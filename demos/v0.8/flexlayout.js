/*
 * ATTENTION: The "eval" devtool has been used (maybe by default in mode: "development").
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
(function webpackUniversalModuleDefinition(root, factory) {
	if(typeof exports === 'object' && typeof module === 'object')
		module.exports = factory(require("react"), require("react-dom"));
	else if(typeof define === 'function' && define.amd)
		define(["react", "react-dom"], factory);
	else if(typeof exports === 'object')
		exports["FlexLayout"] = factory(require("react"), require("react-dom"));
	else
		root["FlexLayout"] = factory(root["React"], root["ReactDOM"]);
})(self, (__WEBPACK_EXTERNAL_MODULE_react__, __WEBPACK_EXTERNAL_MODULE_react_dom__) => {
return /******/ (() => { // webpackBootstrap
/******/ 	"use strict";
/******/ 	var __webpack_modules__ = ({

/***/ "./node_modules/.pnpm/react-dom@18.3.1_react@18.3.1/node_modules/react-dom/client.js":
/*!*******************************************************************************************!*\
  !*** ./node_modules/.pnpm/react-dom@18.3.1_react@18.3.1/node_modules/react-dom/client.js ***!
  \*******************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\n\nvar m = __webpack_require__(/*! react-dom */ \"react-dom\");\nif (false) {} else {\n  var i = m.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED;\n  exports.createRoot = function(c, o) {\n    i.usingClientEntryPoint = true;\n    try {\n      return m.createRoot(c, o);\n    } finally {\n      i.usingClientEntryPoint = false;\n    }\n  };\n  exports.hydrateRoot = function(c, h, o) {\n    i.usingClientEntryPoint = true;\n    try {\n      return m.hydrateRoot(c, h, o);\n    } finally {\n      i.usingClientEntryPoint = false;\n    }\n  };\n}\n\n\n//# sourceURL=webpack://FlexLayout/./node_modules/.pnpm/react-dom@18.3.1_react@18.3.1/node_modules/react-dom/client.js?");

/***/ }),

/***/ "./src/Attribute.ts":
/*!**************************!*\
  !*** ./src/Attribute.ts ***!
  \**************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   Attribute: () => (/* binding */ Attribute)\n/* harmony export */ });\n/** @internal */\nclass Attribute {\n    constructor(name, modelName, defaultValue, alwaysWriteJson) {\n        this.name = name;\n        this.alias = undefined;\n        this.modelName = modelName;\n        this.defaultValue = defaultValue;\n        this.alwaysWriteJson = alwaysWriteJson;\n        this.required = false;\n        this.fixed = false;\n        this.type = \"any\";\n    }\n    setType(value) {\n        this.type = value;\n        return this;\n    }\n    setAlias(value) {\n        this.alias = value;\n        return this;\n    }\n    setDescription(value) {\n        this.description = value;\n    }\n    setRequired() {\n        this.required = true;\n        return this;\n    }\n    setFixed() {\n        this.fixed = true;\n        return this;\n    }\n    // sets modelAttr for nodes, and nodeAttr for model\n    setpairedAttr(value) {\n        this.pairedAttr = value;\n    }\n    setPairedType(value) {\n        this.pairedType = value;\n    }\n}\nAttribute.NUMBER = \"number\";\nAttribute.STRING = \"string\";\nAttribute.BOOLEAN = \"boolean\";\n\n\n//# sourceURL=webpack://FlexLayout/./src/Attribute.ts?");

/***/ }),

/***/ "./src/AttributeDefinitions.ts":
/*!*************************************!*\
  !*** ./src/AttributeDefinitions.ts ***!
  \*************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   AttributeDefinitions: () => (/* binding */ AttributeDefinitions)\n/* harmony export */ });\n/* harmony import */ var _Attribute__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Attribute */ \"./src/Attribute.ts\");\n\n/** @internal */\nclass AttributeDefinitions {\n    constructor() {\n        this.attributes = [];\n        this.nameToAttribute = new Map();\n    }\n    addWithAll(name, modelName, defaultValue, alwaysWriteJson) {\n        const attr = new _Attribute__WEBPACK_IMPORTED_MODULE_0__.Attribute(name, modelName, defaultValue, alwaysWriteJson);\n        this.attributes.push(attr);\n        this.nameToAttribute.set(name, attr);\n        return attr;\n    }\n    addInherited(name, modelName) {\n        return this.addWithAll(name, modelName, undefined, false);\n    }\n    add(name, defaultValue, alwaysWriteJson) {\n        return this.addWithAll(name, undefined, defaultValue, alwaysWriteJson);\n    }\n    getAttributes() {\n        return this.attributes;\n    }\n    getModelName(name) {\n        const conversion = this.nameToAttribute.get(name);\n        if (conversion !== undefined) {\n            return conversion.modelName;\n        }\n        return undefined;\n    }\n    toJson(jsonObj, obj) {\n        for (const attr of this.attributes) {\n            const fromValue = obj[attr.name];\n            if (attr.alwaysWriteJson || fromValue !== attr.defaultValue) {\n                jsonObj[attr.name] = fromValue;\n            }\n        }\n    }\n    fromJson(jsonObj, obj) {\n        for (const attr of this.attributes) {\n            let fromValue = jsonObj[attr.name];\n            if (fromValue === undefined && attr.alias) {\n                fromValue = jsonObj[attr.alias];\n            }\n            if (fromValue === undefined) {\n                obj[attr.name] = attr.defaultValue;\n            }\n            else {\n                obj[attr.name] = fromValue;\n            }\n        }\n    }\n    update(jsonObj, obj) {\n        for (const attr of this.attributes) {\n            if (jsonObj.hasOwnProperty(attr.name)) {\n                const fromValue = jsonObj[attr.name];\n                if (fromValue === undefined) {\n                    delete obj[attr.name];\n                }\n                else {\n                    obj[attr.name] = fromValue;\n                }\n            }\n        }\n    }\n    setDefaults(obj) {\n        for (const attr of this.attributes) {\n            obj[attr.name] = attr.defaultValue;\n        }\n    }\n    pairAttributes(type, childAttributes) {\n        for (const attr of childAttributes.attributes) {\n            if (attr.modelName && this.nameToAttribute.has(attr.modelName)) {\n                const pairedAttr = this.nameToAttribute.get(attr.modelName);\n                pairedAttr.setpairedAttr(attr);\n                attr.setpairedAttr(pairedAttr);\n                pairedAttr.setPairedType(type);\n            }\n        }\n    }\n    toTypescriptInterface(name, parentAttributes) {\n        var _a, _b;\n        const lines = [];\n        const sorted = this.attributes.sort((a, b) => a.name.localeCompare(b.name));\n        // const sorted = this.attributes;\n        lines.push(\"export interface I\" + name + \"Attributes {\");\n        for (let i = 0; i < sorted.length; i++) {\n            const c = sorted[i];\n            let type = c.type;\n            let defaultValue = undefined;\n            let attr = c;\n            let inherited = undefined;\n            if (attr.defaultValue !== undefined) {\n                defaultValue = attr.defaultValue;\n            }\n            else if (attr.modelName !== undefined\n                && parentAttributes !== undefined\n                && parentAttributes.nameToAttribute.get(attr.modelName) !== undefined) {\n                inherited = attr.modelName;\n                attr = parentAttributes.nameToAttribute.get(inherited);\n                defaultValue = attr.defaultValue;\n                type = attr.type;\n            }\n            let defValue = JSON.stringify(defaultValue);\n            const required = attr.required ? \"\" : \"?\";\n            let sb = \"\\t/**\\n\\t  \";\n            if (c.description) {\n                sb += c.description;\n            }\n            else if (c.pairedType && ((_a = c.pairedAttr) === null || _a === void 0 ? void 0 : _a.description)) {\n                sb += `Value for ${c.pairedType} attribute ${c.pairedAttr.name} if not overridden`;\n                sb += \"\\n\\n\\t  \";\n                sb += (_b = c.pairedAttr) === null || _b === void 0 ? void 0 : _b.description;\n            }\n            sb += \"\\n\\n\\t  \";\n            if (c.fixed) {\n                sb += `Fixed value: ${defValue}`;\n            }\n            else if (inherited) {\n                sb += `Default: inherited from Global attribute ${c.modelName} (default ${defValue})`;\n            }\n            else {\n                sb += `Default: ${defValue}`;\n            }\n            sb += \"\\n\\t */\";\n            lines.push(sb);\n            lines.push(\"\\t\" + c.name + required + \": \" + type + \";\\n\");\n        }\n        lines.push(\"}\");\n        return lines.join(\"\\n\");\n    }\n}\n\n\n//# sourceURL=webpack://FlexLayout/./src/AttributeDefinitions.ts?");

/***/ }),

/***/ "./src/DockLocation.ts":
/*!*****************************!*\
  !*** ./src/DockLocation.ts ***!
  \*****************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   DockLocation: () => (/* binding */ DockLocation)\n/* harmony export */ });\n/* harmony import */ var _Orientation__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Orientation */ \"./src/Orientation.ts\");\n/* harmony import */ var _Rect__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./Rect */ \"./src/Rect.ts\");\n\n\nclass DockLocation {\n    /** @internal */\n    static getByName(name) {\n        return DockLocation.values.get(name);\n    }\n    /** @internal */\n    static getLocation(rect, x, y) {\n        x = (x - rect.x) / rect.width;\n        y = (y - rect.y) / rect.height;\n        if (x >= 0.25 && x < 0.75 && y >= 0.25 && y < 0.75) {\n            return DockLocation.CENTER;\n        }\n        // Whether or not the point is in the bottom-left half of the rect\n        // +-----+\n        // |\\    |\n        // |x\\   |\n        // |xx\\  |\n        // |xxx\\ |\n        // |xxxx\\|\n        // +-----+\n        const bl = y >= x;\n        // Whether or not the point is in the bottom-right half of the rect\n        // +-----+\n        // |    /|\n        // |   /x|\n        // |  /xx|\n        // | /xxx|\n        // |/xxxx|\n        // +-----+\n        const br = y >= 1 - x;\n        if (bl) {\n            return br ? DockLocation.BOTTOM : DockLocation.LEFT;\n        }\n        else {\n            return br ? DockLocation.RIGHT : DockLocation.TOP;\n        }\n    }\n    /** @internal */\n    constructor(_name, _orientation, _indexPlus) {\n        this.name = _name;\n        this.orientation = _orientation;\n        this.indexPlus = _indexPlus;\n        DockLocation.values.set(this.name, this);\n    }\n    getName() {\n        return this.name;\n    }\n    getOrientation() {\n        return this.orientation;\n    }\n    /** @internal */\n    getDockRect(r) {\n        if (this === DockLocation.TOP) {\n            return new _Rect__WEBPACK_IMPORTED_MODULE_1__.Rect(r.x, r.y, r.width, r.height / 2);\n        }\n        else if (this === DockLocation.BOTTOM) {\n            return new _Rect__WEBPACK_IMPORTED_MODULE_1__.Rect(r.x, r.getBottom() - r.height / 2, r.width, r.height / 2);\n        }\n        if (this === DockLocation.LEFT) {\n            return new _Rect__WEBPACK_IMPORTED_MODULE_1__.Rect(r.x, r.y, r.width / 2, r.height);\n        }\n        else if (this === DockLocation.RIGHT) {\n            return new _Rect__WEBPACK_IMPORTED_MODULE_1__.Rect(r.getRight() - r.width / 2, r.y, r.width / 2, r.height);\n        }\n        else {\n            return r.clone();\n        }\n    }\n    /** @internal */\n    split(rect, size) {\n        if (this === DockLocation.TOP) {\n            const r1 = new _Rect__WEBPACK_IMPORTED_MODULE_1__.Rect(rect.x, rect.y, rect.width, size);\n            const r2 = new _Rect__WEBPACK_IMPORTED_MODULE_1__.Rect(rect.x, rect.y + size, rect.width, rect.height - size);\n            return { start: r1, end: r2 };\n        }\n        else if (this === DockLocation.LEFT) {\n            const r1 = new _Rect__WEBPACK_IMPORTED_MODULE_1__.Rect(rect.x, rect.y, size, rect.height);\n            const r2 = new _Rect__WEBPACK_IMPORTED_MODULE_1__.Rect(rect.x + size, rect.y, rect.width - size, rect.height);\n            return { start: r1, end: r2 };\n        }\n        if (this === DockLocation.RIGHT) {\n            const r1 = new _Rect__WEBPACK_IMPORTED_MODULE_1__.Rect(rect.getRight() - size, rect.y, size, rect.height);\n            const r2 = new _Rect__WEBPACK_IMPORTED_MODULE_1__.Rect(rect.x, rect.y, rect.width - size, rect.height);\n            return { start: r1, end: r2 };\n        }\n        else {\n            // if (this === DockLocation.BOTTOM) {\n            const r1 = new _Rect__WEBPACK_IMPORTED_MODULE_1__.Rect(rect.x, rect.getBottom() - size, rect.width, size);\n            const r2 = new _Rect__WEBPACK_IMPORTED_MODULE_1__.Rect(rect.x, rect.y, rect.width, rect.height - size);\n            return { start: r1, end: r2 };\n        }\n    }\n    /** @internal */\n    reflect() {\n        if (this === DockLocation.TOP) {\n            return DockLocation.BOTTOM;\n        }\n        else if (this === DockLocation.LEFT) {\n            return DockLocation.RIGHT;\n        }\n        if (this === DockLocation.RIGHT) {\n            return DockLocation.LEFT;\n        }\n        else {\n            // if (this === DockLocation.BOTTOM) {\n            return DockLocation.TOP;\n        }\n    }\n    toString() {\n        return \"(DockLocation: name=\" + this.name + \", orientation=\" + this.orientation + \")\";\n    }\n}\nDockLocation.values = new Map();\nDockLocation.TOP = new DockLocation(\"top\", _Orientation__WEBPACK_IMPORTED_MODULE_0__.Orientation.VERT, 0);\nDockLocation.BOTTOM = new DockLocation(\"bottom\", _Orientation__WEBPACK_IMPORTED_MODULE_0__.Orientation.VERT, 1);\nDockLocation.LEFT = new DockLocation(\"left\", _Orientation__WEBPACK_IMPORTED_MODULE_0__.Orientation.HORZ, 0);\nDockLocation.RIGHT = new DockLocation(\"right\", _Orientation__WEBPACK_IMPORTED_MODULE_0__.Orientation.HORZ, 1);\nDockLocation.CENTER = new DockLocation(\"center\", _Orientation__WEBPACK_IMPORTED_MODULE_0__.Orientation.VERT, 0);\n\n\n//# sourceURL=webpack://FlexLayout/./src/DockLocation.ts?");

/***/ }),

/***/ "./src/DropInfo.ts":
/*!*************************!*\
  !*** ./src/DropInfo.ts ***!
  \*************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   DropInfo: () => (/* binding */ DropInfo)\n/* harmony export */ });\nclass DropInfo {\n    constructor(node, rect, location, index, className) {\n        this.node = node;\n        this.rect = rect;\n        this.location = location;\n        this.index = index;\n        this.className = className;\n    }\n}\n\n\n//# sourceURL=webpack://FlexLayout/./src/DropInfo.ts?");

/***/ }),

/***/ "./src/I18nLabel.ts":
/*!**************************!*\
  !*** ./src/I18nLabel.ts ***!
  \**************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   I18nLabel: () => (/* binding */ I18nLabel)\n/* harmony export */ });\nvar I18nLabel;\n(function (I18nLabel) {\n    I18nLabel[\"Close_Tab\"] = \"Close\";\n    I18nLabel[\"Close_Tabset\"] = \"Close tab set\";\n    I18nLabel[\"Active_Tabset\"] = \"Active tab set\";\n    I18nLabel[\"Move_Tabset\"] = \"Move tab set\";\n    I18nLabel[\"Move_Tabs\"] = \"Move tabs(?)\";\n    I18nLabel[\"Maximize\"] = \"Maximize tab set\";\n    I18nLabel[\"Restore\"] = \"Restore tab set\";\n    I18nLabel[\"Popout_Tab\"] = \"Popout selected tab\";\n    I18nLabel[\"Overflow_Menu_Tooltip\"] = \"Hidden tabs\";\n    I18nLabel[\"Error_rendering_component\"] = \"Error rendering component\";\n})(I18nLabel || (I18nLabel = {}));\n\n\n//# sourceURL=webpack://FlexLayout/./src/I18nLabel.ts?");

/***/ }),

/***/ "./src/Orientation.ts":
/*!****************************!*\
  !*** ./src/Orientation.ts ***!
  \****************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   Orientation: () => (/* binding */ Orientation)\n/* harmony export */ });\nclass Orientation {\n    static flip(from) {\n        if (from === Orientation.HORZ) {\n            return Orientation.VERT;\n        }\n        else {\n            return Orientation.HORZ;\n        }\n    }\n    /** @internal */\n    constructor(name) {\n        this._name = name;\n    }\n    getName() {\n        return this._name;\n    }\n    toString() {\n        return this._name;\n    }\n}\nOrientation.HORZ = new Orientation(\"horz\");\nOrientation.VERT = new Orientation(\"vert\");\n\n\n//# sourceURL=webpack://FlexLayout/./src/Orientation.ts?");

/***/ }),

/***/ "./src/Rect.ts":
/*!*********************!*\
  !*** ./src/Rect.ts ***!
  \*********************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   Rect: () => (/* binding */ Rect)\n/* harmony export */ });\n/* harmony import */ var _Orientation__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Orientation */ \"./src/Orientation.ts\");\n\nclass Rect {\n    static empty() {\n        return new Rect(0, 0, 0, 0);\n    }\n    static fromJson(json) {\n        return new Rect(json.x, json.y, json.width, json.height);\n    }\n    constructor(x, y, width, height) {\n        this.x = x;\n        this.y = y;\n        this.width = width;\n        this.height = height;\n    }\n    toJson() {\n        return { x: this.x, y: this.y, width: this.width, height: this.height };\n    }\n    snap(round) {\n        this.x = Math.round(this.x / round) * round;\n        this.y = Math.round(this.y / round) * round;\n        this.width = Math.round(this.width / round) * round;\n        this.height = Math.round(this.height / round) * round;\n    }\n    static getBoundingClientRect(element) {\n        let { x, y, width, height } = element.getBoundingClientRect();\n        return new Rect(x, y, width, height);\n    }\n    static getContentRect(element) {\n        const rect = element.getBoundingClientRect();\n        const style = window.getComputedStyle(element);\n        const paddingLeft = parseFloat(style.paddingLeft);\n        const paddingRight = parseFloat(style.paddingRight);\n        const paddingTop = parseFloat(style.paddingTop);\n        const paddingBottom = parseFloat(style.paddingBottom);\n        const borderLeftWidth = parseFloat(style.borderLeftWidth);\n        const borderRightWidth = parseFloat(style.borderRightWidth);\n        const borderTopWidth = parseFloat(style.borderTopWidth);\n        const borderBottomWidth = parseFloat(style.borderBottomWidth);\n        const contentWidth = rect.width - borderLeftWidth - paddingLeft - paddingRight - borderRightWidth;\n        const contentHeight = rect.height - borderTopWidth - paddingTop - paddingBottom - borderBottomWidth;\n        return new Rect(rect.left + borderLeftWidth + paddingLeft, rect.top + borderTopWidth + paddingTop, contentWidth, contentHeight);\n    }\n    static fromDomRect(domRect) {\n        return new Rect(domRect.x, domRect.y, domRect.width, domRect.height);\n    }\n    relativeTo(r) {\n        return new Rect(this.x - r.x, this.y - r.y, this.width, this.height);\n    }\n    clone() {\n        return new Rect(this.x, this.y, this.width, this.height);\n    }\n    equals(rect) {\n        return this.x === (rect === null || rect === void 0 ? void 0 : rect.x) && this.y === (rect === null || rect === void 0 ? void 0 : rect.y) && this.width === (rect === null || rect === void 0 ? void 0 : rect.width) && this.height === (rect === null || rect === void 0 ? void 0 : rect.height);\n    }\n    equalSize(rect) {\n        return this.width === (rect === null || rect === void 0 ? void 0 : rect.width) && this.height === (rect === null || rect === void 0 ? void 0 : rect.height);\n    }\n    getBottom() {\n        return this.y + this.height;\n    }\n    getRight() {\n        return this.x + this.width;\n    }\n    getCenter() {\n        return { x: this.x + this.width / 2, y: this.y + this.height / 2 };\n    }\n    positionElement(element, position) {\n        this.styleWithPosition(element.style, position);\n    }\n    styleWithPosition(style, position = \"absolute\") {\n        style.left = this.x + \"px\";\n        style.top = this.y + \"px\";\n        style.width = Math.max(0, this.width) + \"px\"; // need Math.max to prevent -ve, cause error in IE\n        style.height = Math.max(0, this.height) + \"px\";\n        style.position = position;\n        return style;\n    }\n    contains(x, y) {\n        if (this.x <= x && x <= this.getRight() && this.y <= y && y <= this.getBottom()) {\n            return true;\n        }\n        else {\n            return false;\n        }\n    }\n    removeInsets(insets) {\n        return new Rect(this.x + insets.left, this.y + insets.top, Math.max(0, this.width - insets.left - insets.right), Math.max(0, this.height - insets.top - insets.bottom));\n    }\n    centerInRect(outerRect) {\n        this.x = (outerRect.width - this.width) / 2;\n        this.y = (outerRect.height - this.height) / 2;\n    }\n    /** @internal */\n    _getSize(orientation) {\n        let prefSize = this.width;\n        if (orientation === _Orientation__WEBPACK_IMPORTED_MODULE_0__.Orientation.VERT) {\n            prefSize = this.height;\n        }\n        return prefSize;\n    }\n    toString() {\n        return \"(Rect: x=\" + this.x + \", y=\" + this.y + \", width=\" + this.width + \", height=\" + this.height + \")\";\n    }\n}\n\n\n//# sourceURL=webpack://FlexLayout/./src/Rect.ts?");

/***/ }),

/***/ "./src/Types.ts":
/*!**********************!*\
  !*** ./src/Types.ts ***!
  \**********************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   CLASSES: () => (/* binding */ CLASSES)\n/* harmony export */ });\nvar CLASSES;\n(function (CLASSES) {\n    CLASSES[\"FLEXLAYOUT__BORDER\"] = \"flexlayout__border\";\n    CLASSES[\"FLEXLAYOUT__BORDER_\"] = \"flexlayout__border_\";\n    CLASSES[\"FLEXLAYOUT__BORDER_TAB_CONTENTS\"] = \"flexlayout__border_tab_contents\";\n    CLASSES[\"FLEXLAYOUT__BORDER_BUTTON\"] = \"flexlayout__border_button\";\n    CLASSES[\"FLEXLAYOUT__BORDER_BUTTON_\"] = \"flexlayout__border_button_\";\n    CLASSES[\"FLEXLAYOUT__BORDER_BUTTON_CONTENT\"] = \"flexlayout__border_button_content\";\n    CLASSES[\"FLEXLAYOUT__BORDER_BUTTON_LEADING\"] = \"flexlayout__border_button_leading\";\n    CLASSES[\"FLEXLAYOUT__BORDER_BUTTON_TRAILING\"] = \"flexlayout__border_button_trailing\";\n    CLASSES[\"FLEXLAYOUT__BORDER_BUTTON__SELECTED\"] = \"flexlayout__border_button--selected\";\n    CLASSES[\"FLEXLAYOUT__BORDER_BUTTON__UNSELECTED\"] = \"flexlayout__border_button--unselected\";\n    CLASSES[\"FLEXLAYOUT__BORDER_TOOLBAR_BUTTON_OVERFLOW\"] = \"flexlayout__border_toolbar_button_overflow\";\n    CLASSES[\"FLEXLAYOUT__BORDER_TOOLBAR_BUTTON_OVERFLOW_\"] = \"flexlayout__border_toolbar_button_overflow_\";\n    CLASSES[\"FLEXLAYOUT__BORDER_INNER\"] = \"flexlayout__border_inner\";\n    CLASSES[\"FLEXLAYOUT__BORDER_INNER_\"] = \"flexlayout__border_inner_\";\n    CLASSES[\"FLEXLAYOUT__BORDER_INNER_TAB_CONTAINER\"] = \"flexlayout__border_inner_tab_container\";\n    CLASSES[\"FLEXLAYOUT__BORDER_INNER_TAB_CONTAINER_\"] = \"flexlayout__border_inner_tab_container_\";\n    CLASSES[\"FLEXLAYOUT__BORDER_TAB_DIVIDER\"] = \"flexlayout__border_tab_divider\";\n    CLASSES[\"FLEXLAYOUT__BORDER_SIZER\"] = \"flexlayout__border_sizer\";\n    CLASSES[\"FLEXLAYOUT__BORDER_TOOLBAR\"] = \"flexlayout__border_toolbar\";\n    CLASSES[\"FLEXLAYOUT__BORDER_TOOLBAR_\"] = \"flexlayout__border_toolbar_\";\n    CLASSES[\"FLEXLAYOUT__BORDER_TOOLBAR_BUTTON\"] = \"flexlayout__border_toolbar_button\";\n    CLASSES[\"FLEXLAYOUT__BORDER_TOOLBAR_BUTTON_FLOAT\"] = \"flexlayout__border_toolbar_button-float\";\n    CLASSES[\"FLEXLAYOUT__DRAG_RECT\"] = \"flexlayout__drag_rect\";\n    CLASSES[\"FLEXLAYOUT__EDGE_RECT\"] = \"flexlayout__edge_rect\";\n    CLASSES[\"FLEXLAYOUT__EDGE_RECT_TOP\"] = \"flexlayout__edge_rect_top\";\n    CLASSES[\"FLEXLAYOUT__EDGE_RECT_LEFT\"] = \"flexlayout__edge_rect_left\";\n    CLASSES[\"FLEXLAYOUT__EDGE_RECT_BOTTOM\"] = \"flexlayout__edge_rect_bottom\";\n    CLASSES[\"FLEXLAYOUT__EDGE_RECT_RIGHT\"] = \"flexlayout__edge_rect_right\";\n    CLASSES[\"FLEXLAYOUT__ERROR_BOUNDARY_CONTAINER\"] = \"flexlayout__error_boundary_container\";\n    CLASSES[\"FLEXLAYOUT__ERROR_BOUNDARY_CONTENT\"] = \"flexlayout__error_boundary_content\";\n    CLASSES[\"FLEXLAYOUT__FLOATING_WINDOW_CONTENT\"] = \"flexlayout__floating_window_content\";\n    CLASSES[\"FLEXLAYOUT__FLOATING_WINDOW_TAB\"] = \"flexlayout__floating_window_tab\";\n    CLASSES[\"FLEXLAYOUT__LAYOUT\"] = \"flexlayout__layout\";\n    CLASSES[\"FLEXLAYOUT__LAYOUT_MOVEABLES\"] = \"flexlayout__layout_moveables\";\n    CLASSES[\"FLEXLAYOUT__LAYOUT_OVERLAY\"] = \"flexlayout__layout_overlay\";\n    CLASSES[\"FLEXLAYOUT__LAYOUT_TAB_STAMPS\"] = \"flexlayout__layout_tab_stamps\";\n    CLASSES[\"FLEXLAYOUT__LAYOUT_MAIN\"] = \"flexlayout__layout_main\";\n    CLASSES[\"FLEXLAYOUT__LAYOUT_BORDER_CONTAINER\"] = \"flexlayout__layout_border_container\";\n    CLASSES[\"FLEXLAYOUT__LAYOUT_BORDER_CONTAINER_INNER\"] = \"flexlayout__layout_border_container_inner\";\n    CLASSES[\"FLEXLAYOUT__OUTLINE_RECT\"] = \"flexlayout__outline_rect\";\n    CLASSES[\"FLEXLAYOUT__OUTLINE_RECT_EDGE\"] = \"flexlayout__outline_rect_edge\";\n    CLASSES[\"FLEXLAYOUT__SPLITTER\"] = \"flexlayout__splitter\";\n    CLASSES[\"FLEXLAYOUT__SPLITTER_EXTRA\"] = \"flexlayout__splitter_extra\";\n    CLASSES[\"FLEXLAYOUT__SPLITTER_\"] = \"flexlayout__splitter_\";\n    CLASSES[\"FLEXLAYOUT__SPLITTER_BORDER\"] = \"flexlayout__splitter_border\";\n    CLASSES[\"FLEXLAYOUT__SPLITTER_DRAG\"] = \"flexlayout__splitter_drag\";\n    CLASSES[\"FLEXLAYOUT__SPLITTER_HANDLE\"] = \"flexlayout__splitter_handle\";\n    CLASSES[\"FLEXLAYOUT__SPLITTER_HANDLE_HORZ\"] = \"flexlayout__splitter_handle_horz\";\n    CLASSES[\"FLEXLAYOUT__SPLITTER_HANDLE_VERT\"] = \"flexlayout__splitter_handle_vert\";\n    CLASSES[\"FLEXLAYOUT__ROW\"] = \"flexlayout__row\";\n    CLASSES[\"FLEXLAYOUT__TAB\"] = \"flexlayout__tab\";\n    CLASSES[\"FLEXLAYOUT__TAB_POSITION\"] = \"flexlayout__tab_position\";\n    CLASSES[\"FLEXLAYOUT__TAB_MOVEABLE\"] = \"flexlayout__tab_moveable\";\n    CLASSES[\"FLEXLAYOUT__TAB_OVERLAY\"] = \"flexlayout__tab_overlay\";\n    CLASSES[\"FLEXLAYOUT__TABSET\"] = \"flexlayout__tabset\";\n    CLASSES[\"FLEXLAYOUT__TABSET_CONTAINER\"] = \"flexlayout__tabset_container\";\n    CLASSES[\"FLEXLAYOUT__TABSET_HEADER\"] = \"flexlayout__tabset_header\";\n    CLASSES[\"FLEXLAYOUT__TABSET_HEADER_SIZER\"] = \"flexlayout__tabset_header_sizer\";\n    CLASSES[\"FLEXLAYOUT__TABSET_HEADER_CONTENT\"] = \"flexlayout__tabset_header_content\";\n    CLASSES[\"FLEXLAYOUT__TABSET_MAXIMIZED\"] = \"flexlayout__tabset-maximized\";\n    CLASSES[\"FLEXLAYOUT__TABSET_SELECTED\"] = \"flexlayout__tabset-selected\";\n    CLASSES[\"FLEXLAYOUT__TABSET_SIZER\"] = \"flexlayout__tabset_sizer\";\n    CLASSES[\"FLEXLAYOUT__TABSET_TAB_DIVIDER\"] = \"flexlayout__tabset_tab_divider\";\n    CLASSES[\"FLEXLAYOUT__TABSET_CONTENT\"] = \"flexlayout__tabset_content\";\n    CLASSES[\"FLEXLAYOUT__TABSET_TABBAR_INNER\"] = \"flexlayout__tabset_tabbar_inner\";\n    CLASSES[\"FLEXLAYOUT__TABSET_TABBAR_INNER_\"] = \"flexlayout__tabset_tabbar_inner_\";\n    CLASSES[\"FLEXLAYOUT__TABSET_TABBAR_INNER_TAB_CONTAINER\"] = \"flexlayout__tabset_tabbar_inner_tab_container\";\n    CLASSES[\"FLEXLAYOUT__TABSET_TABBAR_INNER_TAB_CONTAINER_\"] = \"flexlayout__tabset_tabbar_inner_tab_container_\";\n    CLASSES[\"FLEXLAYOUT__TABSET_TABBAR_OUTER\"] = \"flexlayout__tabset_tabbar_outer\";\n    CLASSES[\"FLEXLAYOUT__TABSET_TABBAR_OUTER_\"] = \"flexlayout__tabset_tabbar_outer_\";\n    CLASSES[\"FLEXLAYOUT__TAB_BORDER\"] = \"flexlayout__tab_border\";\n    CLASSES[\"FLEXLAYOUT__TAB_BORDER_\"] = \"flexlayout__tab_border_\";\n    CLASSES[\"FLEXLAYOUT__TAB_BUTTON\"] = \"flexlayout__tab_button\";\n    CLASSES[\"FLEXLAYOUT__TAB_BUTTON_STRETCH\"] = \"flexlayout__tab_button_stretch\";\n    CLASSES[\"FLEXLAYOUT__TAB_BUTTON_CONTENT\"] = \"flexlayout__tab_button_content\";\n    CLASSES[\"FLEXLAYOUT__TAB_BUTTON_LEADING\"] = \"flexlayout__tab_button_leading\";\n    CLASSES[\"FLEXLAYOUT__TAB_BUTTON_OVERFLOW\"] = \"flexlayout__tab_button_overflow\";\n    CLASSES[\"FLEXLAYOUT__TAB_BUTTON_OVERFLOW_COUNT\"] = \"flexlayout__tab_button_overflow_count\";\n    CLASSES[\"FLEXLAYOUT__TAB_BUTTON_TEXTBOX\"] = \"flexlayout__tab_button_textbox\";\n    CLASSES[\"FLEXLAYOUT__TAB_BUTTON_TRAILING\"] = \"flexlayout__tab_button_trailing\";\n    CLASSES[\"FLEXLAYOUT__TAB_BUTTON_STAMP\"] = \"flexlayout__tab_button_stamp\";\n    CLASSES[\"FLEXLAYOUT__TAB_FLOATING\"] = \"flexlayout__tab_floating\";\n    CLASSES[\"FLEXLAYOUT__TAB_FLOATING_INNER\"] = \"flexlayout__tab_floating_inner\";\n    CLASSES[\"FLEXLAYOUT__TAB_TOOLBAR\"] = \"flexlayout__tab_toolbar\";\n    CLASSES[\"FLEXLAYOUT__TAB_TOOLBAR_BUTTON\"] = \"flexlayout__tab_toolbar_button\";\n    CLASSES[\"FLEXLAYOUT__TAB_TOOLBAR_ICON\"] = \"flexlayout__tab_toolbar_icon\";\n    CLASSES[\"FLEXLAYOUT__TAB_TOOLBAR_BUTTON_\"] = \"flexlayout__tab_toolbar_button-\";\n    CLASSES[\"FLEXLAYOUT__TAB_TOOLBAR_BUTTON_FLOAT\"] = \"flexlayout__tab_toolbar_button-float\";\n    CLASSES[\"FLEXLAYOUT__TAB_TOOLBAR_STICKY_BUTTONS_CONTAINER\"] = \"flexlayout__tab_toolbar_sticky_buttons_container\";\n    CLASSES[\"FLEXLAYOUT__TAB_TOOLBAR_BUTTON_CLOSE\"] = \"flexlayout__tab_toolbar_button-close\";\n    CLASSES[\"FLEXLAYOUT__POPUP_MENU_CONTAINER\"] = \"flexlayout__popup_menu_container\";\n    CLASSES[\"FLEXLAYOUT__POPUP_MENU_ITEM\"] = \"flexlayout__popup_menu_item\";\n    CLASSES[\"FLEXLAYOUT__POPUP_MENU\"] = \"flexlayout__popup_menu\";\n})(CLASSES || (CLASSES = {}));\n\n\n//# sourceURL=webpack://FlexLayout/./src/Types.ts?");

/***/ }),

/***/ "./src/index.ts":
/*!**********************!*\
  !*** ./src/index.ts ***!
  \**********************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   Action: () => (/* reexport safe */ _model_Action__WEBPACK_IMPORTED_MODULE_1__.Action),\n/* harmony export */   Actions: () => (/* reexport safe */ _model_Actions__WEBPACK_IMPORTED_MODULE_2__.Actions),\n/* harmony export */   BorderNode: () => (/* reexport safe */ _model_BorderNode__WEBPACK_IMPORTED_MODULE_3__.BorderNode),\n/* harmony export */   BorderSet: () => (/* reexport safe */ _model_BorderSet__WEBPACK_IMPORTED_MODULE_4__.BorderSet),\n/* harmony export */   CLASSES: () => (/* reexport safe */ _Types__WEBPACK_IMPORTED_MODULE_20__.CLASSES),\n/* harmony export */   DefaultMax: () => (/* reexport safe */ _model_Model__WEBPACK_IMPORTED_MODULE_9__.DefaultMax),\n/* harmony export */   DefaultMin: () => (/* reexport safe */ _model_Model__WEBPACK_IMPORTED_MODULE_9__.DefaultMin),\n/* harmony export */   DockLocation: () => (/* reexport safe */ _DockLocation__WEBPACK_IMPORTED_MODULE_15__.DockLocation),\n/* harmony export */   DropInfo: () => (/* reexport safe */ _DropInfo__WEBPACK_IMPORTED_MODULE_16__.DropInfo),\n/* harmony export */   I18nLabel: () => (/* reexport safe */ _I18nLabel__WEBPACK_IMPORTED_MODULE_17__.I18nLabel),\n/* harmony export */   ICloseType: () => (/* reexport safe */ _model_ICloseType__WEBPACK_IMPORTED_MODULE_5__.ICloseType),\n/* harmony export */   Layout: () => (/* reexport safe */ _view_Layout__WEBPACK_IMPORTED_MODULE_0__.Layout),\n/* harmony export */   LayoutInternal: () => (/* reexport safe */ _view_Layout__WEBPACK_IMPORTED_MODULE_0__.LayoutInternal),\n/* harmony export */   LayoutWindow: () => (/* reexport safe */ _model_LayoutWindow__WEBPACK_IMPORTED_MODULE_14__.LayoutWindow),\n/* harmony export */   Model: () => (/* reexport safe */ _model_Model__WEBPACK_IMPORTED_MODULE_9__.Model),\n/* harmony export */   Node: () => (/* reexport safe */ _model_Node__WEBPACK_IMPORTED_MODULE_10__.Node),\n/* harmony export */   Orientation: () => (/* reexport safe */ _Orientation__WEBPACK_IMPORTED_MODULE_18__.Orientation),\n/* harmony export */   Rect: () => (/* reexport safe */ _Rect__WEBPACK_IMPORTED_MODULE_19__.Rect),\n/* harmony export */   RowNode: () => (/* reexport safe */ _model_RowNode__WEBPACK_IMPORTED_MODULE_11__.RowNode),\n/* harmony export */   TabNode: () => (/* reexport safe */ _model_TabNode__WEBPACK_IMPORTED_MODULE_12__.TabNode),\n/* harmony export */   TabSetNode: () => (/* reexport safe */ _model_TabSetNode__WEBPACK_IMPORTED_MODULE_13__.TabSetNode)\n/* harmony export */ });\n/* harmony import */ var _view_Layout__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./view/Layout */ \"./src/view/Layout.tsx\");\n/* harmony import */ var _model_Action__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./model/Action */ \"./src/model/Action.ts\");\n/* harmony import */ var _model_Actions__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./model/Actions */ \"./src/model/Actions.ts\");\n/* harmony import */ var _model_BorderNode__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./model/BorderNode */ \"./src/model/BorderNode.ts\");\n/* harmony import */ var _model_BorderSet__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./model/BorderSet */ \"./src/model/BorderSet.ts\");\n/* harmony import */ var _model_ICloseType__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./model/ICloseType */ \"./src/model/ICloseType.ts\");\n/* harmony import */ var _model_IDraggable__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./model/IDraggable */ \"./src/model/IDraggable.ts\");\n/* harmony import */ var _model_IDropTarget__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./model/IDropTarget */ \"./src/model/IDropTarget.ts\");\n/* harmony import */ var _model_IJsonModel__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ./model/IJsonModel */ \"./src/model/IJsonModel.ts\");\n/* harmony import */ var _model_Model__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ./model/Model */ \"./src/model/Model.ts\");\n/* harmony import */ var _model_Node__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! ./model/Node */ \"./src/model/Node.ts\");\n/* harmony import */ var _model_RowNode__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(/*! ./model/RowNode */ \"./src/model/RowNode.ts\");\n/* harmony import */ var _model_TabNode__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__(/*! ./model/TabNode */ \"./src/model/TabNode.ts\");\n/* harmony import */ var _model_TabSetNode__WEBPACK_IMPORTED_MODULE_13__ = __webpack_require__(/*! ./model/TabSetNode */ \"./src/model/TabSetNode.ts\");\n/* harmony import */ var _model_LayoutWindow__WEBPACK_IMPORTED_MODULE_14__ = __webpack_require__(/*! ./model/LayoutWindow */ \"./src/model/LayoutWindow.ts\");\n/* harmony import */ var _DockLocation__WEBPACK_IMPORTED_MODULE_15__ = __webpack_require__(/*! ./DockLocation */ \"./src/DockLocation.ts\");\n/* harmony import */ var _DropInfo__WEBPACK_IMPORTED_MODULE_16__ = __webpack_require__(/*! ./DropInfo */ \"./src/DropInfo.ts\");\n/* harmony import */ var _I18nLabel__WEBPACK_IMPORTED_MODULE_17__ = __webpack_require__(/*! ./I18nLabel */ \"./src/I18nLabel.ts\");\n/* harmony import */ var _Orientation__WEBPACK_IMPORTED_MODULE_18__ = __webpack_require__(/*! ./Orientation */ \"./src/Orientation.ts\");\n/* harmony import */ var _Rect__WEBPACK_IMPORTED_MODULE_19__ = __webpack_require__(/*! ./Rect */ \"./src/Rect.ts\");\n/* harmony import */ var _Types__WEBPACK_IMPORTED_MODULE_20__ = __webpack_require__(/*! ./Types */ \"./src/Types.ts\");\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n//# sourceURL=webpack://FlexLayout/./src/index.ts?");

/***/ }),

/***/ "./src/model/Action.ts":
/*!*****************************!*\
  !*** ./src/model/Action.ts ***!
  \*****************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   Action: () => (/* binding */ Action)\n/* harmony export */ });\nclass Action {\n    constructor(type, data) {\n        this.type = type;\n        this.data = data;\n    }\n}\n\n\n//# sourceURL=webpack://FlexLayout/./src/model/Action.ts?");

/***/ }),

/***/ "./src/model/Actions.ts":
/*!******************************!*\
  !*** ./src/model/Actions.ts ***!
  \******************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   Actions: () => (/* binding */ Actions)\n/* harmony export */ });\n/* harmony import */ var _Action__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Action */ \"./src/model/Action.ts\");\n\n/**\n * The Action creator class for FlexLayout model actions\n */\nclass Actions {\n    /**\n     * Adds a tab node to the given tabset node\n     * @param json the json for the new tab node e.g {type:\"tab\", component:\"table\"}\n     * @param toNodeId the new tab node will be added to the tabset with this node id\n     * @param location the location where the new tab will be added, one of the DockLocation enum values.\n     * @param index for docking to the center this value is the index of the tab, use -1 to add to the end.\n     * @param select (optional) whether to select the new tab, overriding autoSelectTab\n     * @returns {Action} the action\n     */\n    static addNode(json, toNodeId, location, index, select) {\n        return new _Action__WEBPACK_IMPORTED_MODULE_0__.Action(Actions.ADD_NODE, {\n            json,\n            toNode: toNodeId,\n            location: location.getName(),\n            index,\n            select,\n        });\n    }\n    /**\n     * Moves a node (tab or tabset) from one location to another\n     * @param fromNodeId the id of the node to move\n     * @param toNodeId the id of the node to receive the moved node\n     * @param location the location where the moved node will be added, one of the DockLocation enum values.\n     * @param index for docking to the center this value is the index of the tab, use -1 to add to the end.\n     * @param select (optional) whether to select the moved tab(s) in new tabset, overriding autoSelectTab\n     * @returns {Action} the action\n     */\n    static moveNode(fromNodeId, toNodeId, location, index, select) {\n        return new _Action__WEBPACK_IMPORTED_MODULE_0__.Action(Actions.MOVE_NODE, {\n            fromNode: fromNodeId,\n            toNode: toNodeId,\n            location: location.getName(),\n            index,\n            select,\n        });\n    }\n    /**\n     * Deletes a tab node from the layout\n     * @param tabNodeId the id of the tab node to delete\n     * @returns {Action} the action\n     */\n    static deleteTab(tabNodeId) {\n        return new _Action__WEBPACK_IMPORTED_MODULE_0__.Action(Actions.DELETE_TAB, { node: tabNodeId });\n    }\n    /**\n     * Deletes a tabset node and all it's child tab nodes from the layout\n     * @param tabsetNodeId the id of the tabset node to delete\n     * @returns {Action} the action\n     */\n    static deleteTabset(tabsetNodeId) {\n        return new _Action__WEBPACK_IMPORTED_MODULE_0__.Action(Actions.DELETE_TABSET, { node: tabsetNodeId });\n    }\n    /**\n     * Change the given nodes tab text\n     * @param tabNodeId the id of the node to rename\n     * @param text the test of the tab\n     * @returns {Action} the action\n     */\n    static renameTab(tabNodeId, text) {\n        return new _Action__WEBPACK_IMPORTED_MODULE_0__.Action(Actions.RENAME_TAB, { node: tabNodeId, text });\n    }\n    /**\n     * Selects the given tab in its parent tabset\n     * @param tabNodeId the id of the node to set selected\n     * @returns {Action} the action\n     */\n    static selectTab(tabNodeId) {\n        return new _Action__WEBPACK_IMPORTED_MODULE_0__.Action(Actions.SELECT_TAB, { tabNode: tabNodeId });\n    }\n    /**\n     * Set the given tabset node as the active tabset\n     * @param tabsetNodeId the id of the tabset node to set as active\n     * @returns {Action} the action\n     */\n    static setActiveTabset(tabsetNodeId, windowId) {\n        return new _Action__WEBPACK_IMPORTED_MODULE_0__.Action(Actions.SET_ACTIVE_TABSET, { tabsetNode: tabsetNodeId, windowId: windowId });\n    }\n    /**\n     * Adjust the weights of a row, used when the splitter is moved\n     * @param nodeId the row node whose childrens weights are being adjusted\n     * @param weights an array of weights to be applied to the children\n     * @returns {Action} the action\n     */\n    static adjustWeights(nodeId, weights) {\n        return new _Action__WEBPACK_IMPORTED_MODULE_0__.Action(Actions.ADJUST_WEIGHTS, { nodeId, weights });\n    }\n    static adjustBorderSplit(nodeId, pos) {\n        return new _Action__WEBPACK_IMPORTED_MODULE_0__.Action(Actions.ADJUST_BORDER_SPLIT, { node: nodeId, pos });\n    }\n    /**\n     * Maximizes the given tabset\n     * @param tabsetNodeId the id of the tabset to maximize\n     * @returns {Action} the action\n     */\n    static maximizeToggle(tabsetNodeId, windowId) {\n        return new _Action__WEBPACK_IMPORTED_MODULE_0__.Action(Actions.MAXIMIZE_TOGGLE, { node: tabsetNodeId, windowId: windowId });\n    }\n    /**\n     * Updates the global model jsone attributes\n     * @param attributes the json for the model attributes to update (merge into the existing attributes)\n     * @returns {Action} the action\n     */\n    static updateModelAttributes(attributes) {\n        return new _Action__WEBPACK_IMPORTED_MODULE_0__.Action(Actions.UPDATE_MODEL_ATTRIBUTES, { json: attributes });\n    }\n    /**\n     * Updates the given nodes json attributes\n     * @param nodeId the id of the node to update\n     * @param attributes the json attributes to update (merge with the existing attributes)\n     * @returns {Action} the action\n     */\n    static updateNodeAttributes(nodeId, attributes) {\n        return new _Action__WEBPACK_IMPORTED_MODULE_0__.Action(Actions.UPDATE_NODE_ATTRIBUTES, { node: nodeId, json: attributes });\n    }\n    /**\n     * Pops out the given tab node into a new browser window\n     * @param nodeId the tab node to popout\n     * @returns\n     */\n    static popoutTab(nodeId) {\n        return new _Action__WEBPACK_IMPORTED_MODULE_0__.Action(Actions.POPOUT_TAB, { node: nodeId });\n    }\n    /**\n     * Pops out the given tab set node into a new browser window\n     * @param nodeId the tab set node to popout\n     * @returns\n     */\n    static popoutTabset(nodeId) {\n        return new _Action__WEBPACK_IMPORTED_MODULE_0__.Action(Actions.POPOUT_TABSET, { node: nodeId });\n    }\n    /**\n     * Closes the popout window\n     * @param windowId the id of the popout window to close\n     * @returns\n     */\n    static closeWindow(windowId) {\n        return new _Action__WEBPACK_IMPORTED_MODULE_0__.Action(Actions.CLOSE_WINDOW, { windowId });\n    }\n    /**\n     * Creates a new empty popout window with the given layout\n     * @param layout the json layout for the new window\n     * @param rect the window rectangle in screen coordinates\n     * @returns\n     */\n    static createWindow(layout, rect) {\n        return new _Action__WEBPACK_IMPORTED_MODULE_0__.Action(Actions.CREATE_WINDOW, { layout, rect });\n    }\n}\nActions.ADD_NODE = \"FlexLayout_AddNode\";\nActions.MOVE_NODE = \"FlexLayout_MoveNode\";\nActions.DELETE_TAB = \"FlexLayout_DeleteTab\";\nActions.DELETE_TABSET = \"FlexLayout_DeleteTabset\";\nActions.RENAME_TAB = \"FlexLayout_RenameTab\";\nActions.SELECT_TAB = \"FlexLayout_SelectTab\";\nActions.SET_ACTIVE_TABSET = \"FlexLayout_SetActiveTabset\";\nActions.ADJUST_WEIGHTS = \"FlexLayout_AdjustWeights\";\nActions.ADJUST_BORDER_SPLIT = \"FlexLayout_AdjustBorderSplit\";\nActions.MAXIMIZE_TOGGLE = \"FlexLayout_MaximizeToggle\";\nActions.UPDATE_MODEL_ATTRIBUTES = \"FlexLayout_UpdateModelAttributes\";\nActions.UPDATE_NODE_ATTRIBUTES = \"FlexLayout_UpdateNodeAttributes\";\nActions.POPOUT_TAB = \"FlexLayout_PopoutTab\";\nActions.POPOUT_TABSET = \"FlexLayout_PopoutTabset\";\nActions.CLOSE_WINDOW = \"FlexLayout_CloseWindow\";\nActions.CREATE_WINDOW = \"FlexLayout_CreateWindow\";\n\n\n//# sourceURL=webpack://FlexLayout/./src/model/Actions.ts?");

/***/ }),

/***/ "./src/model/BorderNode.ts":
/*!*********************************!*\
  !*** ./src/model/BorderNode.ts ***!
  \*********************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   BorderNode: () => (/* binding */ BorderNode)\n/* harmony export */ });\n/* harmony import */ var _Attribute__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../Attribute */ \"./src/Attribute.ts\");\n/* harmony import */ var _AttributeDefinitions__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../AttributeDefinitions */ \"./src/AttributeDefinitions.ts\");\n/* harmony import */ var _DockLocation__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../DockLocation */ \"./src/DockLocation.ts\");\n/* harmony import */ var _DropInfo__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../DropInfo */ \"./src/DropInfo.ts\");\n/* harmony import */ var _Orientation__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../Orientation */ \"./src/Orientation.ts\");\n/* harmony import */ var _Rect__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../Rect */ \"./src/Rect.ts\");\n/* harmony import */ var _Types__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ../Types */ \"./src/Types.ts\");\n/* harmony import */ var _Model__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./Model */ \"./src/model/Model.ts\");\n/* harmony import */ var _Node__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ./Node */ \"./src/model/Node.ts\");\n/* harmony import */ var _TabNode__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ./TabNode */ \"./src/model/TabNode.ts\");\n/* harmony import */ var _Utils__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! ./Utils */ \"./src/model/Utils.ts\");\n\n\n\n\n\n\n\n\n\n\n\nclass BorderNode extends _Node__WEBPACK_IMPORTED_MODULE_8__.Node {\n    /** @internal */\n    static fromJson(json, model) {\n        const location = _DockLocation__WEBPACK_IMPORTED_MODULE_2__.DockLocation.getByName(json.location);\n        const border = new BorderNode(location, json, model);\n        if (json.children) {\n            border.children = json.children.map((jsonChild) => {\n                const child = _TabNode__WEBPACK_IMPORTED_MODULE_9__.TabNode.fromJson(jsonChild, model);\n                child.setParent(border);\n                return child;\n            });\n        }\n        return border;\n    }\n    /** @internal */\n    constructor(location, json, model) {\n        super(model);\n        /** @internal */\n        this.outerRect = _Rect__WEBPACK_IMPORTED_MODULE_5__.Rect.empty();\n        /** @internal */\n        this.contentRect = _Rect__WEBPACK_IMPORTED_MODULE_5__.Rect.empty();\n        /** @internal */\n        this.tabHeaderRect = _Rect__WEBPACK_IMPORTED_MODULE_5__.Rect.empty();\n        this.location = location;\n        this.attributes.id = `border_${location.getName()}`;\n        BorderNode.attributeDefinitions.fromJson(json, this.attributes);\n        model.addNode(this);\n    }\n    getLocation() {\n        return this.location;\n    }\n    getClassName() {\n        return this.getAttr(\"className\");\n    }\n    isHorizontal() {\n        return this.location.orientation === _Orientation__WEBPACK_IMPORTED_MODULE_4__.Orientation.HORZ;\n    }\n    getSize() {\n        const defaultSize = this.getAttr(\"size\");\n        const selected = this.getSelected();\n        if (selected === -1) {\n            return defaultSize;\n        }\n        else {\n            const tabNode = this.children[selected];\n            const tabBorderSize = this.isHorizontal() ? tabNode.getAttr(\"borderWidth\") : tabNode.getAttr(\"borderHeight\");\n            if (tabBorderSize === -1) {\n                return defaultSize;\n            }\n            else {\n                return tabBorderSize;\n            }\n        }\n    }\n    getMinSize() {\n        const selectedNode = this.getSelectedNode();\n        let min = this.getAttr(\"minSize\");\n        if (selectedNode) {\n            const nodeMin = this.isHorizontal() ? selectedNode.getMinWidth() : selectedNode.getMinHeight();\n            min = Math.max(min, nodeMin);\n        }\n        return min;\n    }\n    getMaxSize() {\n        const selectedNode = this.getSelectedNode();\n        let max = this.getAttr(\"maxSize\");\n        if (selectedNode) {\n            const nodeMax = this.isHorizontal() ? selectedNode.getMaxWidth() : selectedNode.getMaxHeight();\n            max = Math.min(max, nodeMax);\n        }\n        return max;\n    }\n    getSelected() {\n        return this.attributes.selected;\n    }\n    isAutoHide() {\n        return this.getAttr(\"enableAutoHide\");\n    }\n    getSelectedNode() {\n        if (this.getSelected() !== -1) {\n            return this.children[this.getSelected()];\n        }\n        return undefined;\n    }\n    getOrientation() {\n        return this.location.getOrientation();\n    }\n    /**\n     * Returns the config attribute that can be used to store node specific data that\n     * WILL be saved to the json. The config attribute should be changed via the action Actions.updateNodeAttributes rather\n     * than directly, for example:\n     * this.state.model.doAction(\n     *   FlexLayout.Actions.updateNodeAttributes(node.getId(), {config:myConfigObject}));\n     */\n    getConfig() {\n        return this.attributes.config;\n    }\n    isMaximized() {\n        return false;\n    }\n    isShowing() {\n        return this.attributes.show;\n    }\n    toJson() {\n        const json = {};\n        BorderNode.attributeDefinitions.toJson(json, this.attributes);\n        json.location = this.location.getName();\n        json.children = this.children.map((child) => child.toJson());\n        return json;\n    }\n    /** @internal */\n    isAutoSelectTab(whenOpen) {\n        if (whenOpen == null) {\n            whenOpen = this.getSelected() !== -1;\n        }\n        if (whenOpen) {\n            return this.getAttr(\"autoSelectTabWhenOpen\");\n        }\n        else {\n            return this.getAttr(\"autoSelectTabWhenClosed\");\n        }\n    }\n    /** @internal */\n    setSelected(index) {\n        this.attributes.selected = index;\n    }\n    /** @internal */\n    getTabHeaderRect() {\n        return this.tabHeaderRect;\n    }\n    /** @internal */\n    setTabHeaderRect(r) {\n        this.tabHeaderRect = r;\n    }\n    /** @internal */\n    getOuterRect() {\n        return this.outerRect;\n    }\n    /** @internal */\n    setOuterRect(r) {\n        this.outerRect = r;\n    }\n    /** @internal */\n    getRect() {\n        return this.tabHeaderRect;\n    }\n    /** @internal */\n    getContentRect() {\n        return this.contentRect;\n    }\n    /** @internal */\n    setContentRect(r) {\n        this.contentRect = r;\n    }\n    /** @internal */\n    isEnableDrop() {\n        return this.getAttr(\"enableDrop\");\n    }\n    /** @internal */\n    setSize(pos) {\n        const selected = this.getSelected();\n        if (selected === -1) {\n            this.attributes.size = pos;\n        }\n        else {\n            const tabNode = this.children[selected];\n            const tabBorderSize = this.isHorizontal() ? tabNode.getAttr(\"borderWidth\") : tabNode.getAttr(\"borderHeight\");\n            if (tabBorderSize === -1) {\n                this.attributes.size = pos;\n            }\n            else {\n                if (this.isHorizontal()) {\n                    tabNode.setBorderWidth(pos);\n                }\n                else {\n                    tabNode.setBorderHeight(pos);\n                }\n            }\n        }\n    }\n    /** @internal */\n    updateAttrs(json) {\n        BorderNode.attributeDefinitions.update(json, this.attributes);\n    }\n    /** @internal */\n    remove(node) {\n        const removedIndex = this.removeChild(node);\n        if (this.getSelected() !== -1) {\n            (0,_Utils__WEBPACK_IMPORTED_MODULE_10__.adjustSelectedIndex)(this, removedIndex);\n        }\n    }\n    /** @internal */\n    canDrop(dragNode, x, y) {\n        if (!(dragNode instanceof _TabNode__WEBPACK_IMPORTED_MODULE_9__.TabNode)) {\n            return undefined;\n        }\n        let dropInfo;\n        const dockLocation = _DockLocation__WEBPACK_IMPORTED_MODULE_2__.DockLocation.CENTER;\n        if (this.tabHeaderRect.contains(x, y)) {\n            if (this.location.orientation === _Orientation__WEBPACK_IMPORTED_MODULE_4__.Orientation.VERT) {\n                if (this.children.length > 0) {\n                    let child = this.children[0];\n                    let childRect = child.getTabRect();\n                    const childY = childRect.y;\n                    const childHeight = childRect.height;\n                    let pos = this.tabHeaderRect.x;\n                    let childCenter = 0;\n                    for (let i = 0; i < this.children.length; i++) {\n                        child = this.children[i];\n                        childRect = child.getTabRect();\n                        childCenter = childRect.x + childRect.width / 2;\n                        if (x >= pos && x < childCenter) {\n                            const outlineRect = new _Rect__WEBPACK_IMPORTED_MODULE_5__.Rect(childRect.x - 2, childY, 3, childHeight);\n                            dropInfo = new _DropInfo__WEBPACK_IMPORTED_MODULE_3__.DropInfo(this, outlineRect, dockLocation, i, _Types__WEBPACK_IMPORTED_MODULE_6__.CLASSES.FLEXLAYOUT__OUTLINE_RECT);\n                            break;\n                        }\n                        pos = childCenter;\n                    }\n                    if (dropInfo == null) {\n                        const outlineRect = new _Rect__WEBPACK_IMPORTED_MODULE_5__.Rect(childRect.getRight() - 2, childY, 3, childHeight);\n                        dropInfo = new _DropInfo__WEBPACK_IMPORTED_MODULE_3__.DropInfo(this, outlineRect, dockLocation, this.children.length, _Types__WEBPACK_IMPORTED_MODULE_6__.CLASSES.FLEXLAYOUT__OUTLINE_RECT);\n                    }\n                }\n                else {\n                    const outlineRect = new _Rect__WEBPACK_IMPORTED_MODULE_5__.Rect(this.tabHeaderRect.x + 1, this.tabHeaderRect.y + 2, 3, 18);\n                    dropInfo = new _DropInfo__WEBPACK_IMPORTED_MODULE_3__.DropInfo(this, outlineRect, dockLocation, 0, _Types__WEBPACK_IMPORTED_MODULE_6__.CLASSES.FLEXLAYOUT__OUTLINE_RECT);\n                }\n            }\n            else {\n                if (this.children.length > 0) {\n                    let child = this.children[0];\n                    let childRect = child.getTabRect();\n                    const childX = childRect.x;\n                    const childWidth = childRect.width;\n                    let pos = this.tabHeaderRect.y;\n                    let childCenter = 0;\n                    for (let i = 0; i < this.children.length; i++) {\n                        child = this.children[i];\n                        childRect = child.getTabRect();\n                        childCenter = childRect.y + childRect.height / 2;\n                        if (y >= pos && y < childCenter) {\n                            const outlineRect = new _Rect__WEBPACK_IMPORTED_MODULE_5__.Rect(childX, childRect.y - 2, childWidth, 3);\n                            dropInfo = new _DropInfo__WEBPACK_IMPORTED_MODULE_3__.DropInfo(this, outlineRect, dockLocation, i, _Types__WEBPACK_IMPORTED_MODULE_6__.CLASSES.FLEXLAYOUT__OUTLINE_RECT);\n                            break;\n                        }\n                        pos = childCenter;\n                    }\n                    if (dropInfo == null) {\n                        const outlineRect = new _Rect__WEBPACK_IMPORTED_MODULE_5__.Rect(childX, childRect.getBottom() - 2, childWidth, 3);\n                        dropInfo = new _DropInfo__WEBPACK_IMPORTED_MODULE_3__.DropInfo(this, outlineRect, dockLocation, this.children.length, _Types__WEBPACK_IMPORTED_MODULE_6__.CLASSES.FLEXLAYOUT__OUTLINE_RECT);\n                    }\n                }\n                else {\n                    const outlineRect = new _Rect__WEBPACK_IMPORTED_MODULE_5__.Rect(this.tabHeaderRect.x + 2, this.tabHeaderRect.y + 1, 18, 3);\n                    dropInfo = new _DropInfo__WEBPACK_IMPORTED_MODULE_3__.DropInfo(this, outlineRect, dockLocation, 0, _Types__WEBPACK_IMPORTED_MODULE_6__.CLASSES.FLEXLAYOUT__OUTLINE_RECT);\n                }\n            }\n            if (!dragNode.canDockInto(dragNode, dropInfo)) {\n                return undefined;\n            }\n        }\n        else if (this.getSelected() !== -1 && this.outerRect.contains(x, y)) {\n            const outlineRect = this.outerRect;\n            dropInfo = new _DropInfo__WEBPACK_IMPORTED_MODULE_3__.DropInfo(this, outlineRect, dockLocation, -1, _Types__WEBPACK_IMPORTED_MODULE_6__.CLASSES.FLEXLAYOUT__OUTLINE_RECT);\n            if (!dragNode.canDockInto(dragNode, dropInfo)) {\n                return undefined;\n            }\n        }\n        return dropInfo;\n    }\n    /** @internal */\n    drop(dragNode, location, index, select) {\n        let fromIndex = 0;\n        const dragParent = dragNode.getParent();\n        if (dragParent !== undefined) {\n            fromIndex = dragParent.removeChild(dragNode);\n            // if selected node in border is being docked into a different border then deselect border tabs\n            if (dragParent !== this && dragParent instanceof BorderNode && dragParent.getSelected() === fromIndex) {\n                dragParent.setSelected(-1);\n            }\n            else {\n                (0,_Utils__WEBPACK_IMPORTED_MODULE_10__.adjustSelectedIndex)(dragParent, fromIndex);\n            }\n        }\n        // if dropping a tab back to same tabset and moving to forward position then reduce insertion index\n        if (dragNode instanceof _TabNode__WEBPACK_IMPORTED_MODULE_9__.TabNode && dragParent === this && fromIndex < index && index > 0) {\n            index--;\n        }\n        // simple_bundled dock to existing tabset\n        let insertPos = index;\n        if (insertPos === -1) {\n            insertPos = this.children.length;\n        }\n        if (dragNode instanceof _TabNode__WEBPACK_IMPORTED_MODULE_9__.TabNode) {\n            this.addChild(dragNode, insertPos);\n        }\n        if (select || (select !== false && this.isAutoSelectTab())) {\n            this.setSelected(insertPos);\n        }\n        this.model.tidy();\n    }\n    /** @internal */\n    getSplitterBounds(index, useMinSize = false) {\n        const pBounds = [0, 0];\n        const minSize = useMinSize ? this.getMinSize() : 0;\n        const maxSize = useMinSize ? this.getMaxSize() : 99999;\n        const rootRow = this.model.getRoot(_Model__WEBPACK_IMPORTED_MODULE_7__.Model.MAIN_WINDOW_ID);\n        const innerRect = rootRow.getRect();\n        const splitterSize = this.model.getSplitterSize();\n        if (this.location === _DockLocation__WEBPACK_IMPORTED_MODULE_2__.DockLocation.TOP) {\n            pBounds[0] = this.tabHeaderRect.getBottom() + minSize;\n            const maxPos = this.tabHeaderRect.getBottom() + maxSize;\n            pBounds[1] = Math.max(pBounds[0], innerRect.getBottom() - rootRow.getMinHeight() - splitterSize);\n            pBounds[1] = Math.min(pBounds[1], maxPos);\n        }\n        else if (this.location === _DockLocation__WEBPACK_IMPORTED_MODULE_2__.DockLocation.LEFT) {\n            pBounds[0] = this.tabHeaderRect.getRight() + minSize;\n            const maxPos = this.tabHeaderRect.getRight() + maxSize;\n            pBounds[1] = Math.max(pBounds[0], innerRect.getRight() - rootRow.getMinWidth() - splitterSize);\n            pBounds[1] = Math.min(pBounds[1], maxPos);\n        }\n        else if (this.location === _DockLocation__WEBPACK_IMPORTED_MODULE_2__.DockLocation.BOTTOM) {\n            pBounds[1] = this.tabHeaderRect.y - minSize - splitterSize;\n            const maxPos = this.tabHeaderRect.y - maxSize - splitterSize;\n            pBounds[0] = Math.min(pBounds[1], innerRect.y + rootRow.getMinHeight());\n            pBounds[0] = Math.max(pBounds[0], maxPos);\n        }\n        else if (this.location === _DockLocation__WEBPACK_IMPORTED_MODULE_2__.DockLocation.RIGHT) {\n            pBounds[1] = this.tabHeaderRect.x - minSize - splitterSize;\n            const maxPos = this.tabHeaderRect.x - maxSize - splitterSize;\n            pBounds[0] = Math.min(pBounds[1], innerRect.x + rootRow.getMinWidth());\n            pBounds[0] = Math.max(pBounds[0], maxPos);\n        }\n        return pBounds;\n    }\n    /** @internal */\n    calculateSplit(splitter, splitterPos) {\n        const pBounds = this.getSplitterBounds(splitterPos);\n        if (this.location === _DockLocation__WEBPACK_IMPORTED_MODULE_2__.DockLocation.BOTTOM || this.location === _DockLocation__WEBPACK_IMPORTED_MODULE_2__.DockLocation.RIGHT) {\n            return Math.max(0, pBounds[1] - splitterPos);\n        }\n        else {\n            return Math.max(0, splitterPos - pBounds[0]);\n        }\n    }\n    /** @internal */\n    getAttributeDefinitions() {\n        return BorderNode.attributeDefinitions;\n    }\n    /** @internal */\n    static getAttributeDefinitions() {\n        return BorderNode.attributeDefinitions;\n    }\n    /** @internal */\n    static createAttributeDefinitions() {\n        const attributeDefinitions = new _AttributeDefinitions__WEBPACK_IMPORTED_MODULE_1__.AttributeDefinitions();\n        attributeDefinitions.add(\"type\", BorderNode.TYPE, true).setType(_Attribute__WEBPACK_IMPORTED_MODULE_0__.Attribute.STRING).setFixed();\n        attributeDefinitions.add(\"selected\", -1).setType(_Attribute__WEBPACK_IMPORTED_MODULE_0__.Attribute.NUMBER).setDescription(`index of selected/visible tab in border; -1 means no tab selected`);\n        attributeDefinitions.add(\"show\", true).setType(_Attribute__WEBPACK_IMPORTED_MODULE_0__.Attribute.BOOLEAN).setDescription(`show/hide this border`);\n        attributeDefinitions.add(\"config\", undefined).setType(\"any\").setDescription(`a place to hold json config used in your own code`);\n        attributeDefinitions.addInherited(\"enableDrop\", \"borderEnableDrop\").setType(_Attribute__WEBPACK_IMPORTED_MODULE_0__.Attribute.BOOLEAN).setDescription(`whether tabs can be dropped into this border`);\n        attributeDefinitions.addInherited(\"className\", \"borderClassName\").setType(_Attribute__WEBPACK_IMPORTED_MODULE_0__.Attribute.STRING).setDescription(`class applied to tab button`);\n        attributeDefinitions.addInherited(\"autoSelectTabWhenOpen\", \"borderAutoSelectTabWhenOpen\").setType(_Attribute__WEBPACK_IMPORTED_MODULE_0__.Attribute.BOOLEAN).setDescription(`whether to select new/moved tabs in border when the border is already open`);\n        attributeDefinitions.addInherited(\"autoSelectTabWhenClosed\", \"borderAutoSelectTabWhenClosed\").setType(_Attribute__WEBPACK_IMPORTED_MODULE_0__.Attribute.BOOLEAN).setDescription(`whether to select new/moved tabs in border when the border is currently closed`);\n        attributeDefinitions.addInherited(\"size\", \"borderSize\").setType(_Attribute__WEBPACK_IMPORTED_MODULE_0__.Attribute.NUMBER).setDescription(`size of the tab area when selected`);\n        attributeDefinitions.addInherited(\"minSize\", \"borderMinSize\").setType(_Attribute__WEBPACK_IMPORTED_MODULE_0__.Attribute.NUMBER).setDescription(`the minimum size of the tab area`);\n        attributeDefinitions.addInherited(\"maxSize\", \"borderMaxSize\").setType(_Attribute__WEBPACK_IMPORTED_MODULE_0__.Attribute.NUMBER).setDescription(`the maximum size of the tab area`);\n        attributeDefinitions.addInherited(\"enableAutoHide\", \"borderEnableAutoHide\").setType(_Attribute__WEBPACK_IMPORTED_MODULE_0__.Attribute.BOOLEAN).setDescription(`hide border if it has zero tabs`);\n        return attributeDefinitions;\n    }\n}\nBorderNode.TYPE = \"border\";\n/** @internal */\nBorderNode.attributeDefinitions = BorderNode.createAttributeDefinitions();\n\n\n//# sourceURL=webpack://FlexLayout/./src/model/BorderNode.ts?");

/***/ }),

/***/ "./src/model/BorderSet.ts":
/*!********************************!*\
  !*** ./src/model/BorderSet.ts ***!
  \********************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   BorderSet: () => (/* binding */ BorderSet)\n/* harmony export */ });\n/* harmony import */ var _BorderNode__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./BorderNode */ \"./src/model/BorderNode.ts\");\n\nclass BorderSet {\n    /** @internal */\n    static fromJson(json, model) {\n        const borderSet = new BorderSet(model);\n        borderSet.borders = json.map((borderJson) => _BorderNode__WEBPACK_IMPORTED_MODULE_0__.BorderNode.fromJson(borderJson, model));\n        for (const border of borderSet.borders) {\n            borderSet.borderMap.set(border.getLocation(), border);\n        }\n        return borderSet;\n    }\n    /** @internal */\n    constructor(_model) {\n        this.borders = [];\n        this.borderMap = new Map();\n        this.layoutHorizontal = true;\n    }\n    toJson() {\n        return this.borders.map((borderNode) => borderNode.toJson());\n    }\n    /** @internal */\n    getLayoutHorizontal() {\n        return this.layoutHorizontal;\n    }\n    /** @internal */\n    getBorders() {\n        return this.borders;\n    }\n    /** @internal */\n    getBorderMap() {\n        return this.borderMap;\n    }\n    /** @internal */\n    forEachNode(fn) {\n        for (const borderNode of this.borders) {\n            fn(borderNode, 0);\n            for (const node of borderNode.getChildren()) {\n                node.forEachNode(fn, 1);\n            }\n        }\n    }\n    /** @internal */\n    setPaths() {\n        for (const borderNode of this.borders) {\n            const path = \"/border/\" + borderNode.getLocation().getName();\n            borderNode.setPath(path);\n            let i = 0;\n            for (const node of borderNode.getChildren()) {\n                node.setPath(path + \"/t\" + i);\n                i++;\n            }\n        }\n    }\n    /** @internal */\n    findDropTargetNode(dragNode, x, y) {\n        for (const border of this.borders) {\n            if (border.isShowing()) {\n                const dropInfo = border.canDrop(dragNode, x, y);\n                if (dropInfo !== undefined) {\n                    return dropInfo;\n                }\n            }\n        }\n        return undefined;\n    }\n}\n\n\n//# sourceURL=webpack://FlexLayout/./src/model/BorderSet.ts?");

/***/ }),

/***/ "./src/model/ICloseType.ts":
/*!*********************************!*\
  !*** ./src/model/ICloseType.ts ***!
  \*********************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   ICloseType: () => (/* binding */ ICloseType)\n/* harmony export */ });\nvar ICloseType;\n(function (ICloseType) {\n    ICloseType[ICloseType[\"Visible\"] = 1] = \"Visible\";\n    ICloseType[ICloseType[\"Always\"] = 2] = \"Always\";\n    ICloseType[ICloseType[\"Selected\"] = 3] = \"Selected\";\n})(ICloseType || (ICloseType = {}));\n\n\n//# sourceURL=webpack://FlexLayout/./src/model/ICloseType.ts?");

/***/ }),

/***/ "./src/model/IDraggable.ts":
/*!*********************************!*\
  !*** ./src/model/IDraggable.ts ***!
  \*********************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n\n\n\n//# sourceURL=webpack://FlexLayout/./src/model/IDraggable.ts?");

/***/ }),

/***/ "./src/model/IDropTarget.ts":
/*!**********************************!*\
  !*** ./src/model/IDropTarget.ts ***!
  \**********************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n\n\n\n//# sourceURL=webpack://FlexLayout/./src/model/IDropTarget.ts?");

/***/ }),

/***/ "./src/model/IJsonModel.ts":
/*!*********************************!*\
  !*** ./src/model/IJsonModel.ts ***!
  \*********************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n\n\n\n//# sourceURL=webpack://FlexLayout/./src/model/IJsonModel.ts?");

/***/ }),

/***/ "./src/model/LayoutWindow.ts":
/*!***********************************!*\
  !*** ./src/model/LayoutWindow.ts ***!
  \***********************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   LayoutWindow: () => (/* binding */ LayoutWindow)\n/* harmony export */ });\n/* harmony import */ var _Rect__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../Rect */ \"./src/Rect.ts\");\n/* harmony import */ var _RowNode__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./RowNode */ \"./src/model/RowNode.ts\");\n/* harmony import */ var _view_Utils__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../view/Utils */ \"./src/view/Utils.tsx\");\n\n\n\nclass LayoutWindow {\n    constructor(windowId, rect) {\n        this._windowId = windowId;\n        this._rect = rect;\n        this._toScreenRectFunction = (r) => r;\n    }\n    visitNodes(fn) {\n        this.root.forEachNode(fn, 0);\n    }\n    get windowId() {\n        return this._windowId;\n    }\n    get rect() {\n        return this._rect;\n    }\n    get layout() {\n        return this._layout;\n    }\n    get window() {\n        return this._window;\n    }\n    get root() {\n        return this._root;\n    }\n    get maximizedTabSet() {\n        return this._maximizedTabSet;\n    }\n    get activeTabSet() {\n        return this._activeTabSet;\n    }\n    /** @internal */\n    set rect(value) {\n        this._rect = value;\n    }\n    /** @internal */\n    set layout(value) {\n        this._layout = value;\n    }\n    /** @internal */\n    set window(value) {\n        this._window = value;\n    }\n    /** @internal */\n    set root(value) {\n        this._root = value;\n    }\n    /** @internal */\n    set maximizedTabSet(value) {\n        this._maximizedTabSet = value;\n    }\n    /** @internal */\n    set activeTabSet(value) {\n        this._activeTabSet = value;\n    }\n    /** @internal */\n    get toScreenRectFunction() {\n        return this._toScreenRectFunction;\n    }\n    /** @internal */\n    set toScreenRectFunction(value) {\n        this._toScreenRectFunction = value;\n    }\n    toJson() {\n        // chrome sets top,left to large -ve values when minimized, dont save in this case\n        if (this._window && this._window.screenTop > -10000) {\n            this.rect = new _Rect__WEBPACK_IMPORTED_MODULE_0__.Rect(this._window.screenLeft, this._window.screenTop, this._window.outerWidth, this._window.outerHeight);\n        }\n        return { layout: this.root.toJson(), rect: this.rect.toJson() };\n    }\n    static fromJson(windowJson, model, windowId) {\n        const count = model.getwindowsMap().size;\n        let rect = windowJson.rect ? _Rect__WEBPACK_IMPORTED_MODULE_0__.Rect.fromJson(windowJson.rect) : new _Rect__WEBPACK_IMPORTED_MODULE_0__.Rect(50 + 50 * count, 50 + 50 * count, 600, 400);\n        rect = (0,_view_Utils__WEBPACK_IMPORTED_MODULE_2__.keepOnScreen)(rect); // snaps to grid of 10x10 and then moves into visible area\n        // snapping prevents issue where window moves 1 pixel per save/restore on Chrome\n        const layoutWindow = new LayoutWindow(windowId, rect);\n        layoutWindow.root = _RowNode__WEBPACK_IMPORTED_MODULE_1__.RowNode.fromJson(windowJson.layout, model, layoutWindow);\n        return layoutWindow;\n    }\n}\n\n\n//# sourceURL=webpack://FlexLayout/./src/model/LayoutWindow.ts?");

/***/ }),

/***/ "./src/model/Model.ts":
/*!****************************!*\
  !*** ./src/model/Model.ts ***!
  \****************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   DefaultMax: () => (/* binding */ DefaultMax),\n/* harmony export */   DefaultMin: () => (/* binding */ DefaultMin),\n/* harmony export */   Model: () => (/* binding */ Model)\n/* harmony export */ });\n/* harmony import */ var _Attribute__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../Attribute */ \"./src/Attribute.ts\");\n/* harmony import */ var _AttributeDefinitions__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../AttributeDefinitions */ \"./src/AttributeDefinitions.ts\");\n/* harmony import */ var _DockLocation__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../DockLocation */ \"./src/DockLocation.ts\");\n/* harmony import */ var _Rect__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../Rect */ \"./src/Rect.ts\");\n/* harmony import */ var _Actions__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./Actions */ \"./src/model/Actions.ts\");\n/* harmony import */ var _BorderNode__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./BorderNode */ \"./src/model/BorderNode.ts\");\n/* harmony import */ var _BorderSet__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./BorderSet */ \"./src/model/BorderSet.ts\");\n/* harmony import */ var _RowNode__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./RowNode */ \"./src/model/RowNode.ts\");\n/* harmony import */ var _TabNode__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ./TabNode */ \"./src/model/TabNode.ts\");\n/* harmony import */ var _TabSetNode__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ./TabSetNode */ \"./src/model/TabSetNode.ts\");\n/* harmony import */ var _Utils__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! ./Utils */ \"./src/model/Utils.ts\");\n/* harmony import */ var _LayoutWindow__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(/*! ./LayoutWindow */ \"./src/model/LayoutWindow.ts\");\n/* harmony import */ var _view_Utils__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__(/*! ../view/Utils */ \"./src/view/Utils.tsx\");\n\n\n\n\n\n\n\n\n\n\n\n\n\n/** @internal */\nconst DefaultMin = 0;\n/** @internal */\nconst DefaultMax = 99999;\n/**\n * Class containing the Tree of Nodes used by the FlexLayout component\n */\nclass Model {\n    /**\n     * 'private' constructor. Use the static method Model.fromJson(json) to create a model\n     *  @internal\n     */\n    constructor() {\n        this.attributes = {};\n        this.idMap = new Map();\n        this.borders = new _BorderSet__WEBPACK_IMPORTED_MODULE_6__.BorderSet(this);\n        this.windows = new Map();\n        this.rootWindow = new _LayoutWindow__WEBPACK_IMPORTED_MODULE_11__.LayoutWindow(Model.MAIN_WINDOW_ID, _Rect__WEBPACK_IMPORTED_MODULE_3__.Rect.empty());\n        this.windows.set(Model.MAIN_WINDOW_ID, this.rootWindow);\n        this.changeListeners = [];\n    }\n    /**\n     * Update the node tree by performing the given action,\n     * Actions should be generated via static methods on the Actions class\n     * @param action the action to perform\n     * @returns added Node for Actions.addNode, windowId for createWindow\n     */\n    doAction(action) {\n        var _a;\n        let returnVal = undefined;\n        // console.log(action);\n        switch (action.type) {\n            case _Actions__WEBPACK_IMPORTED_MODULE_4__.Actions.ADD_NODE: {\n                const newNode = new _TabNode__WEBPACK_IMPORTED_MODULE_8__.TabNode(this, action.data.json, true);\n                const toNode = this.idMap.get(action.data.toNode);\n                if (toNode instanceof _TabSetNode__WEBPACK_IMPORTED_MODULE_9__.TabSetNode || toNode instanceof _BorderNode__WEBPACK_IMPORTED_MODULE_5__.BorderNode || toNode instanceof _RowNode__WEBPACK_IMPORTED_MODULE_7__.RowNode) {\n                    toNode.drop(newNode, _DockLocation__WEBPACK_IMPORTED_MODULE_2__.DockLocation.getByName(action.data.location), action.data.index, action.data.select);\n                    returnVal = newNode;\n                }\n                break;\n            }\n            case _Actions__WEBPACK_IMPORTED_MODULE_4__.Actions.MOVE_NODE: {\n                const fromNode = this.idMap.get(action.data.fromNode);\n                if (fromNode instanceof _TabNode__WEBPACK_IMPORTED_MODULE_8__.TabNode || fromNode instanceof _TabSetNode__WEBPACK_IMPORTED_MODULE_9__.TabSetNode || fromNode instanceof _RowNode__WEBPACK_IMPORTED_MODULE_7__.RowNode) {\n                    if (fromNode === this.getMaximizedTabset(fromNode.getWindowId())) {\n                        const fromWindow = this.windows.get(fromNode.getWindowId());\n                        fromWindow.maximizedTabSet = undefined;\n                    }\n                    const toNode = this.idMap.get(action.data.toNode);\n                    if (toNode instanceof _TabSetNode__WEBPACK_IMPORTED_MODULE_9__.TabSetNode || toNode instanceof _BorderNode__WEBPACK_IMPORTED_MODULE_5__.BorderNode || toNode instanceof _RowNode__WEBPACK_IMPORTED_MODULE_7__.RowNode) {\n                        toNode.drop(fromNode, _DockLocation__WEBPACK_IMPORTED_MODULE_2__.DockLocation.getByName(action.data.location), action.data.index, action.data.select);\n                    }\n                }\n                this.removeEmptyWindows();\n                break;\n            }\n            case _Actions__WEBPACK_IMPORTED_MODULE_4__.Actions.DELETE_TAB: {\n                const node = this.idMap.get(action.data.node);\n                if (node instanceof _TabNode__WEBPACK_IMPORTED_MODULE_8__.TabNode) {\n                    node.delete();\n                }\n                this.removeEmptyWindows();\n                break;\n            }\n            case _Actions__WEBPACK_IMPORTED_MODULE_4__.Actions.DELETE_TABSET: {\n                const node = this.idMap.get(action.data.node);\n                if (node instanceof _TabSetNode__WEBPACK_IMPORTED_MODULE_9__.TabSetNode) {\n                    // first delete all child tabs that are closeable\n                    const children = [...node.getChildren()];\n                    for (let i = 0; i < children.length; i++) {\n                        const child = children[i];\n                        if (child.isEnableClose()) {\n                            child.delete();\n                        }\n                    }\n                    if (node.getChildren().length === 0) {\n                        node.delete();\n                    }\n                    this.tidy();\n                }\n                this.removeEmptyWindows();\n                break;\n            }\n            case _Actions__WEBPACK_IMPORTED_MODULE_4__.Actions.POPOUT_TABSET: {\n                const node = this.idMap.get(action.data.node);\n                if (node instanceof _TabSetNode__WEBPACK_IMPORTED_MODULE_9__.TabSetNode) {\n                    const isMaximized = node.isMaximized();\n                    const oldLayoutWindow = this.windows.get(node.getWindowId());\n                    const windowId = (0,_Utils__WEBPACK_IMPORTED_MODULE_10__.randomUUID)();\n                    const layoutWindow = new _LayoutWindow__WEBPACK_IMPORTED_MODULE_11__.LayoutWindow(windowId, oldLayoutWindow.toScreenRectFunction(node.getRect()));\n                    const json = {\n                        type: \"row\",\n                        children: []\n                    };\n                    const row = _RowNode__WEBPACK_IMPORTED_MODULE_7__.RowNode.fromJson(json, this, layoutWindow);\n                    layoutWindow.root = row;\n                    this.windows.set(windowId, layoutWindow);\n                    row.drop(node, _DockLocation__WEBPACK_IMPORTED_MODULE_2__.DockLocation.CENTER, 0);\n                    if (isMaximized) {\n                        this.rootWindow.maximizedTabSet = undefined;\n                    }\n                }\n                this.removeEmptyWindows();\n                break;\n            }\n            case _Actions__WEBPACK_IMPORTED_MODULE_4__.Actions.POPOUT_TAB: {\n                const node = this.idMap.get(action.data.node);\n                if (node instanceof _TabNode__WEBPACK_IMPORTED_MODULE_8__.TabNode) {\n                    const windowId = (0,_Utils__WEBPACK_IMPORTED_MODULE_10__.randomUUID)();\n                    let r = _Rect__WEBPACK_IMPORTED_MODULE_3__.Rect.empty();\n                    if (node.getParent() instanceof _TabSetNode__WEBPACK_IMPORTED_MODULE_9__.TabSetNode) {\n                        r = node.getParent().getRect();\n                    }\n                    else {\n                        r = node.getParent().getContentRect();\n                    }\n                    const oldLayoutWindow = this.windows.get(node.getWindowId());\n                    const layoutWindow = new _LayoutWindow__WEBPACK_IMPORTED_MODULE_11__.LayoutWindow(windowId, oldLayoutWindow.toScreenRectFunction(r));\n                    const tabsetId = (0,_Utils__WEBPACK_IMPORTED_MODULE_10__.randomUUID)();\n                    const json = {\n                        type: \"row\",\n                        children: [\n                            { type: \"tabset\", id: tabsetId }\n                        ]\n                    };\n                    const row = _RowNode__WEBPACK_IMPORTED_MODULE_7__.RowNode.fromJson(json, this, layoutWindow);\n                    layoutWindow.root = row;\n                    this.windows.set(windowId, layoutWindow);\n                    const tabset = this.idMap.get(tabsetId);\n                    tabset.drop(node, _DockLocation__WEBPACK_IMPORTED_MODULE_2__.DockLocation.CENTER, 0, true);\n                }\n                this.removeEmptyWindows();\n                break;\n            }\n            case _Actions__WEBPACK_IMPORTED_MODULE_4__.Actions.CLOSE_WINDOW: {\n                const window = this.windows.get(action.data.windowId);\n                if (window) {\n                    (_a = this.rootWindow.root) === null || _a === void 0 ? void 0 : _a.drop(window === null || window === void 0 ? void 0 : window.root, _DockLocation__WEBPACK_IMPORTED_MODULE_2__.DockLocation.CENTER, -1);\n                    this.rootWindow.visitNodes((node, level) => {\n                        if (node instanceof _RowNode__WEBPACK_IMPORTED_MODULE_7__.RowNode) {\n                            node.setWindowId(Model.MAIN_WINDOW_ID);\n                        }\n                    });\n                    // this.getFirstTabSet().drop(window?.root!,DockLocation.CENTER, -1);\n                    this.windows.delete(action.data.windowId);\n                }\n                break;\n            }\n            case _Actions__WEBPACK_IMPORTED_MODULE_4__.Actions.CREATE_WINDOW: {\n                const windowId = (0,_Utils__WEBPACK_IMPORTED_MODULE_10__.randomUUID)();\n                const layoutWindow = new _LayoutWindow__WEBPACK_IMPORTED_MODULE_11__.LayoutWindow(windowId, _Rect__WEBPACK_IMPORTED_MODULE_3__.Rect.fromJson(action.data.rect));\n                const row = _RowNode__WEBPACK_IMPORTED_MODULE_7__.RowNode.fromJson(action.data.layout, this, layoutWindow);\n                layoutWindow.root = row;\n                this.windows.set(windowId, layoutWindow);\n                returnVal = windowId;\n                break;\n            }\n            case _Actions__WEBPACK_IMPORTED_MODULE_4__.Actions.RENAME_TAB: {\n                const node = this.idMap.get(action.data.node);\n                if (node instanceof _TabNode__WEBPACK_IMPORTED_MODULE_8__.TabNode) {\n                    node.setName(action.data.text);\n                }\n                break;\n            }\n            case _Actions__WEBPACK_IMPORTED_MODULE_4__.Actions.SELECT_TAB: {\n                const tabNode = this.idMap.get(action.data.tabNode);\n                const windowId = action.data.windowId ? action.data.windowId : Model.MAIN_WINDOW_ID;\n                const window = this.windows.get(windowId);\n                if (tabNode instanceof _TabNode__WEBPACK_IMPORTED_MODULE_8__.TabNode) {\n                    const parent = tabNode.getParent();\n                    const pos = parent.getChildren().indexOf(tabNode);\n                    if (parent instanceof _BorderNode__WEBPACK_IMPORTED_MODULE_5__.BorderNode) {\n                        if (parent.getSelected() === pos) {\n                            parent.setSelected(-1);\n                        }\n                        else {\n                            parent.setSelected(pos);\n                        }\n                    }\n                    else if (parent instanceof _TabSetNode__WEBPACK_IMPORTED_MODULE_9__.TabSetNode) {\n                        if (parent.getSelected() !== pos) {\n                            parent.setSelected(pos);\n                        }\n                        window.activeTabSet = parent;\n                    }\n                }\n                break;\n            }\n            case _Actions__WEBPACK_IMPORTED_MODULE_4__.Actions.SET_ACTIVE_TABSET: {\n                const windowId = action.data.windowId ? action.data.windowId : Model.MAIN_WINDOW_ID;\n                const window = this.windows.get(windowId);\n                if (action.data.tabsetNode === undefined) {\n                    window.activeTabSet = undefined;\n                }\n                else {\n                    const tabsetNode = this.idMap.get(action.data.tabsetNode);\n                    if (tabsetNode instanceof _TabSetNode__WEBPACK_IMPORTED_MODULE_9__.TabSetNode) {\n                        window.activeTabSet = tabsetNode;\n                    }\n                }\n                break;\n            }\n            case _Actions__WEBPACK_IMPORTED_MODULE_4__.Actions.ADJUST_WEIGHTS: {\n                const row = this.idMap.get(action.data.nodeId);\n                const c = row.getChildren();\n                for (let i = 0; i < c.length; i++) {\n                    const n = c[i];\n                    n.setWeight(action.data.weights[i]);\n                }\n                break;\n            }\n            case _Actions__WEBPACK_IMPORTED_MODULE_4__.Actions.ADJUST_BORDER_SPLIT: {\n                const node = this.idMap.get(action.data.node);\n                if (node instanceof _BorderNode__WEBPACK_IMPORTED_MODULE_5__.BorderNode) {\n                    node.setSize(action.data.pos);\n                }\n                break;\n            }\n            case _Actions__WEBPACK_IMPORTED_MODULE_4__.Actions.MAXIMIZE_TOGGLE: {\n                const windowId = action.data.windowId ? action.data.windowId : Model.MAIN_WINDOW_ID;\n                const window = this.windows.get(windowId);\n                const node = this.idMap.get(action.data.node);\n                if (node instanceof _TabSetNode__WEBPACK_IMPORTED_MODULE_9__.TabSetNode) {\n                    if (node === window.maximizedTabSet) {\n                        window.maximizedTabSet = undefined;\n                    }\n                    else {\n                        window.maximizedTabSet = node;\n                        window.activeTabSet = node;\n                    }\n                }\n                break;\n            }\n            case _Actions__WEBPACK_IMPORTED_MODULE_4__.Actions.UPDATE_MODEL_ATTRIBUTES: {\n                this.updateAttrs(action.data.json);\n                break;\n            }\n            case _Actions__WEBPACK_IMPORTED_MODULE_4__.Actions.UPDATE_NODE_ATTRIBUTES: {\n                const node = this.idMap.get(action.data.node);\n                node.updateAttrs(action.data.json);\n                break;\n            }\n            default:\n                break;\n        }\n        this.updateIdMap();\n        for (const listener of this.changeListeners) {\n            listener(action);\n        }\n        return returnVal;\n    }\n    /**\n     * Get the currently active tabset node\n     */\n    getActiveTabset(windowId = Model.MAIN_WINDOW_ID) {\n        const window = this.windows.get(windowId);\n        if (window && window.activeTabSet && this.getNodeById(window.activeTabSet.getId())) {\n            return window.activeTabSet;\n        }\n        else {\n            return undefined;\n        }\n    }\n    /**\n     * Get the currently maximized tabset node\n     */\n    getMaximizedTabset(windowId = Model.MAIN_WINDOW_ID) {\n        return this.windows.get(windowId).maximizedTabSet;\n    }\n    /**\n     * Gets the root RowNode of the model\n     * @returns {RowNode}\n     */\n    getRoot(windowId = Model.MAIN_WINDOW_ID) {\n        return this.windows.get(windowId).root;\n    }\n    isRootOrientationVertical() {\n        return this.attributes.rootOrientationVertical;\n    }\n    isEnableRotateBorderIcons() {\n        return this.attributes.enableRotateBorderIcons;\n    }\n    /**\n     * Gets the\n     * @returns {BorderSet|*}\n     */\n    getBorderSet() {\n        return this.borders;\n    }\n    getwindowsMap() {\n        return this.windows;\n    }\n    /**\n     * Visits all the nodes in the model and calls the given function for each\n     * @param fn a function that takes visited node and a integer level as parameters\n     */\n    visitNodes(fn) {\n        this.borders.forEachNode(fn);\n        for (const [_, w] of this.windows) {\n            w.root.forEachNode(fn, 0);\n        }\n    }\n    visitWindowNodes(windowId, fn) {\n        if (this.windows.has(windowId)) {\n            if (windowId === Model.MAIN_WINDOW_ID) {\n                this.borders.forEachNode(fn);\n            }\n            this.windows.get(windowId).visitNodes(fn);\n        }\n    }\n    /**\n     * Gets a node by its id\n     * @param id the id to find\n     */\n    getNodeById(id) {\n        return this.idMap.get(id);\n    }\n    /**\n     * Finds the first/top left tab set of the given node.\n     * @param node The top node you want to begin searching from, deafults to the root node\n     * @returns The first Tab Set\n     */\n    getFirstTabSet(node = this.windows.get(Model.MAIN_WINDOW_ID).root) {\n        const child = node.getChildren()[0];\n        if (child instanceof _TabSetNode__WEBPACK_IMPORTED_MODULE_9__.TabSetNode) {\n            return child;\n        }\n        else {\n            return this.getFirstTabSet(child);\n        }\n    }\n    /**\n * Loads the model from the given json object\n * @param json the json model to load\n * @returns {Model} a new Model object\n */\n    static fromJson(json) {\n        const model = new Model();\n        Model.attributeDefinitions.fromJson(json.global, model.attributes);\n        if (json.borders) {\n            model.borders = _BorderSet__WEBPACK_IMPORTED_MODULE_6__.BorderSet.fromJson(json.borders, model);\n        }\n        if (json.popouts) {\n            let i = 0;\n            let top = 100;\n            let left = 100;\n            for (const windowId in json.popouts) {\n                const windowJson = json.popouts[windowId];\n                const layoutWindow = _LayoutWindow__WEBPACK_IMPORTED_MODULE_11__.LayoutWindow.fromJson(windowJson, model, windowId);\n                model.windows.set(windowId, layoutWindow);\n                // offscreen windows will reload cascaded (since cannot reposition)\n                if (!(0,_view_Utils__WEBPACK_IMPORTED_MODULE_12__.isOnScreen)(layoutWindow.rect)) {\n                    layoutWindow.rect = new _Rect__WEBPACK_IMPORTED_MODULE_3__.Rect(top + i * 50, left + i * 50, 600, 400);\n                    i++;\n                }\n            }\n        }\n        model.rootWindow.root = _RowNode__WEBPACK_IMPORTED_MODULE_7__.RowNode.fromJson(json.layout, model, model.getwindowsMap().get(Model.MAIN_WINDOW_ID));\n        model.tidy(); // initial tidy of node tree\n        return model;\n    }\n    /**\n     * Converts the model to a json object\n     * @returns {IJsonModel} json object that represents this model\n     */\n    toJson() {\n        const global = {};\n        Model.attributeDefinitions.toJson(global, this.attributes);\n        // save state of nodes\n        this.visitNodes((node) => {\n            node.fireEvent(\"save\", {});\n        });\n        const windows = {};\n        for (const [id, window] of this.windows) {\n            if (id !== Model.MAIN_WINDOW_ID) {\n                windows[id] = window.toJson();\n            }\n        }\n        return {\n            global,\n            borders: this.borders.toJson(),\n            layout: this.rootWindow.root.toJson(),\n            popouts: windows\n        };\n    }\n    getSplitterSize() {\n        return this.attributes.splitterSize;\n    }\n    getSplitterExtra() {\n        return this.attributes.splitterExtra;\n    }\n    isEnableEdgeDock() {\n        return this.attributes.enableEdgeDock;\n    }\n    isSplitterEnableHandle() {\n        return this.attributes.splitterEnableHandle;\n    }\n    /**\n     * Sets a function to allow/deny dropping a node\n     * @param onAllowDrop function that takes the drag node and DropInfo and returns true if the drop is allowed\n     */\n    setOnAllowDrop(onAllowDrop) {\n        this.onAllowDrop = onAllowDrop;\n    }\n    /**\n     * set callback called when a new TabSet is created.\n     * The tabNode can be undefined if it's the auto created first tabset in the root row (when the last\n     * tab is deleted, the root tabset can be recreated)\n     * @param onCreateTabSet\n     */\n    setOnCreateTabSet(onCreateTabSet) {\n        this.onCreateTabSet = onCreateTabSet;\n    }\n    addChangeListener(listener) {\n        this.changeListeners.push(listener);\n    }\n    removeChangeListener(listener) {\n        const pos = this.changeListeners.findIndex(l => l === listener);\n        if (pos !== -1) {\n            this.changeListeners.splice(pos, 1);\n        }\n    }\n    toString() {\n        return JSON.stringify(this.toJson());\n    }\n    /***********************internal ********************************/\n    /** @internal */\n    removeEmptyWindows() {\n        const emptyWindows = new Set();\n        for (const [windowId] of this.windows) {\n            if (windowId !== Model.MAIN_WINDOW_ID) {\n                let count = 0;\n                this.visitWindowNodes(windowId, (node) => {\n                    if (node instanceof _TabNode__WEBPACK_IMPORTED_MODULE_8__.TabNode) {\n                        count++;\n                    }\n                });\n                if (count === 0) {\n                    emptyWindows.add(windowId);\n                }\n            }\n        }\n        for (const windowId of emptyWindows) {\n            this.windows.delete(windowId);\n        }\n    }\n    /** @internal */\n    setActiveTabset(tabsetNode, windowId) {\n        const window = this.windows.get(windowId);\n        if (window) {\n            if (tabsetNode) {\n                window.activeTabSet = tabsetNode;\n            }\n            else {\n                window.activeTabSet = undefined;\n            }\n        }\n    }\n    /** @internal */\n    setMaximizedTabset(tabsetNode, windowId) {\n        const window = this.windows.get(windowId);\n        if (window) {\n            if (tabsetNode) {\n                window.maximizedTabSet = tabsetNode;\n            }\n            else {\n                window.maximizedTabSet = undefined;\n            }\n        }\n    }\n    /** @internal */\n    updateIdMap() {\n        // regenerate idMap to stop it building up\n        this.idMap.clear();\n        this.visitNodes((node) => {\n            this.idMap.set(node.getId(), node);\n            // if (node instanceof RowNode) {\n            //     node.normalizeWeights();\n            // }\n        });\n        // console.log(JSON.stringify(Object.keys(this._idMap)));\n    }\n    /** @internal */\n    addNode(node) {\n        const id = node.getId();\n        if (this.idMap.has(id)) {\n            throw new Error(`Error: each node must have a unique id, duplicate id:${node.getId()}`);\n        }\n        this.idMap.set(id, node);\n    }\n    /** @internal */\n    findDropTargetNode(windowId, dragNode, x, y) {\n        let node = this.windows.get(windowId).root.findDropTargetNode(windowId, dragNode, x, y);\n        if (node === undefined && windowId === Model.MAIN_WINDOW_ID) {\n            node = this.borders.findDropTargetNode(dragNode, x, y);\n        }\n        return node;\n    }\n    /** @internal */\n    tidy() {\n        // console.log(\"before _tidy\", this.toString());\n        for (const [_, window] of this.windows) {\n            window.root.tidy();\n        }\n        // console.log(\"after _tidy\", this.toString());\n    }\n    /** @internal */\n    updateAttrs(json) {\n        Model.attributeDefinitions.update(json, this.attributes);\n    }\n    /** @internal */\n    nextUniqueId() {\n        return '#' + (0,_Utils__WEBPACK_IMPORTED_MODULE_10__.randomUUID)();\n    }\n    /** @internal */\n    getAttribute(name) {\n        return this.attributes[name];\n    }\n    /** @internal */\n    getOnAllowDrop() {\n        return this.onAllowDrop;\n    }\n    /** @internal */\n    getOnCreateTabSet() {\n        return this.onCreateTabSet;\n    }\n    static toTypescriptInterfaces() {\n        Model.attributeDefinitions.pairAttributes(\"RowNode\", _RowNode__WEBPACK_IMPORTED_MODULE_7__.RowNode.getAttributeDefinitions());\n        Model.attributeDefinitions.pairAttributes(\"TabSetNode\", _TabSetNode__WEBPACK_IMPORTED_MODULE_9__.TabSetNode.getAttributeDefinitions());\n        Model.attributeDefinitions.pairAttributes(\"TabNode\", _TabNode__WEBPACK_IMPORTED_MODULE_8__.TabNode.getAttributeDefinitions());\n        Model.attributeDefinitions.pairAttributes(\"BorderNode\", _BorderNode__WEBPACK_IMPORTED_MODULE_5__.BorderNode.getAttributeDefinitions());\n        let sb = [];\n        sb.push(Model.attributeDefinitions.toTypescriptInterface(\"Global\", undefined));\n        sb.push(_RowNode__WEBPACK_IMPORTED_MODULE_7__.RowNode.getAttributeDefinitions().toTypescriptInterface(\"Row\", Model.attributeDefinitions));\n        sb.push(_TabSetNode__WEBPACK_IMPORTED_MODULE_9__.TabSetNode.getAttributeDefinitions().toTypescriptInterface(\"TabSet\", Model.attributeDefinitions));\n        sb.push(_TabNode__WEBPACK_IMPORTED_MODULE_8__.TabNode.getAttributeDefinitions().toTypescriptInterface(\"Tab\", Model.attributeDefinitions));\n        sb.push(_BorderNode__WEBPACK_IMPORTED_MODULE_5__.BorderNode.getAttributeDefinitions().toTypescriptInterface(\"Border\", Model.attributeDefinitions));\n        console.log(sb.join(\"\\n\"));\n    }\n    /** @internal */\n    static createAttributeDefinitions() {\n        const attributeDefinitions = new _AttributeDefinitions__WEBPACK_IMPORTED_MODULE_1__.AttributeDefinitions();\n        attributeDefinitions.add(\"enableEdgeDock\", true).setType(_Attribute__WEBPACK_IMPORTED_MODULE_0__.Attribute.BOOLEAN).setDescription(`enable docking to the edges of the layout, this will show the edge indicators`);\n        attributeDefinitions.add(\"rootOrientationVertical\", false).setType(_Attribute__WEBPACK_IMPORTED_MODULE_0__.Attribute.BOOLEAN).setDescription(`the top level 'row' will layout horizontally by default, set this option true to make it layout vertically`);\n        attributeDefinitions.add(\"enableRotateBorderIcons\", true).setType(_Attribute__WEBPACK_IMPORTED_MODULE_0__.Attribute.BOOLEAN).setDescription(`boolean indicating if tab icons should rotate with the text in the left and right borders`);\n        // splitter\n        attributeDefinitions.add(\"splitterSize\", 8).setType(_Attribute__WEBPACK_IMPORTED_MODULE_0__.Attribute.NUMBER).setDescription(`width in pixels of all splitters between tabsets/borders`);\n        attributeDefinitions.add(\"splitterExtra\", 0).setType(_Attribute__WEBPACK_IMPORTED_MODULE_0__.Attribute.NUMBER).setDescription(`additional width in pixels of the splitter hit test area`);\n        attributeDefinitions.add(\"splitterEnableHandle\", false).setType(_Attribute__WEBPACK_IMPORTED_MODULE_0__.Attribute.BOOLEAN).setDescription(`enable a small centralized handle on all splitters`);\n        // tab\n        attributeDefinitions.add(\"tabEnableClose\", true).setType(_Attribute__WEBPACK_IMPORTED_MODULE_0__.Attribute.BOOLEAN);\n        attributeDefinitions.add(\"tabCloseType\", 1).setType(\"ICloseType\");\n        attributeDefinitions.add(\"tabEnablePopout\", false).setType(_Attribute__WEBPACK_IMPORTED_MODULE_0__.Attribute.BOOLEAN).setAlias(\"tabEnableFloat\");\n        attributeDefinitions.add(\"tabEnablePopoutIcon\", true).setType(_Attribute__WEBPACK_IMPORTED_MODULE_0__.Attribute.BOOLEAN);\n        attributeDefinitions.add(\"tabEnablePopoutOverlay\", false).setType(_Attribute__WEBPACK_IMPORTED_MODULE_0__.Attribute.BOOLEAN);\n        attributeDefinitions.add(\"tabEnableDrag\", true).setType(_Attribute__WEBPACK_IMPORTED_MODULE_0__.Attribute.BOOLEAN);\n        attributeDefinitions.add(\"tabEnableRename\", true).setType(_Attribute__WEBPACK_IMPORTED_MODULE_0__.Attribute.BOOLEAN);\n        attributeDefinitions.add(\"tabContentClassName\", undefined).setType(_Attribute__WEBPACK_IMPORTED_MODULE_0__.Attribute.STRING);\n        attributeDefinitions.add(\"tabClassName\", undefined).setType(_Attribute__WEBPACK_IMPORTED_MODULE_0__.Attribute.STRING);\n        attributeDefinitions.add(\"tabIcon\", undefined).setType(_Attribute__WEBPACK_IMPORTED_MODULE_0__.Attribute.STRING);\n        attributeDefinitions.add(\"tabEnableRenderOnDemand\", true).setType(_Attribute__WEBPACK_IMPORTED_MODULE_0__.Attribute.BOOLEAN);\n        attributeDefinitions.add(\"tabDragSpeed\", 0.3).setType(_Attribute__WEBPACK_IMPORTED_MODULE_0__.Attribute.NUMBER);\n        attributeDefinitions.add(\"tabBorderWidth\", -1).setType(_Attribute__WEBPACK_IMPORTED_MODULE_0__.Attribute.NUMBER);\n        attributeDefinitions.add(\"tabBorderHeight\", -1).setType(_Attribute__WEBPACK_IMPORTED_MODULE_0__.Attribute.NUMBER);\n        // tabset\n        attributeDefinitions.add(\"tabSetEnableDeleteWhenEmpty\", true).setType(_Attribute__WEBPACK_IMPORTED_MODULE_0__.Attribute.BOOLEAN);\n        attributeDefinitions.add(\"tabSetEnableDrop\", true).setType(_Attribute__WEBPACK_IMPORTED_MODULE_0__.Attribute.BOOLEAN);\n        attributeDefinitions.add(\"tabSetEnableDrag\", true).setType(_Attribute__WEBPACK_IMPORTED_MODULE_0__.Attribute.BOOLEAN);\n        attributeDefinitions.add(\"tabSetEnableDivide\", true).setType(_Attribute__WEBPACK_IMPORTED_MODULE_0__.Attribute.BOOLEAN);\n        attributeDefinitions.add(\"tabSetEnableMaximize\", true).setType(_Attribute__WEBPACK_IMPORTED_MODULE_0__.Attribute.BOOLEAN);\n        attributeDefinitions.add(\"tabSetEnableClose\", false).setType(_Attribute__WEBPACK_IMPORTED_MODULE_0__.Attribute.BOOLEAN);\n        attributeDefinitions.add(\"tabSetEnableSingleTabStretch\", false).setType(_Attribute__WEBPACK_IMPORTED_MODULE_0__.Attribute.BOOLEAN);\n        attributeDefinitions.add(\"tabSetAutoSelectTab\", true).setType(_Attribute__WEBPACK_IMPORTED_MODULE_0__.Attribute.BOOLEAN);\n        attributeDefinitions.add(\"tabSetEnableActiveIcon\", false).setType(_Attribute__WEBPACK_IMPORTED_MODULE_0__.Attribute.BOOLEAN);\n        attributeDefinitions.add(\"tabSetClassNameTabStrip\", undefined).setType(_Attribute__WEBPACK_IMPORTED_MODULE_0__.Attribute.STRING);\n        attributeDefinitions.add(\"tabSetEnableTabStrip\", true).setType(_Attribute__WEBPACK_IMPORTED_MODULE_0__.Attribute.BOOLEAN);\n        attributeDefinitions.add(\"tabSetEnableTabWrap\", false).setType(_Attribute__WEBPACK_IMPORTED_MODULE_0__.Attribute.BOOLEAN);\n        attributeDefinitions.add(\"tabSetTabLocation\", \"top\").setType(\"ITabLocation\");\n        attributeDefinitions.add(\"tabMinWidth\", DefaultMin).setType(_Attribute__WEBPACK_IMPORTED_MODULE_0__.Attribute.NUMBER);\n        attributeDefinitions.add(\"tabMinHeight\", DefaultMin).setType(_Attribute__WEBPACK_IMPORTED_MODULE_0__.Attribute.NUMBER);\n        attributeDefinitions.add(\"tabSetMinWidth\", DefaultMin).setType(_Attribute__WEBPACK_IMPORTED_MODULE_0__.Attribute.NUMBER);\n        attributeDefinitions.add(\"tabSetMinHeight\", DefaultMin).setType(_Attribute__WEBPACK_IMPORTED_MODULE_0__.Attribute.NUMBER);\n        attributeDefinitions.add(\"tabMaxWidth\", DefaultMax).setType(_Attribute__WEBPACK_IMPORTED_MODULE_0__.Attribute.NUMBER);\n        attributeDefinitions.add(\"tabMaxHeight\", DefaultMax).setType(_Attribute__WEBPACK_IMPORTED_MODULE_0__.Attribute.NUMBER);\n        attributeDefinitions.add(\"tabSetMaxWidth\", DefaultMax).setType(_Attribute__WEBPACK_IMPORTED_MODULE_0__.Attribute.NUMBER);\n        attributeDefinitions.add(\"tabSetMaxHeight\", DefaultMax).setType(_Attribute__WEBPACK_IMPORTED_MODULE_0__.Attribute.NUMBER);\n        // border\n        attributeDefinitions.add(\"borderSize\", 200).setType(_Attribute__WEBPACK_IMPORTED_MODULE_0__.Attribute.NUMBER);\n        attributeDefinitions.add(\"borderMinSize\", DefaultMin).setType(_Attribute__WEBPACK_IMPORTED_MODULE_0__.Attribute.NUMBER);\n        attributeDefinitions.add(\"borderMaxSize\", DefaultMax).setType(_Attribute__WEBPACK_IMPORTED_MODULE_0__.Attribute.NUMBER);\n        attributeDefinitions.add(\"borderEnableDrop\", true).setType(_Attribute__WEBPACK_IMPORTED_MODULE_0__.Attribute.BOOLEAN);\n        attributeDefinitions.add(\"borderAutoSelectTabWhenOpen\", true).setType(_Attribute__WEBPACK_IMPORTED_MODULE_0__.Attribute.BOOLEAN);\n        attributeDefinitions.add(\"borderAutoSelectTabWhenClosed\", false).setType(_Attribute__WEBPACK_IMPORTED_MODULE_0__.Attribute.BOOLEAN);\n        attributeDefinitions.add(\"borderClassName\", undefined).setType(_Attribute__WEBPACK_IMPORTED_MODULE_0__.Attribute.STRING);\n        attributeDefinitions.add(\"borderEnableAutoHide\", false).setType(_Attribute__WEBPACK_IMPORTED_MODULE_0__.Attribute.BOOLEAN);\n        return attributeDefinitions;\n    }\n}\nModel.MAIN_WINDOW_ID = \"__main_window_id__\";\n/** @internal */\nModel.attributeDefinitions = Model.createAttributeDefinitions();\n\n\n//# sourceURL=webpack://FlexLayout/./src/model/Model.ts?");

/***/ }),

/***/ "./src/model/Node.ts":
/*!***************************!*\
  !*** ./src/model/Node.ts ***!
  \***************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   Node: () => (/* binding */ Node)\n/* harmony export */ });\n/* harmony import */ var _DockLocation__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../DockLocation */ \"./src/DockLocation.ts\");\n/* harmony import */ var _Orientation__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../Orientation */ \"./src/Orientation.ts\");\n/* harmony import */ var _Rect__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../Rect */ \"./src/Rect.ts\");\n\n\n\nclass Node {\n    /** @internal */\n    constructor(_model) {\n        this.model = _model;\n        this.attributes = {};\n        this.children = [];\n        this.rect = _Rect__WEBPACK_IMPORTED_MODULE_2__.Rect.empty();\n        this.listeners = new Map();\n        this.path = \"\";\n    }\n    getId() {\n        let id = this.attributes.id;\n        if (id !== undefined) {\n            return id;\n        }\n        id = this.model.nextUniqueId();\n        this.setId(id);\n        return id;\n    }\n    getModel() {\n        return this.model;\n    }\n    getType() {\n        return this.attributes.type;\n    }\n    getParent() {\n        return this.parent;\n    }\n    getChildren() {\n        return this.children;\n    }\n    getRect() {\n        return this.rect;\n    }\n    getPath() {\n        return this.path;\n    }\n    getOrientation() {\n        if (this.parent === undefined) {\n            return this.model.isRootOrientationVertical() ? _Orientation__WEBPACK_IMPORTED_MODULE_1__.Orientation.VERT : _Orientation__WEBPACK_IMPORTED_MODULE_1__.Orientation.HORZ;\n        }\n        else {\n            return _Orientation__WEBPACK_IMPORTED_MODULE_1__.Orientation.flip(this.parent.getOrientation());\n        }\n    }\n    // event can be: resize, visibility, maximize (on tabset), close\n    setEventListener(event, callback) {\n        this.listeners.set(event, callback);\n    }\n    removeEventListener(event) {\n        this.listeners.delete(event);\n    }\n    /** @internal */\n    setId(id) {\n        this.attributes.id = id;\n    }\n    /** @internal */\n    fireEvent(event, params) {\n        // console.log(this._type, \" fireEvent \" + event + \" \" + JSON.stringify(params));\n        if (this.listeners.has(event)) {\n            this.listeners.get(event)(params);\n        }\n    }\n    /** @internal */\n    getAttr(name) {\n        let val = this.attributes[name];\n        if (val === undefined) {\n            const modelName = this.getAttributeDefinitions().getModelName(name);\n            if (modelName !== undefined) {\n                val = this.model.getAttribute(modelName);\n            }\n        }\n        // console.log(name + \"=\" + val);\n        return val;\n    }\n    /** @internal */\n    forEachNode(fn, level) {\n        fn(this, level);\n        level++;\n        for (const node of this.children) {\n            node.forEachNode(fn, level);\n        }\n    }\n    /** @internal */\n    setPaths(path) {\n        let i = 0;\n        for (const node of this.children) {\n            let newPath = path;\n            if (node.getType() === \"row\") {\n                if (node.getOrientation() === _Orientation__WEBPACK_IMPORTED_MODULE_1__.Orientation.VERT) {\n                    newPath += \"/c\" + i;\n                }\n                else {\n                    newPath += \"/r\" + i;\n                }\n            }\n            else if (node.getType() === \"tabset\") {\n                newPath += \"/ts\" + i;\n            }\n            else if (node.getType() === \"tab\") {\n                newPath += \"/t\" + i;\n            }\n            node.path = newPath;\n            node.setPaths(newPath);\n            i++;\n        }\n    }\n    /** @internal */\n    setParent(parent) {\n        this.parent = parent;\n    }\n    /** @internal */\n    setRect(rect) {\n        this.rect = rect;\n    }\n    /** @internal */\n    setPath(path) {\n        this.path = path;\n    }\n    /** @internal */\n    setWeight(weight) {\n        this.attributes.weight = weight;\n    }\n    /** @internal */\n    setSelected(index) {\n        this.attributes.selected = index;\n    }\n    /** @internal */\n    findDropTargetNode(windowId, dragNode, x, y) {\n        let rtn;\n        if (this.rect.contains(x, y)) {\n            if (this.model.getMaximizedTabset(windowId) !== undefined) {\n                rtn = this.model.getMaximizedTabset(windowId).canDrop(dragNode, x, y);\n            }\n            else {\n                rtn = this.canDrop(dragNode, x, y);\n                if (rtn === undefined) {\n                    if (this.children.length !== 0) {\n                        for (const child of this.children) {\n                            rtn = child.findDropTargetNode(windowId, dragNode, x, y);\n                            if (rtn !== undefined) {\n                                break;\n                            }\n                        }\n                    }\n                }\n            }\n        }\n        return rtn;\n    }\n    /** @internal */\n    canDrop(dragNode, x, y) {\n        return undefined;\n    }\n    /** @internal */\n    canDockInto(dragNode, dropInfo) {\n        if (dropInfo != null) {\n            if (dropInfo.location === _DockLocation__WEBPACK_IMPORTED_MODULE_0__.DockLocation.CENTER && dropInfo.node.isEnableDrop() === false) {\n                return false;\n            }\n            // prevent named tabset docking into another tabset, since this would lose the header\n            if (dropInfo.location === _DockLocation__WEBPACK_IMPORTED_MODULE_0__.DockLocation.CENTER && dragNode.getType() === \"tabset\" && dragNode.getName() !== undefined) {\n                return false;\n            }\n            if (dropInfo.location !== _DockLocation__WEBPACK_IMPORTED_MODULE_0__.DockLocation.CENTER && dropInfo.node.isEnableDivide() === false) {\n                return false;\n            }\n            // finally check model callback to check if drop allowed\n            if (this.model.getOnAllowDrop()) {\n                return this.model.getOnAllowDrop()(dragNode, dropInfo);\n            }\n        }\n        return true;\n    }\n    /** @internal */\n    removeChild(childNode) {\n        const pos = this.children.indexOf(childNode);\n        if (pos !== -1) {\n            this.children.splice(pos, 1);\n        }\n        return pos;\n    }\n    /** @internal */\n    addChild(childNode, pos) {\n        if (pos != null) {\n            this.children.splice(pos, 0, childNode);\n        }\n        else {\n            this.children.push(childNode);\n            pos = this.children.length - 1;\n        }\n        childNode.parent = this;\n        return pos;\n    }\n    /** @internal */\n    removeAll() {\n        this.children = [];\n    }\n    /** @internal */\n    styleWithPosition(style) {\n        if (style == null) {\n            style = {};\n        }\n        return this.rect.styleWithPosition(style);\n    }\n    /** @internal */\n    isEnableDivide() {\n        return true;\n    }\n    /** @internal */\n    toAttributeString() {\n        return JSON.stringify(this.attributes, undefined, \"\\t\");\n    }\n}\n\n\n//# sourceURL=webpack://FlexLayout/./src/model/Node.ts?");

/***/ }),

/***/ "./src/model/RowNode.ts":
/*!******************************!*\
  !*** ./src/model/RowNode.ts ***!
  \******************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   RowNode: () => (/* binding */ RowNode)\n/* harmony export */ });\n/* harmony import */ var _Attribute__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../Attribute */ \"./src/Attribute.ts\");\n/* harmony import */ var _AttributeDefinitions__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../AttributeDefinitions */ \"./src/AttributeDefinitions.ts\");\n/* harmony import */ var _DockLocation__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../DockLocation */ \"./src/DockLocation.ts\");\n/* harmony import */ var _DropInfo__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../DropInfo */ \"./src/DropInfo.ts\");\n/* harmony import */ var _Orientation__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../Orientation */ \"./src/Orientation.ts\");\n/* harmony import */ var _Types__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../Types */ \"./src/Types.ts\");\n/* harmony import */ var _BorderNode__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./BorderNode */ \"./src/model/BorderNode.ts\");\n/* harmony import */ var _Model__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./Model */ \"./src/model/Model.ts\");\n/* harmony import */ var _Node__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ./Node */ \"./src/model/Node.ts\");\n/* harmony import */ var _TabSetNode__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ./TabSetNode */ \"./src/model/TabSetNode.ts\");\n/* harmony import */ var _view_Utils__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! ../view/Utils */ \"./src/view/Utils.tsx\");\n\n\n\n\n\n\n\n\n\n\n\nclass RowNode extends _Node__WEBPACK_IMPORTED_MODULE_8__.Node {\n    /** @internal */\n    static fromJson(json, model, layoutWindow) {\n        const newLayoutNode = new RowNode(model, layoutWindow.windowId, json);\n        if (json.children != null) {\n            for (const jsonChild of json.children) {\n                if (jsonChild.type === _TabSetNode__WEBPACK_IMPORTED_MODULE_9__.TabSetNode.TYPE) {\n                    const child = _TabSetNode__WEBPACK_IMPORTED_MODULE_9__.TabSetNode.fromJson(jsonChild, model, layoutWindow);\n                    newLayoutNode.addChild(child);\n                }\n                else {\n                    const child = RowNode.fromJson(jsonChild, model, layoutWindow);\n                    newLayoutNode.addChild(child);\n                }\n            }\n        }\n        return newLayoutNode;\n    }\n    /** @internal */\n    constructor(model, windowId, json) {\n        super(model);\n        this.windowId = windowId;\n        this.minHeight = _Model__WEBPACK_IMPORTED_MODULE_7__.DefaultMin;\n        this.minWidth = _Model__WEBPACK_IMPORTED_MODULE_7__.DefaultMin;\n        this.maxHeight = _Model__WEBPACK_IMPORTED_MODULE_7__.DefaultMax;\n        this.maxWidth = _Model__WEBPACK_IMPORTED_MODULE_7__.DefaultMax;\n        RowNode.attributeDefinitions.fromJson(json, this.attributes);\n        this.normalizeWeights();\n        model.addNode(this);\n    }\n    getWeight() {\n        return this.attributes.weight;\n    }\n    toJson() {\n        const json = {};\n        RowNode.attributeDefinitions.toJson(json, this.attributes);\n        json.children = [];\n        for (const child of this.children) {\n            json.children.push(child.toJson());\n        }\n        return json;\n    }\n    /** @internal */\n    getWindowId() {\n        return this.windowId;\n    }\n    setWindowId(windowId) {\n        this.windowId = windowId;\n    }\n    /** @internal */\n    setWeight(weight) {\n        this.attributes.weight = weight;\n    }\n    /** @internal */\n    getSplitterBounds(index) {\n        const h = this.getOrientation() === _Orientation__WEBPACK_IMPORTED_MODULE_4__.Orientation.HORZ;\n        const c = this.getChildren();\n        const ss = this.model.getSplitterSize();\n        const fr = c[0].getRect();\n        const lr = c[c.length - 1].getRect();\n        let p = h ? [fr.x, lr.getRight()] : [fr.y, lr.getBottom()];\n        const q = h ? [fr.x, lr.getRight()] : [fr.y, lr.getBottom()];\n        for (let i = 0; i < index; i++) {\n            const n = c[i];\n            p[0] += h ? n.getMinWidth() : n.getMinHeight();\n            q[0] += h ? n.getMaxWidth() : n.getMaxHeight();\n            if (i > 0) {\n                p[0] += ss;\n                q[0] += ss;\n            }\n        }\n        for (let i = c.length - 1; i >= index; i--) {\n            const n = c[i];\n            p[1] -= (h ? n.getMinWidth() : n.getMinHeight()) + ss;\n            q[1] -= (h ? n.getMaxWidth() : n.getMaxHeight()) + ss;\n        }\n        p = [Math.max(q[1], p[0]), Math.min(q[0], p[1])];\n        return p;\n    }\n    /** @internal */\n    getSplitterInitials(index) {\n        const h = this.getOrientation() === _Orientation__WEBPACK_IMPORTED_MODULE_4__.Orientation.HORZ;\n        const c = this.getChildren();\n        const ss = this.model.getSplitterSize();\n        const initialSizes = [];\n        let sum = 0;\n        for (let i = 0; i < c.length; i++) {\n            const n = c[i];\n            const r = n.getRect();\n            const s = h ? r.width : r.height;\n            initialSizes.push(s);\n            sum += s;\n        }\n        const startRect = c[index].getRect();\n        const startPosition = (h ? startRect.x : startRect.y) - ss;\n        return { initialSizes, sum, startPosition };\n    }\n    /** @internal */\n    calculateSplit(index, splitterPos, initialSizes, sum, startPosition) {\n        const h = this.getOrientation() === _Orientation__WEBPACK_IMPORTED_MODULE_4__.Orientation.HORZ;\n        const c = this.getChildren();\n        const sn = c[index];\n        const smax = h ? sn.getMaxWidth() : sn.getMaxHeight();\n        const sizes = [...initialSizes];\n        if (splitterPos < startPosition) { // moved left\n            let shift = startPosition - splitterPos;\n            let altShift = 0;\n            if (sizes[index] + shift > smax) {\n                altShift = sizes[index] + shift - smax;\n                sizes[index] = smax;\n            }\n            else {\n                sizes[index] += shift;\n            }\n            for (let i = index - 1; i >= 0; i--) {\n                const n = c[i];\n                const m = h ? n.getMinWidth() : n.getMinHeight();\n                if (sizes[i] - shift > m) {\n                    sizes[i] -= shift;\n                    break;\n                }\n                else {\n                    shift -= sizes[i] - m;\n                    sizes[i] = m;\n                }\n            }\n            for (let i = index + 1; i < c.length; i++) {\n                const n = c[i];\n                const m = h ? n.getMaxWidth() : n.getMaxHeight();\n                if (sizes[i] + altShift < m) {\n                    sizes[i] += altShift;\n                    break;\n                }\n                else {\n                    altShift -= m - sizes[i];\n                    sizes[i] = m;\n                }\n            }\n        }\n        else {\n            let shift = splitterPos - startPosition;\n            let altShift = 0;\n            if (sizes[index - 1] + shift > smax) {\n                altShift = sizes[index - 1] + shift - smax;\n                sizes[index - 1] = smax;\n            }\n            else {\n                sizes[index - 1] += shift;\n            }\n            for (let i = index; i < c.length; i++) {\n                const n = c[i];\n                const m = h ? n.getMinWidth() : n.getMinHeight();\n                if (sizes[i] - shift > m) {\n                    sizes[i] -= shift;\n                    break;\n                }\n                else {\n                    shift -= sizes[i] - m;\n                    sizes[i] = m;\n                }\n            }\n            for (let i = index - 1; i >= 0; i--) {\n                const n = c[i];\n                const m = h ? n.getMaxWidth() : n.getMaxHeight();\n                if (sizes[i] + altShift < m) {\n                    sizes[i] += altShift;\n                    break;\n                }\n                else {\n                    altShift -= m - sizes[i];\n                    sizes[i] = m;\n                }\n            }\n        }\n        // 0.1 is to prevent weight ever going to zero\n        const weights = sizes.map(s => Math.max(0.1, s) * 100 / sum);\n        // console.log(splitterPos, startPosition, \"sizes\", sizes);\n        // console.log(\"weights\",weights);\n        return weights;\n    }\n    /** @internal */\n    getMinSize(orientation) {\n        if (orientation === _Orientation__WEBPACK_IMPORTED_MODULE_4__.Orientation.HORZ) {\n            return this.getMinWidth();\n        }\n        else {\n            return this.getMinHeight();\n        }\n    }\n    /** @internal */\n    getMinWidth() {\n        return this.minWidth;\n    }\n    /** @internal */\n    getMinHeight() {\n        return this.minHeight;\n    }\n    /** @internal */\n    getMaxSize(orientation) {\n        if (orientation === _Orientation__WEBPACK_IMPORTED_MODULE_4__.Orientation.HORZ) {\n            return this.getMaxWidth();\n        }\n        else {\n            return this.getMaxHeight();\n        }\n    }\n    /** @internal */\n    getMaxWidth() {\n        return this.maxWidth;\n    }\n    /** @internal */\n    getMaxHeight() {\n        return this.maxHeight;\n    }\n    /** @internal */\n    calcMinMaxSize() {\n        this.minHeight = _Model__WEBPACK_IMPORTED_MODULE_7__.DefaultMin;\n        this.minWidth = _Model__WEBPACK_IMPORTED_MODULE_7__.DefaultMin;\n        this.maxHeight = _Model__WEBPACK_IMPORTED_MODULE_7__.DefaultMax;\n        this.maxWidth = _Model__WEBPACK_IMPORTED_MODULE_7__.DefaultMax;\n        let first = true;\n        for (const child of this.children) {\n            const c = child;\n            c.calcMinMaxSize();\n            if (this.getOrientation() === _Orientation__WEBPACK_IMPORTED_MODULE_4__.Orientation.VERT) {\n                this.minHeight += c.getMinHeight();\n                this.maxHeight += c.getMaxHeight();\n                if (!first) {\n                    this.minHeight += this.model.getSplitterSize();\n                    this.maxHeight += this.model.getSplitterSize();\n                }\n                this.minWidth = Math.max(this.minWidth, c.getMinWidth());\n                this.maxWidth = Math.min(this.maxWidth, c.getMaxWidth());\n            }\n            else {\n                this.minWidth += c.getMinWidth();\n                this.maxWidth += c.getMaxWidth();\n                if (!first) {\n                    this.minWidth += this.model.getSplitterSize();\n                    this.maxWidth += this.model.getSplitterSize();\n                }\n                this.minHeight = Math.max(this.minHeight, c.getMinHeight());\n                this.maxHeight = Math.min(this.maxHeight, c.getMaxHeight());\n            }\n            first = false;\n        }\n    }\n    /** @internal */\n    tidy() {\n        let i = 0;\n        while (i < this.children.length) {\n            const child = this.children[i];\n            if (child instanceof RowNode) {\n                child.tidy();\n                const childChildren = child.getChildren();\n                if (childChildren.length === 0) {\n                    this.removeChild(child);\n                }\n                else if (childChildren.length === 1) {\n                    // hoist child/children up to this level\n                    const subchild = childChildren[0];\n                    this.removeChild(child);\n                    if (subchild instanceof RowNode) {\n                        let subChildrenTotal = 0;\n                        const subChildChildren = subchild.getChildren();\n                        for (const ssc of subChildChildren) {\n                            const subsubChild = ssc;\n                            subChildrenTotal += subsubChild.getWeight();\n                        }\n                        for (let j = 0; j < subChildChildren.length; j++) {\n                            const subsubChild = subChildChildren[j];\n                            subsubChild.setWeight((child.getWeight() * subsubChild.getWeight()) / subChildrenTotal);\n                            this.addChild(subsubChild, i + j);\n                        }\n                    }\n                    else {\n                        subchild.setWeight(child.getWeight());\n                        this.addChild(subchild, i);\n                    }\n                }\n                else {\n                    i++;\n                }\n            }\n            else if (child instanceof _TabSetNode__WEBPACK_IMPORTED_MODULE_9__.TabSetNode && child.getChildren().length === 0) {\n                if (child.isEnableDeleteWhenEmpty()) {\n                    this.removeChild(child);\n                    if (child === this.model.getMaximizedTabset(this.windowId)) {\n                        this.model.setMaximizedTabset(undefined, this.windowId);\n                    }\n                }\n                else {\n                    i++;\n                }\n            }\n            else {\n                i++;\n            }\n        }\n        // add tabset into empty root\n        if (this === this.model.getRoot(this.windowId) && this.children.length === 0) {\n            const callback = this.model.getOnCreateTabSet();\n            let attrs = callback ? callback() : {};\n            attrs = Object.assign(Object.assign({}, attrs), { selected: -1 });\n            const child = new _TabSetNode__WEBPACK_IMPORTED_MODULE_9__.TabSetNode(this.model, attrs);\n            this.model.setActiveTabset(child, this.windowId);\n            this.addChild(child);\n        }\n    }\n    /** @internal */\n    canDrop(dragNode, x, y) {\n        const yy = y - this.rect.y;\n        const xx = x - this.rect.x;\n        const w = this.rect.width;\n        const h = this.rect.height;\n        const margin = 10; // height of edge rect\n        const half = 50; // half width of edge rect\n        let dropInfo;\n        if (this.getWindowId() !== _Model__WEBPACK_IMPORTED_MODULE_7__.Model.MAIN_WINDOW_ID && !(0,_view_Utils__WEBPACK_IMPORTED_MODULE_10__.canDockToWindow)(dragNode)) {\n            return undefined;\n        }\n        if (this.model.isEnableEdgeDock() && this.parent === undefined) {\n            if (x < this.rect.x + margin && yy > h / 2 - half && yy < h / 2 + half) {\n                const dockLocation = _DockLocation__WEBPACK_IMPORTED_MODULE_2__.DockLocation.LEFT;\n                const outlineRect = dockLocation.getDockRect(this.rect);\n                outlineRect.width = outlineRect.width / 2;\n                dropInfo = new _DropInfo__WEBPACK_IMPORTED_MODULE_3__.DropInfo(this, outlineRect, dockLocation, -1, _Types__WEBPACK_IMPORTED_MODULE_5__.CLASSES.FLEXLAYOUT__OUTLINE_RECT_EDGE);\n            }\n            else if (x > this.rect.getRight() - margin && yy > h / 2 - half && yy < h / 2 + half) {\n                const dockLocation = _DockLocation__WEBPACK_IMPORTED_MODULE_2__.DockLocation.RIGHT;\n                const outlineRect = dockLocation.getDockRect(this.rect);\n                outlineRect.width = outlineRect.width / 2;\n                outlineRect.x += outlineRect.width;\n                dropInfo = new _DropInfo__WEBPACK_IMPORTED_MODULE_3__.DropInfo(this, outlineRect, dockLocation, -1, _Types__WEBPACK_IMPORTED_MODULE_5__.CLASSES.FLEXLAYOUT__OUTLINE_RECT_EDGE);\n            }\n            else if (y < this.rect.y + margin && xx > w / 2 - half && xx < w / 2 + half) {\n                const dockLocation = _DockLocation__WEBPACK_IMPORTED_MODULE_2__.DockLocation.TOP;\n                const outlineRect = dockLocation.getDockRect(this.rect);\n                outlineRect.height = outlineRect.height / 2;\n                dropInfo = new _DropInfo__WEBPACK_IMPORTED_MODULE_3__.DropInfo(this, outlineRect, dockLocation, -1, _Types__WEBPACK_IMPORTED_MODULE_5__.CLASSES.FLEXLAYOUT__OUTLINE_RECT_EDGE);\n            }\n            else if (y > this.rect.getBottom() - margin && xx > w / 2 - half && xx < w / 2 + half) {\n                const dockLocation = _DockLocation__WEBPACK_IMPORTED_MODULE_2__.DockLocation.BOTTOM;\n                const outlineRect = dockLocation.getDockRect(this.rect);\n                outlineRect.height = outlineRect.height / 2;\n                outlineRect.y += outlineRect.height;\n                dropInfo = new _DropInfo__WEBPACK_IMPORTED_MODULE_3__.DropInfo(this, outlineRect, dockLocation, -1, _Types__WEBPACK_IMPORTED_MODULE_5__.CLASSES.FLEXLAYOUT__OUTLINE_RECT_EDGE);\n            }\n            if (dropInfo !== undefined) {\n                if (!dragNode.canDockInto(dragNode, dropInfo)) {\n                    return undefined;\n                }\n            }\n        }\n        return dropInfo;\n    }\n    /** @internal */\n    drop(dragNode, location, index) {\n        const dockLocation = location;\n        const parent = dragNode.getParent();\n        if (parent) {\n            parent.removeChild(dragNode);\n        }\n        if (parent !== undefined && parent instanceof _TabSetNode__WEBPACK_IMPORTED_MODULE_9__.TabSetNode) {\n            parent.setSelected(0);\n        }\n        if (parent !== undefined && parent instanceof _BorderNode__WEBPACK_IMPORTED_MODULE_6__.BorderNode) {\n            parent.setSelected(-1);\n        }\n        let node;\n        if (dragNode instanceof _TabSetNode__WEBPACK_IMPORTED_MODULE_9__.TabSetNode || dragNode instanceof RowNode) {\n            node = dragNode;\n            // need to turn round if same orientation unless docking oposite direction\n            if (node instanceof RowNode && node.getOrientation() === this.getOrientation() &&\n                (location.getOrientation() === this.getOrientation() || location === _DockLocation__WEBPACK_IMPORTED_MODULE_2__.DockLocation.CENTER)) {\n                node = new RowNode(this.model, this.windowId, {});\n                node.addChild(dragNode);\n            }\n        }\n        else {\n            const callback = this.model.getOnCreateTabSet();\n            node = new _TabSetNode__WEBPACK_IMPORTED_MODULE_9__.TabSetNode(this.model, callback ? callback(dragNode) : {});\n            node.addChild(dragNode);\n        }\n        let size = this.children.reduce((sum, child) => {\n            return sum + child.getWeight();\n        }, 0);\n        if (size === 0) {\n            size = 100;\n        }\n        node.setWeight(size / 3);\n        const horz = !this.model.isRootOrientationVertical();\n        if (dockLocation === _DockLocation__WEBPACK_IMPORTED_MODULE_2__.DockLocation.CENTER) {\n            if (index === -1) {\n                this.addChild(node, this.children.length);\n            }\n            else {\n                this.addChild(node, index);\n            }\n        }\n        else if (horz && dockLocation === _DockLocation__WEBPACK_IMPORTED_MODULE_2__.DockLocation.LEFT || !horz && dockLocation === _DockLocation__WEBPACK_IMPORTED_MODULE_2__.DockLocation.TOP) {\n            this.addChild(node, 0);\n        }\n        else if (horz && dockLocation === _DockLocation__WEBPACK_IMPORTED_MODULE_2__.DockLocation.RIGHT || !horz && dockLocation === _DockLocation__WEBPACK_IMPORTED_MODULE_2__.DockLocation.BOTTOM) {\n            this.addChild(node);\n        }\n        else if (horz && dockLocation === _DockLocation__WEBPACK_IMPORTED_MODULE_2__.DockLocation.TOP || !horz && dockLocation === _DockLocation__WEBPACK_IMPORTED_MODULE_2__.DockLocation.LEFT) {\n            const vrow = new RowNode(this.model, this.windowId, {});\n            const hrow = new RowNode(this.model, this.windowId, {});\n            hrow.setWeight(75);\n            node.setWeight(25);\n            for (const child of this.children) {\n                hrow.addChild(child);\n            }\n            this.removeAll();\n            vrow.addChild(node);\n            vrow.addChild(hrow);\n            this.addChild(vrow);\n        }\n        else if (horz && dockLocation === _DockLocation__WEBPACK_IMPORTED_MODULE_2__.DockLocation.BOTTOM || !horz && dockLocation === _DockLocation__WEBPACK_IMPORTED_MODULE_2__.DockLocation.RIGHT) {\n            const vrow = new RowNode(this.model, this.windowId, {});\n            const hrow = new RowNode(this.model, this.windowId, {});\n            hrow.setWeight(75);\n            node.setWeight(25);\n            for (const child of this.children) {\n                hrow.addChild(child);\n            }\n            this.removeAll();\n            vrow.addChild(hrow);\n            vrow.addChild(node);\n            this.addChild(vrow);\n        }\n        if (node instanceof _TabSetNode__WEBPACK_IMPORTED_MODULE_9__.TabSetNode) {\n            this.model.setActiveTabset(node, this.windowId);\n        }\n        this.model.tidy();\n    }\n    /** @internal */\n    isEnableDrop() {\n        return true;\n    }\n    /** @internal */\n    getAttributeDefinitions() {\n        return RowNode.attributeDefinitions;\n    }\n    /** @internal */\n    updateAttrs(json) {\n        RowNode.attributeDefinitions.update(json, this.attributes);\n    }\n    /** @internal */\n    static getAttributeDefinitions() {\n        return RowNode.attributeDefinitions;\n    }\n    // NOTE:  flex-grow cannot have values < 1 otherwise will not fill parent, need to normalize \n    normalizeWeights() {\n        let sum = 0;\n        for (const n of this.children) {\n            const node = n;\n            sum += node.getWeight();\n        }\n        if (sum === 0) {\n            sum = 1;\n        }\n        for (const n of this.children) {\n            const node = n;\n            node.setWeight(Math.max(0.001, 100 * node.getWeight() / sum));\n        }\n    }\n    /** @internal */\n    static createAttributeDefinitions() {\n        const attributeDefinitions = new _AttributeDefinitions__WEBPACK_IMPORTED_MODULE_1__.AttributeDefinitions();\n        attributeDefinitions.add(\"type\", RowNode.TYPE, true).setType(_Attribute__WEBPACK_IMPORTED_MODULE_0__.Attribute.STRING).setFixed();\n        attributeDefinitions.add(\"id\", undefined).setType(_Attribute__WEBPACK_IMPORTED_MODULE_0__.Attribute.STRING).setDescription(`the unique id of the row, if left undefined a uuid will be assigned`);\n        attributeDefinitions.add(\"weight\", 100).setType(_Attribute__WEBPACK_IMPORTED_MODULE_0__.Attribute.NUMBER).setDescription(`relative weight for sizing of this row in parent row`);\n        return attributeDefinitions;\n    }\n}\nRowNode.TYPE = \"row\";\n/** @internal */\nRowNode.attributeDefinitions = RowNode.createAttributeDefinitions();\n\n\n//# sourceURL=webpack://FlexLayout/./src/model/RowNode.ts?");

/***/ }),

/***/ "./src/model/TabNode.ts":
/*!******************************!*\
  !*** ./src/model/TabNode.ts ***!
  \******************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   TabNode: () => (/* binding */ TabNode)\n/* harmony export */ });\n/* harmony import */ var _Attribute__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../Attribute */ \"./src/Attribute.ts\");\n/* harmony import */ var _AttributeDefinitions__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../AttributeDefinitions */ \"./src/AttributeDefinitions.ts\");\n/* harmony import */ var _Rect__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../Rect */ \"./src/Rect.ts\");\n/* harmony import */ var _Model__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./Model */ \"./src/model/Model.ts\");\n/* harmony import */ var _Node__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./Node */ \"./src/model/Node.ts\");\n/* harmony import */ var _TabSetNode__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./TabSetNode */ \"./src/model/TabSetNode.ts\");\n\n\n\n\n\n\nclass TabNode extends _Node__WEBPACK_IMPORTED_MODULE_4__.Node {\n    /** @internal */\n    static fromJson(json, model, addToModel = true) {\n        const newLayoutNode = new TabNode(model, json, addToModel);\n        return newLayoutNode;\n    }\n    /** @internal */\n    constructor(model, json, addToModel = true) {\n        super(model);\n        /** @internal */\n        this.tabRect = _Rect__WEBPACK_IMPORTED_MODULE_2__.Rect.empty();\n        this.extra = {}; // extra data added to node not saved in json\n        this.moveableElement = null;\n        this.tabStamp = null;\n        this.rendered = false;\n        this.visible = false;\n        TabNode.attributeDefinitions.fromJson(json, this.attributes);\n        if (addToModel === true) {\n            model.addNode(this);\n        }\n    }\n    getName() {\n        return this.getAttr(\"name\");\n    }\n    getHelpText() {\n        return this.getAttr(\"helpText\");\n    }\n    getComponent() {\n        return this.getAttr(\"component\");\n    }\n    getWindowId() {\n        if (this.parent instanceof _TabSetNode__WEBPACK_IMPORTED_MODULE_5__.TabSetNode) {\n            return this.parent.getWindowId();\n        }\n        return _Model__WEBPACK_IMPORTED_MODULE_3__.Model.MAIN_WINDOW_ID;\n    }\n    getWindow() {\n        const layoutWindow = this.model.getwindowsMap().get(this.getWindowId());\n        if (layoutWindow) {\n            return layoutWindow.window;\n        }\n        return undefined;\n    }\n    /**\n     * Returns the config attribute that can be used to store node specific data that\n     * WILL be saved to the json. The config attribute should be changed via the action Actions.updateNodeAttributes rather\n     * than directly, for example:\n     * this.state.model.doAction(\n     *   FlexLayout.Actions.updateNodeAttributes(node.getId(), {config:myConfigObject}));\n     */\n    getConfig() {\n        return this.attributes.config;\n    }\n    /**\n     * Returns an object that can be used to store transient node specific data that will\n     * NOT be saved in the json.\n     */\n    getExtraData() {\n        return this.extra;\n    }\n    isPoppedOut() {\n        return this.getWindowId() !== _Model__WEBPACK_IMPORTED_MODULE_3__.Model.MAIN_WINDOW_ID;\n    }\n    isSelected() {\n        return this.getParent().getSelectedNode() === this;\n    }\n    getIcon() {\n        return this.getAttr(\"icon\");\n    }\n    isEnableClose() {\n        return this.getAttr(\"enableClose\");\n    }\n    getCloseType() {\n        return this.getAttr(\"closeType\");\n    }\n    isEnablePopout() {\n        return this.getAttr(\"enablePopout\");\n    }\n    isEnablePopoutIcon() {\n        return this.getAttr(\"enablePopoutIcon\");\n    }\n    isEnablePopoutOverlay() {\n        return this.getAttr(\"enablePopoutOverlay\");\n    }\n    isEnableDrag() {\n        return this.getAttr(\"enableDrag\");\n    }\n    isEnableRename() {\n        return this.getAttr(\"enableRename\");\n    }\n    isEnableWindowReMount() {\n        return this.getAttr(\"enableWindowReMount\");\n    }\n    getClassName() {\n        return this.getAttr(\"className\");\n    }\n    getContentClassName() {\n        return this.getAttr(\"contentClassName\");\n    }\n    getTabSetClassName() {\n        return this.getAttr(\"tabsetClassName\");\n    }\n    isEnableRenderOnDemand() {\n        return this.getAttr(\"enableRenderOnDemand\");\n    }\n    getMinWidth() {\n        return this.getAttr(\"minWidth\");\n    }\n    getMinHeight() {\n        return this.getAttr(\"minHeight\");\n    }\n    getMaxWidth() {\n        return this.getAttr(\"maxWidth\");\n    }\n    getMaxHeight() {\n        return this.getAttr(\"maxHeight\");\n    }\n    toJson() {\n        const json = {};\n        TabNode.attributeDefinitions.toJson(json, this.attributes);\n        return json;\n    }\n    /** @internal */\n    saveScrollPosition() {\n        if (this.moveableElement) {\n            this.scrollLeft = this.moveableElement.scrollLeft;\n            this.scrollTop = this.moveableElement.scrollTop;\n            // console.log(\"save\", this.getName(), this.scrollTop);\n        }\n    }\n    /** @internal */\n    restoreScrollPosition() {\n        if (this.scrollTop) {\n            requestAnimationFrame(() => {\n                if (this.moveableElement) {\n                    if (this.scrollTop) {\n                        // console.log(\"restore\", this.getName(), this.scrollTop);\n                        this.moveableElement.scrollTop = this.scrollTop;\n                        this.moveableElement.scrollLeft = this.scrollLeft;\n                    }\n                }\n            });\n        }\n    }\n    /** @internal */\n    setRect(rect) {\n        if (!rect.equals(this.rect)) {\n            this.fireEvent(\"resize\", { rect });\n            this.rect = rect;\n        }\n    }\n    /** @internal */\n    setVisible(visible) {\n        if (visible !== this.visible) {\n            this.fireEvent(\"visibility\", { visible });\n            this.visible = visible;\n        }\n    }\n    /** @internal */\n    getScrollTop() {\n        return this.scrollTop;\n    }\n    /** @internal */\n    setScrollTop(scrollTop) {\n        this.scrollTop = scrollTop;\n    }\n    /** @internal */\n    getScrollLeft() {\n        return this.scrollLeft;\n    }\n    /** @internal */\n    setScrollLeft(scrollLeft) {\n        this.scrollLeft = scrollLeft;\n    }\n    /** @internal */\n    isRendered() {\n        return this.rendered;\n    }\n    /** @internal */\n    setRendered(rendered) {\n        this.rendered = rendered;\n    }\n    /** @internal */\n    getTabRect() {\n        return this.tabRect;\n    }\n    /** @internal */\n    setTabRect(rect) {\n        this.tabRect = rect;\n    }\n    /** @internal */\n    getTabStamp() {\n        return this.tabStamp;\n    }\n    /** @internal */\n    setTabStamp(stamp) {\n        this.tabStamp = stamp;\n    }\n    /** @internal */\n    getMoveableElement() {\n        return this.moveableElement;\n    }\n    /** @internal */\n    setMoveableElement(element) {\n        this.moveableElement = element;\n    }\n    /** @internal */\n    setRenderedName(name) {\n        this.renderedName = name;\n    }\n    /** @internal */\n    getNameForOverflowMenu() {\n        const altName = this.getAttr(\"altName\");\n        if (altName !== undefined) {\n            return altName;\n        }\n        return this.renderedName;\n    }\n    /** @internal */\n    setName(name) {\n        this.attributes.name = name;\n    }\n    /** @internal */\n    delete() {\n        this.parent.remove(this);\n        this.fireEvent(\"close\", {});\n    }\n    /** @internal */\n    updateAttrs(json) {\n        TabNode.attributeDefinitions.update(json, this.attributes);\n    }\n    /** @internal */\n    getAttributeDefinitions() {\n        return TabNode.attributeDefinitions;\n    }\n    /** @internal */\n    setBorderWidth(width) {\n        this.attributes.borderWidth = width;\n    }\n    /** @internal */\n    setBorderHeight(height) {\n        this.attributes.borderHeight = height;\n    }\n    /** @internal */\n    static getAttributeDefinitions() {\n        return TabNode.attributeDefinitions;\n    }\n    /** @internal */\n    static createAttributeDefinitions() {\n        const attributeDefinitions = new _AttributeDefinitions__WEBPACK_IMPORTED_MODULE_1__.AttributeDefinitions();\n        attributeDefinitions.add(\"type\", TabNode.TYPE, true).setType(_Attribute__WEBPACK_IMPORTED_MODULE_0__.Attribute.STRING).setFixed();\n        attributeDefinitions.add(\"id\", undefined).setType(_Attribute__WEBPACK_IMPORTED_MODULE_0__.Attribute.STRING).setDescription(`the unique id of the tab, if left undefined a uuid will be assigned`);\n        attributeDefinitions.add(\"name\", \"[Unnamed Tab]\").setType(_Attribute__WEBPACK_IMPORTED_MODULE_0__.Attribute.STRING).setDescription(`name of tab to be displayed in the tab button`);\n        attributeDefinitions.add(\"altName\", undefined).setType(_Attribute__WEBPACK_IMPORTED_MODULE_0__.Attribute.STRING).setDescription(`if there is no name specifed then this value will be used in the overflow menu`);\n        attributeDefinitions.add(\"helpText\", undefined).setType(_Attribute__WEBPACK_IMPORTED_MODULE_0__.Attribute.STRING).setDescription(`An optional help text for the tab to be displayed upon tab hover.`);\n        attributeDefinitions.add(\"component\", undefined).setType(_Attribute__WEBPACK_IMPORTED_MODULE_0__.Attribute.STRING).setDescription(`string identifying which component to run (for factory)`);\n        attributeDefinitions.add(\"config\", undefined).setType(\"any\").setDescription(`a place to hold json config for the hosted component`);\n        attributeDefinitions.add(\"tabsetClassName\", undefined).setType(_Attribute__WEBPACK_IMPORTED_MODULE_0__.Attribute.STRING).setDescription(`class applied to parent tabset when this is the only tab and it is stretched to fill the tabset`);\n        attributeDefinitions.add(\"enableWindowReMount\", false).setType(_Attribute__WEBPACK_IMPORTED_MODULE_0__.Attribute.BOOLEAN).setDescription(`if enabled the tab will re-mount when popped out/in`);\n        attributeDefinitions.addInherited(\"enableClose\", \"tabEnableClose\").setType(_Attribute__WEBPACK_IMPORTED_MODULE_0__.Attribute.BOOLEAN).setDescription(`allow user to close tab via close button`);\n        attributeDefinitions.addInherited(\"closeType\", \"tabCloseType\").setType(\"ICloseType\").setDescription(`see values in ICloseType`);\n        attributeDefinitions.addInherited(\"enableDrag\", \"tabEnableDrag\").setType(_Attribute__WEBPACK_IMPORTED_MODULE_0__.Attribute.BOOLEAN).setDescription(`allow user to drag tab to new location`);\n        attributeDefinitions.addInherited(\"enableRename\", \"tabEnableRename\").setType(_Attribute__WEBPACK_IMPORTED_MODULE_0__.Attribute.BOOLEAN).setDescription(`allow user to rename tabs by double clicking`);\n        attributeDefinitions.addInherited(\"className\", \"tabClassName\").setType(_Attribute__WEBPACK_IMPORTED_MODULE_0__.Attribute.STRING).setDescription(`class applied to tab button`);\n        attributeDefinitions.addInherited(\"contentClassName\", \"tabContentClassName\").setType(_Attribute__WEBPACK_IMPORTED_MODULE_0__.Attribute.STRING).setDescription(`class applied to tab content`);\n        attributeDefinitions.addInherited(\"icon\", \"tabIcon\").setType(_Attribute__WEBPACK_IMPORTED_MODULE_0__.Attribute.STRING).setDescription(`the tab icon`);\n        attributeDefinitions.addInherited(\"enableRenderOnDemand\", \"tabEnableRenderOnDemand\").setType(_Attribute__WEBPACK_IMPORTED_MODULE_0__.Attribute.BOOLEAN).setDescription(`whether to avoid rendering component until tab is visible`);\n        attributeDefinitions.addInherited(\"enablePopout\", \"tabEnablePopout\").setType(_Attribute__WEBPACK_IMPORTED_MODULE_0__.Attribute.BOOLEAN).setAlias(\"enableFloat\").setDescription(`enable popout (in popout capable browser)`);\n        attributeDefinitions.addInherited(\"enablePopoutIcon\", \"tabEnablePopoutIcon\").setType(_Attribute__WEBPACK_IMPORTED_MODULE_0__.Attribute.BOOLEAN).setDescription(`whether to show the popout icon in the tabset header if this tab enables popouts`);\n        attributeDefinitions.addInherited(\"enablePopoutOverlay\", \"tabEnablePopoutOverlay\").setType(_Attribute__WEBPACK_IMPORTED_MODULE_0__.Attribute.BOOLEAN).setDescription(`if this tab will not work correctly in a popout window when the main window is backgrounded (inactive)\r\n            then enabling this option will gray out this tab`);\n        attributeDefinitions.addInherited(\"borderWidth\", \"tabBorderWidth\").setType(_Attribute__WEBPACK_IMPORTED_MODULE_0__.Attribute.NUMBER).setDescription(`width when added to border, -1 will use border size`);\n        attributeDefinitions.addInherited(\"borderHeight\", \"tabBorderHeight\").setType(_Attribute__WEBPACK_IMPORTED_MODULE_0__.Attribute.NUMBER).setDescription(`height when added to border, -1 will use border size`);\n        attributeDefinitions.addInherited(\"minWidth\", \"tabMinWidth\").setType(_Attribute__WEBPACK_IMPORTED_MODULE_0__.Attribute.NUMBER).setDescription(`the min width of this tab`);\n        attributeDefinitions.addInherited(\"minHeight\", \"tabMinHeight\").setType(_Attribute__WEBPACK_IMPORTED_MODULE_0__.Attribute.NUMBER).setDescription(`the min height of this tab`);\n        attributeDefinitions.addInherited(\"maxWidth\", \"tabMaxWidth\").setType(_Attribute__WEBPACK_IMPORTED_MODULE_0__.Attribute.NUMBER).setDescription(`the max width of this tab`);\n        attributeDefinitions.addInherited(\"maxHeight\", \"tabMaxHeight\").setType(_Attribute__WEBPACK_IMPORTED_MODULE_0__.Attribute.NUMBER).setDescription(`the max height of this tab`);\n        return attributeDefinitions;\n    }\n}\nTabNode.TYPE = \"tab\";\n/** @internal */\nTabNode.attributeDefinitions = TabNode.createAttributeDefinitions();\n\n\n//# sourceURL=webpack://FlexLayout/./src/model/TabNode.ts?");

/***/ }),

/***/ "./src/model/TabSetNode.ts":
/*!*********************************!*\
  !*** ./src/model/TabSetNode.ts ***!
  \*********************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   TabSetNode: () => (/* binding */ TabSetNode)\n/* harmony export */ });\n/* harmony import */ var _Attribute__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../Attribute */ \"./src/Attribute.ts\");\n/* harmony import */ var _AttributeDefinitions__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../AttributeDefinitions */ \"./src/AttributeDefinitions.ts\");\n/* harmony import */ var _DockLocation__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../DockLocation */ \"./src/DockLocation.ts\");\n/* harmony import */ var _DropInfo__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../DropInfo */ \"./src/DropInfo.ts\");\n/* harmony import */ var _Orientation__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../Orientation */ \"./src/Orientation.ts\");\n/* harmony import */ var _Rect__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../Rect */ \"./src/Rect.ts\");\n/* harmony import */ var _Types__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ../Types */ \"./src/Types.ts\");\n/* harmony import */ var _view_Utils__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ../view/Utils */ \"./src/view/Utils.tsx\");\n/* harmony import */ var _BorderNode__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ./BorderNode */ \"./src/model/BorderNode.ts\");\n/* harmony import */ var _Model__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ./Model */ \"./src/model/Model.ts\");\n/* harmony import */ var _Node__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! ./Node */ \"./src/model/Node.ts\");\n/* harmony import */ var _RowNode__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(/*! ./RowNode */ \"./src/model/RowNode.ts\");\n/* harmony import */ var _TabNode__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__(/*! ./TabNode */ \"./src/model/TabNode.ts\");\n/* harmony import */ var _Utils__WEBPACK_IMPORTED_MODULE_13__ = __webpack_require__(/*! ./Utils */ \"./src/model/Utils.ts\");\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nclass TabSetNode extends _Node__WEBPACK_IMPORTED_MODULE_10__.Node {\n    /** @internal */\n    static fromJson(json, model, layoutWindow) {\n        const newLayoutNode = new TabSetNode(model, json);\n        if (json.children != null) {\n            for (const jsonChild of json.children) {\n                const child = _TabNode__WEBPACK_IMPORTED_MODULE_12__.TabNode.fromJson(jsonChild, model);\n                newLayoutNode.addChild(child);\n            }\n        }\n        if (newLayoutNode.children.length === 0) {\n            newLayoutNode.setSelected(-1);\n        }\n        if (json.maximized && json.maximized === true) {\n            layoutWindow.maximizedTabSet = newLayoutNode;\n        }\n        if (json.active && json.active === true) {\n            layoutWindow.activeTabSet = newLayoutNode;\n        }\n        return newLayoutNode;\n    }\n    /** @internal */\n    constructor(model, json) {\n        super(model);\n        /** @internal */\n        this.tabStripRect = _Rect__WEBPACK_IMPORTED_MODULE_5__.Rect.empty();\n        /** @internal */\n        this.contentRect = _Rect__WEBPACK_IMPORTED_MODULE_5__.Rect.empty();\n        this.calculatedMinHeight = 0;\n        this.calculatedMinWidth = 0;\n        this.calculatedMaxHeight = 0;\n        this.calculatedMaxWidth = 0;\n        TabSetNode.attributeDefinitions.fromJson(json, this.attributes);\n        model.addNode(this);\n    }\n    getName() {\n        return this.getAttr(\"name\");\n    }\n    isEnableActiveIcon() {\n        return this.getAttr(\"enableActiveIcon\");\n    }\n    getSelected() {\n        const selected = this.attributes.selected;\n        if (selected !== undefined) {\n            return selected;\n        }\n        return -1;\n    }\n    getSelectedNode() {\n        const selected = this.getSelected();\n        if (selected !== -1) {\n            return this.children[selected];\n        }\n        return undefined;\n    }\n    getWeight() {\n        return this.getAttr(\"weight\");\n    }\n    getAttrMinWidth() {\n        return this.getAttr(\"minWidth\");\n    }\n    getAttrMinHeight() {\n        return this.getAttr(\"minHeight\");\n    }\n    getMinWidth() {\n        return this.calculatedMinWidth;\n    }\n    getMinHeight() {\n        return this.calculatedMinHeight;\n    }\n    /** @internal */\n    getMinSize(orientation) {\n        if (orientation === _Orientation__WEBPACK_IMPORTED_MODULE_4__.Orientation.HORZ) {\n            return this.getMinWidth();\n        }\n        else {\n            return this.getMinHeight();\n        }\n    }\n    getAttrMaxWidth() {\n        return this.getAttr(\"maxWidth\");\n    }\n    getAttrMaxHeight() {\n        return this.getAttr(\"maxHeight\");\n    }\n    getMaxWidth() {\n        return this.calculatedMaxWidth;\n    }\n    getMaxHeight() {\n        return this.calculatedMaxHeight;\n    }\n    /** @internal */\n    getMaxSize(orientation) {\n        if (orientation === _Orientation__WEBPACK_IMPORTED_MODULE_4__.Orientation.HORZ) {\n            return this.getMaxWidth();\n        }\n        else {\n            return this.getMaxHeight();\n        }\n    }\n    /**\n     * Returns the config attribute that can be used to store node specific data that\n     * WILL be saved to the json. The config attribute should be changed via the action Actions.updateNodeAttributes rather\n     * than directly, for example:\n     * this.state.model.doAction(\n     *   FlexLayout.Actions.updateNodeAttributes(node.getId(), {config:myConfigObject}));\n     */\n    getConfig() {\n        return this.attributes.config;\n    }\n    isMaximized() {\n        return this.model.getMaximizedTabset(this.getWindowId()) === this;\n    }\n    isActive() {\n        return this.model.getActiveTabset(this.getWindowId()) === this;\n    }\n    isEnableDeleteWhenEmpty() {\n        return this.getAttr(\"enableDeleteWhenEmpty\");\n    }\n    isEnableDrop() {\n        return this.getAttr(\"enableDrop\");\n    }\n    isEnableTabWrap() {\n        return this.getAttr(\"enableTabWrap\");\n    }\n    isEnableDrag() {\n        return this.getAttr(\"enableDrag\");\n    }\n    isEnableDivide() {\n        return this.getAttr(\"enableDivide\");\n    }\n    isEnableMaximize() {\n        return this.getAttr(\"enableMaximize\");\n    }\n    isEnableClose() {\n        return this.getAttr(\"enableClose\");\n    }\n    isEnableSingleTabStretch() {\n        return this.getAttr(\"enableSingleTabStretch\");\n    }\n    isEnableTabStrip() {\n        return this.getAttr(\"enableTabStrip\");\n    }\n    isAutoSelectTab() {\n        return this.getAttr(\"autoSelectTab\");\n    }\n    getClassNameTabStrip() {\n        return this.getAttr(\"classNameTabStrip\");\n    }\n    getTabLocation() {\n        return this.getAttr(\"tabLocation\");\n    }\n    toJson() {\n        const json = {};\n        TabSetNode.attributeDefinitions.toJson(json, this.attributes);\n        json.children = this.children.map((child) => child.toJson());\n        if (this.isActive()) {\n            json.active = true;\n        }\n        if (this.isMaximized()) {\n            json.maximized = true;\n        }\n        return json;\n    }\n    /** @internal */\n    calcMinMaxSize() {\n        this.calculatedMinHeight = this.getAttrMinHeight();\n        this.calculatedMinWidth = this.getAttrMinWidth();\n        this.calculatedMaxHeight = this.getAttrMaxHeight();\n        this.calculatedMaxWidth = this.getAttrMaxWidth();\n        for (const child of this.children) {\n            const c = child;\n            this.calculatedMinWidth = Math.max(this.calculatedMinWidth, c.getMinWidth());\n            this.calculatedMinHeight = Math.max(this.calculatedMinHeight, c.getMinHeight());\n            this.calculatedMaxWidth = Math.min(this.calculatedMaxWidth, c.getMaxWidth());\n            this.calculatedMaxHeight = Math.min(this.calculatedMaxHeight, c.getMaxHeight());\n        }\n    }\n    /** @internal */\n    canMaximize() {\n        if (this.isEnableMaximize()) {\n            // always allow maximize toggle if already maximized\n            if (this.getModel().getMaximizedTabset(this.getWindowId()) === this) {\n                return true;\n            }\n            // only one tabset, so disable\n            if (this.getParent() === this.getModel().getRoot(this.getWindowId()) && this.getModel().getRoot(this.getWindowId()).getChildren().length === 1) {\n                return false;\n            }\n            return true;\n        }\n        return false;\n    }\n    /** @internal */\n    setContentRect(rect) {\n        this.contentRect = rect;\n    }\n    /** @internal */\n    getContentRect() {\n        return this.contentRect;\n    }\n    /** @internal */\n    setTabStripRect(rect) {\n        this.tabStripRect = rect;\n    }\n    /** @internal */\n    setWeight(weight) {\n        this.attributes.weight = weight;\n    }\n    /** @internal */\n    setSelected(index) {\n        this.attributes.selected = index;\n    }\n    getWindowId() {\n        return this.parent.getWindowId();\n    }\n    /** @internal */\n    canDrop(dragNode, x, y) {\n        let dropInfo;\n        if (dragNode === this) {\n            const dockLocation = _DockLocation__WEBPACK_IMPORTED_MODULE_2__.DockLocation.CENTER;\n            const outlineRect = this.tabStripRect;\n            dropInfo = new _DropInfo__WEBPACK_IMPORTED_MODULE_3__.DropInfo(this, outlineRect, dockLocation, -1, _Types__WEBPACK_IMPORTED_MODULE_6__.CLASSES.FLEXLAYOUT__OUTLINE_RECT);\n        }\n        else if (this.getWindowId() !== _Model__WEBPACK_IMPORTED_MODULE_9__.Model.MAIN_WINDOW_ID && !(0,_view_Utils__WEBPACK_IMPORTED_MODULE_7__.canDockToWindow)(dragNode)) {\n            return undefined;\n        }\n        else if (this.contentRect.contains(x, y)) {\n            let dockLocation = _DockLocation__WEBPACK_IMPORTED_MODULE_2__.DockLocation.CENTER;\n            if (this.model.getMaximizedTabset(this.parent.getWindowId()) === undefined) {\n                dockLocation = _DockLocation__WEBPACK_IMPORTED_MODULE_2__.DockLocation.getLocation(this.contentRect, x, y);\n            }\n            const outlineRect = dockLocation.getDockRect(this.rect);\n            dropInfo = new _DropInfo__WEBPACK_IMPORTED_MODULE_3__.DropInfo(this, outlineRect, dockLocation, -1, _Types__WEBPACK_IMPORTED_MODULE_6__.CLASSES.FLEXLAYOUT__OUTLINE_RECT);\n        }\n        else if (this.tabStripRect != null && this.tabStripRect.contains(x, y)) {\n            let r;\n            let yy;\n            let h;\n            if (this.children.length === 0) {\n                r = this.tabStripRect.clone();\n                yy = r.y + 3;\n                h = r.height - 4;\n                r.width = 2;\n            }\n            else {\n                let child = this.children[0];\n                r = child.getTabRect();\n                yy = r.y;\n                h = r.height;\n                let p = this.tabStripRect.x;\n                let childCenter = 0;\n                for (let i = 0; i < this.children.length; i++) {\n                    child = this.children[i];\n                    r = child.getTabRect();\n                    if (r.y !== yy) {\n                        yy = r.y;\n                        p = this.tabStripRect.x;\n                    }\n                    childCenter = r.x + r.width / 2;\n                    if (x >= p && x < childCenter && y > r.y && y < r.getBottom()) {\n                        const dockLocation = _DockLocation__WEBPACK_IMPORTED_MODULE_2__.DockLocation.CENTER;\n                        const outlineRect = new _Rect__WEBPACK_IMPORTED_MODULE_5__.Rect(r.x - 2, r.y, 3, r.height);\n                        dropInfo = new _DropInfo__WEBPACK_IMPORTED_MODULE_3__.DropInfo(this, outlineRect, dockLocation, i, _Types__WEBPACK_IMPORTED_MODULE_6__.CLASSES.FLEXLAYOUT__OUTLINE_RECT);\n                        break;\n                    }\n                    p = childCenter;\n                }\n            }\n            if (dropInfo == null) {\n                const dockLocation = _DockLocation__WEBPACK_IMPORTED_MODULE_2__.DockLocation.CENTER;\n                const outlineRect = new _Rect__WEBPACK_IMPORTED_MODULE_5__.Rect(r.getRight() - 2, yy, 3, h);\n                dropInfo = new _DropInfo__WEBPACK_IMPORTED_MODULE_3__.DropInfo(this, outlineRect, dockLocation, this.children.length, _Types__WEBPACK_IMPORTED_MODULE_6__.CLASSES.FLEXLAYOUT__OUTLINE_RECT);\n            }\n        }\n        if (!dragNode.canDockInto(dragNode, dropInfo)) {\n            return undefined;\n        }\n        return dropInfo;\n    }\n    /** @internal */\n    delete() {\n        this.parent.removeChild(this);\n    }\n    /** @internal */\n    remove(node) {\n        const removedIndex = this.removeChild(node);\n        this.model.tidy();\n        (0,_Utils__WEBPACK_IMPORTED_MODULE_13__.adjustSelectedIndex)(this, removedIndex);\n    }\n    /** @internal */\n    drop(dragNode, location, index, select) {\n        const dockLocation = location;\n        if (this === dragNode) {\n            // tabset drop into itself\n            return; // dock back to itself\n        }\n        let dragParent = dragNode.getParent();\n        let fromIndex = 0;\n        if (dragParent !== undefined) {\n            fromIndex = dragParent.removeChild(dragNode);\n            // if selected node in border is being docked into tabset then deselect border tabs\n            if (dragParent instanceof _BorderNode__WEBPACK_IMPORTED_MODULE_8__.BorderNode && dragParent.getSelected() === fromIndex) {\n                dragParent.setSelected(-1);\n            }\n            else {\n                (0,_Utils__WEBPACK_IMPORTED_MODULE_13__.adjustSelectedIndex)(dragParent, fromIndex);\n            }\n        }\n        // if dropping a tab back to same tabset and moving to forward position then reduce insertion index\n        if (dragNode instanceof _TabNode__WEBPACK_IMPORTED_MODULE_12__.TabNode && dragParent === this && fromIndex < index && index > 0) {\n            index--;\n        }\n        // simple_bundled dock to existing tabset\n        if (dockLocation === _DockLocation__WEBPACK_IMPORTED_MODULE_2__.DockLocation.CENTER) {\n            let insertPos = index;\n            if (insertPos === -1) {\n                insertPos = this.children.length;\n            }\n            if (dragNode instanceof _TabNode__WEBPACK_IMPORTED_MODULE_12__.TabNode) {\n                this.addChild(dragNode, insertPos);\n                if (select || (select !== false && this.isAutoSelectTab())) {\n                    this.setSelected(insertPos);\n                }\n                // console.log(\"added child at : \" + insertPos);\n            }\n            else if (dragNode instanceof _RowNode__WEBPACK_IMPORTED_MODULE_11__.RowNode) {\n                dragNode.forEachNode((child, level) => {\n                    if (child instanceof _TabNode__WEBPACK_IMPORTED_MODULE_12__.TabNode) {\n                        this.addChild(child, insertPos);\n                        // console.log(\"added child at : \" + insertPos);\n                        insertPos++;\n                    }\n                }, 0);\n            }\n            else {\n                for (let i = 0; i < dragNode.getChildren().length; i++) {\n                    const child = dragNode.getChildren()[i];\n                    this.addChild(child, insertPos);\n                    // console.log(\"added child at : \" + insertPos);\n                    insertPos++;\n                }\n                if (this.getSelected() === -1 && this.children.length > 0) {\n                    this.setSelected(0);\n                }\n            }\n            this.model.setActiveTabset(this, this.parent.getWindowId());\n        }\n        else {\n            let moveNode = dragNode;\n            if (dragNode instanceof _TabNode__WEBPACK_IMPORTED_MODULE_12__.TabNode) {\n                // create new tabset parent\n                // console.log(\"create a new tabset\");\n                const callback = this.model.getOnCreateTabSet();\n                moveNode = new TabSetNode(this.model, callback ? callback(dragNode) : {});\n                moveNode.addChild(dragNode);\n                // console.log(\"added child at end\");\n                dragParent = moveNode;\n            }\n            else if (dragNode instanceof _RowNode__WEBPACK_IMPORTED_MODULE_11__.RowNode) {\n                const parent = this.getParent();\n                // need to turn round if same orientation unless docking oposite direction\n                if (dragNode.getOrientation() === parent.getOrientation() &&\n                    (location.getOrientation() === parent.getOrientation() || location === _DockLocation__WEBPACK_IMPORTED_MODULE_2__.DockLocation.CENTER)) {\n                    const node = new _RowNode__WEBPACK_IMPORTED_MODULE_11__.RowNode(this.model, this.getWindowId(), {});\n                    node.addChild(dragNode);\n                    moveNode = node;\n                }\n            }\n            else {\n                moveNode = dragNode;\n            }\n            const parentRow = this.parent;\n            const pos = parentRow.getChildren().indexOf(this);\n            if (parentRow.getOrientation() === dockLocation.orientation) {\n                moveNode.setWeight(this.getWeight() / 2);\n                this.setWeight(this.getWeight() / 2);\n                // console.log(\"added child 50% size at: \" +  pos + dockLocation.indexPlus);\n                parentRow.addChild(moveNode, pos + dockLocation.indexPlus);\n            }\n            else {\n                // create a new row to host the new tabset (it will go in the opposite direction)\n                // console.log(\"create a new row\");\n                const newRow = new _RowNode__WEBPACK_IMPORTED_MODULE_11__.RowNode(this.model, this.getWindowId(), {});\n                newRow.setWeight(this.getWeight());\n                newRow.addChild(this);\n                this.setWeight(50);\n                moveNode.setWeight(50);\n                // console.log(\"added child 50% size at: \" +  dockLocation.indexPlus);\n                newRow.addChild(moveNode, dockLocation.indexPlus);\n                parentRow.removeChild(this);\n                parentRow.addChild(newRow, pos);\n            }\n            if (moveNode instanceof TabSetNode) {\n                this.model.setActiveTabset(moveNode, this.getWindowId());\n            }\n        }\n        this.model.tidy();\n    }\n    /** @internal */\n    updateAttrs(json) {\n        TabSetNode.attributeDefinitions.update(json, this.attributes);\n    }\n    /** @internal */\n    getAttributeDefinitions() {\n        return TabSetNode.attributeDefinitions;\n    }\n    /** @internal */\n    static getAttributeDefinitions() {\n        return TabSetNode.attributeDefinitions;\n    }\n    /** @internal */\n    static createAttributeDefinitions() {\n        const attributeDefinitions = new _AttributeDefinitions__WEBPACK_IMPORTED_MODULE_1__.AttributeDefinitions();\n        attributeDefinitions.add(\"type\", TabSetNode.TYPE, true).setType(_Attribute__WEBPACK_IMPORTED_MODULE_0__.Attribute.STRING).setFixed();\n        attributeDefinitions.add(\"id\", undefined).setType(_Attribute__WEBPACK_IMPORTED_MODULE_0__.Attribute.STRING).setDescription(`the unique id of the tab set, if left undefined a uuid will be assigned`);\n        attributeDefinitions.add(\"weight\", 100).setType(_Attribute__WEBPACK_IMPORTED_MODULE_0__.Attribute.NUMBER).setDescription(`relative weight for sizing of this tabset in parent row`);\n        attributeDefinitions.add(\"selected\", 0).setType(_Attribute__WEBPACK_IMPORTED_MODULE_0__.Attribute.NUMBER).setDescription(`index of selected/visible tab in tabset`);\n        attributeDefinitions.add(\"name\", undefined).setType(_Attribute__WEBPACK_IMPORTED_MODULE_0__.Attribute.STRING);\n        attributeDefinitions.add(\"config\", undefined).setType(\"any\").setDescription(`a place to hold json config used in your own code`);\n        attributeDefinitions.addInherited(\"enableDeleteWhenEmpty\", \"tabSetEnableDeleteWhenEmpty\").setDescription(`whether to delete this tabset when is has no tabs`);\n        attributeDefinitions.addInherited(\"enableDrop\", \"tabSetEnableDrop\").setDescription(`allow user to drag tabs into this tabset`);\n        attributeDefinitions.addInherited(\"enableDrag\", \"tabSetEnableDrag\").setDescription(`allow user to drag tabs out this tabset`);\n        attributeDefinitions.addInherited(\"enableDivide\", \"tabSetEnableDivide\").setDescription(`allow user to drag tabs to region of this tabset, splitting into new tabset`);\n        attributeDefinitions.addInherited(\"enableMaximize\", \"tabSetEnableMaximize\").setDescription(`allow user to maximize tabset to fill view via maximize button`);\n        attributeDefinitions.addInherited(\"enableClose\", \"tabSetEnableClose\").setDescription(`allow user to close tabset via a close button`);\n        attributeDefinitions.addInherited(\"enableSingleTabStretch\", \"tabSetEnableSingleTabStretch\").setDescription(`if the tabset has only a single tab then stretch the single tab to fill area and display in a header style`);\n        attributeDefinitions.addInherited(\"classNameTabStrip\", \"tabSetClassNameTabStrip\").setDescription(`a class name to apply to the tab strip`);\n        attributeDefinitions.addInherited(\"enableTabStrip\", \"tabSetEnableTabStrip\").setDescription(`enable tab strip and allow multiple tabs in this tabset`);\n        attributeDefinitions.addInherited(\"minWidth\", \"tabSetMinWidth\").setDescription(`minimum width (in px) for this tabset`);\n        attributeDefinitions.addInherited(\"minHeight\", \"tabSetMinHeight\").setDescription(`minimum height (in px) for this tabset`);\n        attributeDefinitions.addInherited(\"maxWidth\", \"tabSetMaxWidth\").setDescription(`maximum width (in px) for this tabset`);\n        attributeDefinitions.addInherited(\"maxHeight\", \"tabSetMaxHeight\").setDescription(`maximum height (in px) for this tabset`);\n        attributeDefinitions.addInherited(\"enableTabWrap\", \"tabSetEnableTabWrap\").setDescription(`show tabs in location top or bottom`);\n        attributeDefinitions.addInherited(\"tabLocation\", \"tabSetTabLocation\").setDescription(`the location of the tabs either top or bottom`);\n        attributeDefinitions.addInherited(\"autoSelectTab\", \"tabSetAutoSelectTab\").setType(_Attribute__WEBPACK_IMPORTED_MODULE_0__.Attribute.BOOLEAN).setDescription(`whether to select new/moved tabs in tabset`);\n        attributeDefinitions.addInherited(\"enableActiveIcon\", \"tabSetEnableActiveIcon\").setType(_Attribute__WEBPACK_IMPORTED_MODULE_0__.Attribute.BOOLEAN).setDescription(`whether the active icon (*) should be displayed when the tabset is active`);\n        return attributeDefinitions;\n    }\n}\nTabSetNode.TYPE = \"tabset\";\n/** @internal */\nTabSetNode.attributeDefinitions = TabSetNode.createAttributeDefinitions();\n\n\n//# sourceURL=webpack://FlexLayout/./src/model/TabSetNode.ts?");

/***/ }),

/***/ "./src/model/Utils.ts":
/*!****************************!*\
  !*** ./src/model/Utils.ts ***!
  \****************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   adjustSelectedIndex: () => (/* binding */ adjustSelectedIndex),\n/* harmony export */   adjustSelectedIndexAfterDock: () => (/* binding */ adjustSelectedIndexAfterDock),\n/* harmony export */   randomUUID: () => (/* binding */ randomUUID)\n/* harmony export */ });\n/* harmony import */ var _TabSetNode__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./TabSetNode */ \"./src/model/TabSetNode.ts\");\n/* harmony import */ var _BorderNode__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./BorderNode */ \"./src/model/BorderNode.ts\");\n\n\n/** @internal */\nfunction adjustSelectedIndexAfterDock(node) {\n    const parent = node.getParent();\n    if (parent !== null && (parent instanceof _TabSetNode__WEBPACK_IMPORTED_MODULE_0__.TabSetNode || parent instanceof _BorderNode__WEBPACK_IMPORTED_MODULE_1__.BorderNode)) {\n        const children = parent.getChildren();\n        for (let i = 0; i < children.length; i++) {\n            const child = children[i];\n            if (child === node) {\n                parent.setSelected(i);\n                return;\n            }\n        }\n    }\n}\n/** @internal */\nfunction adjustSelectedIndex(parent, removedIndex) {\n    // for the tabset/border being removed from set the selected index\n    if (parent !== undefined && (parent instanceof _TabSetNode__WEBPACK_IMPORTED_MODULE_0__.TabSetNode || parent instanceof _BorderNode__WEBPACK_IMPORTED_MODULE_1__.BorderNode)) {\n        const selectedIndex = parent.getSelected();\n        if (selectedIndex !== -1) {\n            if (removedIndex === selectedIndex && parent.getChildren().length > 0) {\n                if (removedIndex >= parent.getChildren().length) {\n                    // removed last tab; select new last tab\n                    parent.setSelected(parent.getChildren().length - 1);\n                }\n                else {\n                    // leave selected index as is, selecting next tab after this one\n                }\n            }\n            else if (removedIndex < selectedIndex) {\n                parent.setSelected(selectedIndex - 1);\n            }\n            else if (removedIndex > selectedIndex) {\n                // leave selected index as is\n            }\n            else {\n                parent.setSelected(-1);\n            }\n        }\n    }\n}\nfunction randomUUID() {\n    // @ts-ignore\n    return ([1e7] + -1e3 + -4e3 + -8e3 + -1e11).replace(/[018]/g, c => (c ^ crypto.getRandomValues(new Uint8Array(1))[0] & 15 >> c / 4).toString(16));\n}\n\n\n//# sourceURL=webpack://FlexLayout/./src/model/Utils.ts?");

/***/ }),

/***/ "./src/view/BorderButton.tsx":
/*!***********************************!*\
  !*** ./src/view/BorderButton.tsx ***!
  \***********************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   BorderButton: () => (/* binding */ BorderButton)\n/* harmony export */ });\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react */ \"react\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony import */ var _I18nLabel__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../I18nLabel */ \"./src/I18nLabel.ts\");\n/* harmony import */ var _model_Actions__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../model/Actions */ \"./src/model/Actions.ts\");\n/* harmony import */ var _model_ICloseType__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../model/ICloseType */ \"./src/model/ICloseType.ts\");\n/* harmony import */ var _Types__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../Types */ \"./src/Types.ts\");\n/* harmony import */ var _Utils__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./Utils */ \"./src/view/Utils.tsx\");\n\n\n\n\n\n\n/** @internal */\nconst BorderButton = (props) => {\n    const { layout, node, selected, border, icons, path } = props;\n    const selfRef = react__WEBPACK_IMPORTED_MODULE_0__.useRef(null);\n    const contentRef = react__WEBPACK_IMPORTED_MODULE_0__.useRef(null);\n    const onDragStart = (event) => {\n        event.stopPropagation();\n        layout.setDragNode(event.nativeEvent, node);\n    };\n    const onDragEnd = (event) => {\n        event.stopPropagation();\n        layout.clearDragMain();\n    };\n    const onAuxMouseClick = (event) => {\n        if ((0,_Utils__WEBPACK_IMPORTED_MODULE_5__.isAuxMouseEvent)(event)) {\n            layout.auxMouseClick(node, event);\n        }\n    };\n    const onContextMenu = (event) => {\n        layout.showContextMenu(node, event);\n    };\n    const onClick = () => {\n        layout.doAction(_model_Actions__WEBPACK_IMPORTED_MODULE_2__.Actions.selectTab(node.getId()));\n    };\n    // const onDoubleClick = (event: Event) => {\n    //     // if (node.isEnableRename()) {\n    //     //     onRename();\n    //     // }\n    // };\n    // const onRename = () => {\n    //     layout.setEditingTab(node);\n    //     layout.getCurrentDocument()!.body.addEventListener(\"pointerdown\", onEndEdit);\n    // };\n    const onEndEdit = (event) => {\n        if (event.target !== contentRef.current) {\n            layout.getCurrentDocument().body.removeEventListener(\"pointerdown\", onEndEdit);\n            layout.setEditingTab(undefined);\n        }\n    };\n    const isClosable = () => {\n        const closeType = node.getCloseType();\n        if (selected || closeType === _model_ICloseType__WEBPACK_IMPORTED_MODULE_3__.ICloseType.Always) {\n            return true;\n        }\n        if (closeType === _model_ICloseType__WEBPACK_IMPORTED_MODULE_3__.ICloseType.Visible) {\n            // not selected but x should be visible due to hover\n            if (window.matchMedia && window.matchMedia(\"(hover: hover) and (pointer: fine)\").matches) {\n                return true;\n            }\n        }\n        return false;\n    };\n    const onClose = (event) => {\n        if (isClosable()) {\n            layout.doAction(_model_Actions__WEBPACK_IMPORTED_MODULE_2__.Actions.deleteTab(node.getId()));\n        }\n        else {\n            onClick();\n        }\n    };\n    const onClosePointerDown = (event) => {\n        event.stopPropagation();\n    };\n    react__WEBPACK_IMPORTED_MODULE_0__.useLayoutEffect(() => {\n        node.setTabRect(layout.getBoundingClientRect(selfRef.current));\n        if (layout.getEditingTab() === node) {\n            contentRef.current.select();\n        }\n    });\n    const onTextBoxPointerDown = (event) => {\n        event.stopPropagation();\n    };\n    const onTextBoxKeyPress = (event) => {\n        if (event.code === 'Escape') {\n            // esc\n            layout.setEditingTab(undefined);\n        }\n        else if (event.code === 'Enter') {\n            // enter\n            layout.setEditingTab(undefined);\n            layout.doAction(_model_Actions__WEBPACK_IMPORTED_MODULE_2__.Actions.renameTab(node.getId(), event.target.value));\n        }\n    };\n    const cm = layout.getClassName;\n    let classNames = cm(_Types__WEBPACK_IMPORTED_MODULE_4__.CLASSES.FLEXLAYOUT__BORDER_BUTTON) + \" \" + cm(_Types__WEBPACK_IMPORTED_MODULE_4__.CLASSES.FLEXLAYOUT__BORDER_BUTTON_ + border);\n    if (selected) {\n        classNames += \" \" + cm(_Types__WEBPACK_IMPORTED_MODULE_4__.CLASSES.FLEXLAYOUT__BORDER_BUTTON__SELECTED);\n    }\n    else {\n        classNames += \" \" + cm(_Types__WEBPACK_IMPORTED_MODULE_4__.CLASSES.FLEXLAYOUT__BORDER_BUTTON__UNSELECTED);\n    }\n    if (node.getClassName() !== undefined) {\n        classNames += \" \" + node.getClassName();\n    }\n    let iconAngle = 0;\n    if (node.getModel().isEnableRotateBorderIcons() === false) {\n        if (border === \"left\") {\n            iconAngle = 90;\n        }\n        else if (border === \"right\") {\n            iconAngle = -90;\n        }\n    }\n    const renderState = (0,_Utils__WEBPACK_IMPORTED_MODULE_5__.getRenderStateEx)(layout, node, iconAngle);\n    let content = renderState.content ? (react__WEBPACK_IMPORTED_MODULE_0__.createElement(\"div\", { className: cm(_Types__WEBPACK_IMPORTED_MODULE_4__.CLASSES.FLEXLAYOUT__BORDER_BUTTON_CONTENT) }, renderState.content)) : null;\n    const leading = renderState.leading ? (react__WEBPACK_IMPORTED_MODULE_0__.createElement(\"div\", { className: cm(_Types__WEBPACK_IMPORTED_MODULE_4__.CLASSES.FLEXLAYOUT__BORDER_BUTTON_LEADING) }, renderState.leading)) : null;\n    if (layout.getEditingTab() === node) {\n        content = (react__WEBPACK_IMPORTED_MODULE_0__.createElement(\"input\", { ref: contentRef, className: cm(_Types__WEBPACK_IMPORTED_MODULE_4__.CLASSES.FLEXLAYOUT__TAB_BUTTON_TEXTBOX), \"data-layout-path\": path + \"/textbox\", type: \"text\", autoFocus: true, defaultValue: node.getName(), onKeyDown: onTextBoxKeyPress, onPointerDown: onTextBoxPointerDown }));\n    }\n    if (node.isEnableClose()) {\n        const closeTitle = layout.i18nName(_I18nLabel__WEBPACK_IMPORTED_MODULE_1__.I18nLabel.Close_Tab);\n        renderState.buttons.push(react__WEBPACK_IMPORTED_MODULE_0__.createElement(\"div\", { key: \"close\", \"data-layout-path\": path + \"/button/close\", title: closeTitle, className: cm(_Types__WEBPACK_IMPORTED_MODULE_4__.CLASSES.FLEXLAYOUT__BORDER_BUTTON_TRAILING), onPointerDown: onClosePointerDown, onClick: onClose }, (typeof icons.close === \"function\") ? icons.close(node) : icons.close));\n    }\n    return (react__WEBPACK_IMPORTED_MODULE_0__.createElement(\"div\", { ref: selfRef, \"data-layout-path\": path, className: classNames, onClick: onClick, onAuxClick: onAuxMouseClick, onContextMenu: onContextMenu, title: node.getHelpText(), draggable: true, onDragStart: onDragStart, onDragEnd: onDragEnd },\n        leading,\n        content,\n        renderState.buttons));\n};\n\n\n//# sourceURL=webpack://FlexLayout/./src/view/BorderButton.tsx?");

/***/ }),

/***/ "./src/view/BorderTab.tsx":
/*!********************************!*\
  !*** ./src/view/BorderTab.tsx ***!
  \********************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   BorderTab: () => (/* binding */ BorderTab)\n/* harmony export */ });\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react */ \"react\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony import */ var _Orientation__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../Orientation */ \"./src/Orientation.ts\");\n/* harmony import */ var _Rect__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../Rect */ \"./src/Rect.ts\");\n/* harmony import */ var _Splitter__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./Splitter */ \"./src/view/Splitter.tsx\");\n/* harmony import */ var _DockLocation__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../DockLocation */ \"./src/DockLocation.ts\");\n/* harmony import */ var _Types__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../Types */ \"./src/Types.ts\");\n\n\n\n\n\n\nfunction BorderTab(props) {\n    const { layout, border, show } = props;\n    const selfRef = react__WEBPACK_IMPORTED_MODULE_0__.useRef(null);\n    react__WEBPACK_IMPORTED_MODULE_0__.useLayoutEffect(() => {\n        const outerRect = layout.getBoundingClientRect(selfRef.current);\n        const contentRect = _Rect__WEBPACK_IMPORTED_MODULE_2__.Rect.getContentRect(selfRef.current).relativeTo(layout.getDomRect());\n        if (outerRect.width > 0) {\n            border.setOuterRect(outerRect);\n            if (!border.getContentRect().equals(contentRect)) {\n                border.setContentRect(contentRect);\n                layout.redrawInternal(\"border content rect\");\n            }\n        }\n    });\n    let horizontal = true;\n    const style = {};\n    if (border.getOrientation() === _Orientation__WEBPACK_IMPORTED_MODULE_1__.Orientation.HORZ) {\n        style.width = border.getSize();\n        style.minWidth = border.getMinSize();\n        style.maxWidth = border.getMaxSize();\n    }\n    else {\n        style.height = border.getSize();\n        style.minHeight = border.getMinSize();\n        style.maxHeight = border.getMaxSize();\n        horizontal = false;\n    }\n    style.display = show ? \"flex\" : \"none\";\n    const className = layout.getClassName(_Types__WEBPACK_IMPORTED_MODULE_5__.CLASSES.FLEXLAYOUT__BORDER_TAB_CONTENTS);\n    if (border.getLocation() === _DockLocation__WEBPACK_IMPORTED_MODULE_4__.DockLocation.LEFT || border.getLocation() === _DockLocation__WEBPACK_IMPORTED_MODULE_4__.DockLocation.TOP) {\n        return (react__WEBPACK_IMPORTED_MODULE_0__.createElement(react__WEBPACK_IMPORTED_MODULE_0__.Fragment, null,\n            react__WEBPACK_IMPORTED_MODULE_0__.createElement(\"div\", { ref: selfRef, style: style, className: className }),\n            show && react__WEBPACK_IMPORTED_MODULE_0__.createElement(_Splitter__WEBPACK_IMPORTED_MODULE_3__.Splitter, { layout: layout, node: border, index: 0, horizontal: horizontal })));\n    }\n    else {\n        return (react__WEBPACK_IMPORTED_MODULE_0__.createElement(react__WEBPACK_IMPORTED_MODULE_0__.Fragment, null,\n            show && react__WEBPACK_IMPORTED_MODULE_0__.createElement(_Splitter__WEBPACK_IMPORTED_MODULE_3__.Splitter, { layout: layout, node: border, index: 0, horizontal: horizontal }),\n            react__WEBPACK_IMPORTED_MODULE_0__.createElement(\"div\", { ref: selfRef, style: style, className: className })));\n    }\n}\n\n\n//# sourceURL=webpack://FlexLayout/./src/view/BorderTab.tsx?");

/***/ }),

/***/ "./src/view/BorderTabSet.tsx":
/*!***********************************!*\
  !*** ./src/view/BorderTabSet.tsx ***!
  \***********************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   BorderTabSet: () => (/* binding */ BorderTabSet)\n/* harmony export */ });\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react */ \"react\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony import */ var _DockLocation__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../DockLocation */ \"./src/DockLocation.ts\");\n/* harmony import */ var _BorderButton__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./BorderButton */ \"./src/view/BorderButton.tsx\");\n/* harmony import */ var _PopupMenu__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./PopupMenu */ \"./src/view/PopupMenu.tsx\");\n/* harmony import */ var _model_Actions__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../model/Actions */ \"./src/model/Actions.ts\");\n/* harmony import */ var _I18nLabel__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../I18nLabel */ \"./src/I18nLabel.ts\");\n/* harmony import */ var _TabOverflowHook__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./TabOverflowHook */ \"./src/view/TabOverflowHook.tsx\");\n/* harmony import */ var _Orientation__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ../Orientation */ \"./src/Orientation.ts\");\n/* harmony import */ var _Types__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ../Types */ \"./src/Types.ts\");\n/* harmony import */ var _Utils__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ./Utils */ \"./src/view/Utils.tsx\");\n/* harmony import */ var _Rect__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! ../Rect */ \"./src/Rect.ts\");\n\n\n\n\n\n\n\n\n\n\n\n/** @internal */\nconst BorderTabSet = (props) => {\n    const { border, layout, size } = props;\n    const toolbarRef = react__WEBPACK_IMPORTED_MODULE_0__.useRef(null);\n    const overflowbuttonRef = react__WEBPACK_IMPORTED_MODULE_0__.useRef(null);\n    const stickyButtonsRef = react__WEBPACK_IMPORTED_MODULE_0__.useRef(null);\n    const icons = layout.getIcons();\n    react__WEBPACK_IMPORTED_MODULE_0__.useLayoutEffect(() => {\n        border.setTabHeaderRect(_Rect__WEBPACK_IMPORTED_MODULE_10__.Rect.getBoundingClientRect(selfRef.current).relativeTo(layout.getDomRect()));\n    });\n    const { selfRef, position, userControlledLeft, hiddenTabs, onMouseWheel, tabsTruncated } = (0,_TabOverflowHook__WEBPACK_IMPORTED_MODULE_6__.useTabOverflow)(border, _Orientation__WEBPACK_IMPORTED_MODULE_7__.Orientation.flip(border.getOrientation()), toolbarRef, stickyButtonsRef);\n    const onAuxMouseClick = (event) => {\n        if ((0,_Utils__WEBPACK_IMPORTED_MODULE_9__.isAuxMouseEvent)(event)) {\n            layout.auxMouseClick(border, event);\n        }\n    };\n    const onContextMenu = (event) => {\n        layout.showContextMenu(border, event);\n    };\n    const onInterceptPointerDown = (event) => {\n        event.stopPropagation();\n    };\n    const onOverflowClick = (event) => {\n        const callback = layout.getShowOverflowMenu();\n        if (callback !== undefined) {\n            callback(border, event, hiddenTabs, onOverflowItemSelect);\n        }\n        else {\n            const element = overflowbuttonRef.current;\n            (0,_PopupMenu__WEBPACK_IMPORTED_MODULE_3__.showPopup)(element, hiddenTabs, onOverflowItemSelect, layout);\n        }\n        event.stopPropagation();\n    };\n    const onOverflowItemSelect = (item) => {\n        layout.doAction(_model_Actions__WEBPACK_IMPORTED_MODULE_4__.Actions.selectTab(item.node.getId()));\n        userControlledLeft.current = false;\n    };\n    const onPopoutTab = (event) => {\n        const selectedTabNode = border.getChildren()[border.getSelected()];\n        if (selectedTabNode !== undefined) {\n            layout.doAction(_model_Actions__WEBPACK_IMPORTED_MODULE_4__.Actions.popoutTab(selectedTabNode.getId()));\n        }\n        event.stopPropagation();\n    };\n    const cm = layout.getClassName;\n    const tabButtons = [];\n    const layoutTab = (i) => {\n        let isSelected = border.getSelected() === i;\n        let child = border.getChildren()[i];\n        tabButtons.push(react__WEBPACK_IMPORTED_MODULE_0__.createElement(_BorderButton__WEBPACK_IMPORTED_MODULE_2__.BorderButton, { layout: layout, border: border.getLocation().getName(), node: child, path: border.getPath() + \"/tb\" + i, key: child.getId(), selected: isSelected, icons: icons }));\n        if (i < border.getChildren().length - 1) {\n            tabButtons.push(react__WEBPACK_IMPORTED_MODULE_0__.createElement(\"div\", { key: \"divider\" + i, className: cm(_Types__WEBPACK_IMPORTED_MODULE_8__.CLASSES.FLEXLAYOUT__BORDER_TAB_DIVIDER) }));\n        }\n    };\n    for (let i = 0; i < border.getChildren().length; i++) {\n        layoutTab(i);\n    }\n    let borderClasses = cm(_Types__WEBPACK_IMPORTED_MODULE_8__.CLASSES.FLEXLAYOUT__BORDER) + \" \" + cm(_Types__WEBPACK_IMPORTED_MODULE_8__.CLASSES.FLEXLAYOUT__BORDER_ + border.getLocation().getName());\n    if (border.getClassName() !== undefined) {\n        borderClasses += \" \" + border.getClassName();\n    }\n    // allow customization of tabset right/bottom buttons\n    let buttons = [];\n    let stickyButtons = [];\n    const renderState = { buttons, stickyButtons: stickyButtons, overflowPosition: undefined };\n    layout.customizeTabSet(border, renderState);\n    buttons = renderState.buttons;\n    if (renderState.overflowPosition === undefined) {\n        renderState.overflowPosition = stickyButtons.length;\n    }\n    if (stickyButtons.length > 0) {\n        if (tabsTruncated) {\n            buttons = [...stickyButtons, ...buttons];\n        }\n        else {\n            tabButtons.push(react__WEBPACK_IMPORTED_MODULE_0__.createElement(\"div\", { ref: stickyButtonsRef, key: \"sticky_buttons_container\", onPointerDown: onInterceptPointerDown, onDragStart: (e) => { e.preventDefault(); }, className: cm(_Types__WEBPACK_IMPORTED_MODULE_8__.CLASSES.FLEXLAYOUT__TAB_TOOLBAR_STICKY_BUTTONS_CONTAINER) }, stickyButtons));\n        }\n    }\n    if (hiddenTabs.length > 0) {\n        const overflowTitle = layout.i18nName(_I18nLabel__WEBPACK_IMPORTED_MODULE_5__.I18nLabel.Overflow_Menu_Tooltip);\n        let overflowContent;\n        if (typeof icons.more === \"function\") {\n            overflowContent = icons.more(border, hiddenTabs);\n        }\n        else {\n            overflowContent = (react__WEBPACK_IMPORTED_MODULE_0__.createElement(react__WEBPACK_IMPORTED_MODULE_0__.Fragment, null,\n                icons.more,\n                react__WEBPACK_IMPORTED_MODULE_0__.createElement(\"div\", { className: cm(_Types__WEBPACK_IMPORTED_MODULE_8__.CLASSES.FLEXLAYOUT__TAB_BUTTON_OVERFLOW_COUNT) }, hiddenTabs.length)));\n        }\n        buttons.splice(Math.min(renderState.overflowPosition, buttons.length), 0, react__WEBPACK_IMPORTED_MODULE_0__.createElement(\"button\", { key: \"overflowbutton\", ref: overflowbuttonRef, className: cm(_Types__WEBPACK_IMPORTED_MODULE_8__.CLASSES.FLEXLAYOUT__BORDER_TOOLBAR_BUTTON) + \" \" + cm(_Types__WEBPACK_IMPORTED_MODULE_8__.CLASSES.FLEXLAYOUT__BORDER_TOOLBAR_BUTTON_OVERFLOW) + \" \" + cm(_Types__WEBPACK_IMPORTED_MODULE_8__.CLASSES.FLEXLAYOUT__BORDER_TOOLBAR_BUTTON_OVERFLOW_ + border.getLocation().getName()), title: overflowTitle, onClick: onOverflowClick, onPointerDown: onInterceptPointerDown }, overflowContent));\n    }\n    const selectedIndex = border.getSelected();\n    if (selectedIndex !== -1) {\n        const selectedTabNode = border.getChildren()[selectedIndex];\n        if (selectedTabNode !== undefined && layout.isSupportsPopout() && selectedTabNode.isEnablePopout()) {\n            const popoutTitle = layout.i18nName(_I18nLabel__WEBPACK_IMPORTED_MODULE_5__.I18nLabel.Popout_Tab);\n            buttons.push(react__WEBPACK_IMPORTED_MODULE_0__.createElement(\"button\", { key: \"popout\", title: popoutTitle, className: cm(_Types__WEBPACK_IMPORTED_MODULE_8__.CLASSES.FLEXLAYOUT__BORDER_TOOLBAR_BUTTON) + \" \" + cm(_Types__WEBPACK_IMPORTED_MODULE_8__.CLASSES.FLEXLAYOUT__BORDER_TOOLBAR_BUTTON_FLOAT), onClick: onPopoutTab, onPointerDown: onInterceptPointerDown }, (typeof icons.popout === \"function\") ? icons.popout(selectedTabNode) : icons.popout));\n        }\n    }\n    const toolbar = (react__WEBPACK_IMPORTED_MODULE_0__.createElement(\"div\", { key: \"toolbar\", ref: toolbarRef, className: cm(_Types__WEBPACK_IMPORTED_MODULE_8__.CLASSES.FLEXLAYOUT__BORDER_TOOLBAR) + \" \" + cm(_Types__WEBPACK_IMPORTED_MODULE_8__.CLASSES.FLEXLAYOUT__BORDER_TOOLBAR_ + border.getLocation().getName()) }, buttons));\n    let innerStyle = {};\n    let outerStyle = {};\n    const borderHeight = size - 1;\n    if (border.getLocation() === _DockLocation__WEBPACK_IMPORTED_MODULE_1__.DockLocation.LEFT) {\n        innerStyle = { right: \"100%\", top: position };\n        outerStyle = { width: borderHeight };\n    }\n    else if (border.getLocation() === _DockLocation__WEBPACK_IMPORTED_MODULE_1__.DockLocation.RIGHT) {\n        innerStyle = { left: \"100%\", top: position };\n        outerStyle = { width: borderHeight };\n    }\n    else {\n        innerStyle = { left: position };\n        outerStyle = { height: borderHeight };\n    }\n    return (react__WEBPACK_IMPORTED_MODULE_0__.createElement(\"div\", { ref: selfRef, style: {\n            display: \"flex\",\n            flexDirection: (border.getOrientation() === _Orientation__WEBPACK_IMPORTED_MODULE_7__.Orientation.VERT ? \"row\" : \"column\")\n        }, className: borderClasses, \"data-layout-path\": border.getPath(), onClick: onAuxMouseClick, onAuxClick: onAuxMouseClick, onContextMenu: onContextMenu, onWheel: onMouseWheel },\n        react__WEBPACK_IMPORTED_MODULE_0__.createElement(\"div\", { style: outerStyle, className: cm(_Types__WEBPACK_IMPORTED_MODULE_8__.CLASSES.FLEXLAYOUT__BORDER_INNER) + \" \" + cm(_Types__WEBPACK_IMPORTED_MODULE_8__.CLASSES.FLEXLAYOUT__BORDER_INNER_ + border.getLocation().getName()) },\n            react__WEBPACK_IMPORTED_MODULE_0__.createElement(\"div\", { style: innerStyle, className: cm(_Types__WEBPACK_IMPORTED_MODULE_8__.CLASSES.FLEXLAYOUT__BORDER_INNER_TAB_CONTAINER) + \" \" + cm(_Types__WEBPACK_IMPORTED_MODULE_8__.CLASSES.FLEXLAYOUT__BORDER_INNER_TAB_CONTAINER_ + border.getLocation().getName()) }, tabButtons)),\n        toolbar));\n};\n\n\n//# sourceURL=webpack://FlexLayout/./src/view/BorderTabSet.tsx?");

/***/ }),

/***/ "./src/view/DragContainer.tsx":
/*!************************************!*\
  !*** ./src/view/DragContainer.tsx ***!
  \************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   DragContainer: () => (/* binding */ DragContainer)\n/* harmony export */ });\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react */ \"react\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony import */ var _Types__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../Types */ \"./src/Types.ts\");\n/* harmony import */ var _TabButtonStamp__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./TabButtonStamp */ \"./src/view/TabButtonStamp.tsx\");\n\n\n\n/** @internal */\nconst DragContainer = (props) => {\n    const { layout, node } = props;\n    const selfRef = react__WEBPACK_IMPORTED_MODULE_0__.useRef(null);\n    react__WEBPACK_IMPORTED_MODULE_0__.useEffect(() => {\n        node.setTabStamp(selfRef.current);\n    }, [node, selfRef.current]);\n    const cm = layout.getClassName;\n    let classNames = cm(_Types__WEBPACK_IMPORTED_MODULE_1__.CLASSES.FLEXLAYOUT__DRAG_RECT);\n    return (react__WEBPACK_IMPORTED_MODULE_0__.createElement(\"div\", { ref: selfRef, className: classNames },\n        react__WEBPACK_IMPORTED_MODULE_0__.createElement(_TabButtonStamp__WEBPACK_IMPORTED_MODULE_2__.TabButtonStamp, { key: node.getId(), layout: layout, node: node })));\n};\n\n\n//# sourceURL=webpack://FlexLayout/./src/view/DragContainer.tsx?");

/***/ }),

/***/ "./src/view/ErrorBoundary.tsx":
/*!************************************!*\
  !*** ./src/view/ErrorBoundary.tsx ***!
  \************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   ErrorBoundary: () => (/* binding */ ErrorBoundary)\n/* harmony export */ });\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react */ \"react\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony import */ var _Types__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../Types */ \"./src/Types.ts\");\n\n\n/** @internal */\nclass ErrorBoundary extends react__WEBPACK_IMPORTED_MODULE_0__.Component {\n    constructor(props) {\n        super(props);\n        this.state = { hasError: false };\n    }\n    static getDerivedStateFromError(error) {\n        return { hasError: true };\n    }\n    componentDidCatch(error, errorInfo) {\n        console.debug(error);\n        console.debug(errorInfo);\n    }\n    render() {\n        if (this.state.hasError) {\n            return (react__WEBPACK_IMPORTED_MODULE_0__.createElement(\"div\", { className: _Types__WEBPACK_IMPORTED_MODULE_1__.CLASSES.FLEXLAYOUT__ERROR_BOUNDARY_CONTAINER },\n                react__WEBPACK_IMPORTED_MODULE_0__.createElement(\"div\", { className: _Types__WEBPACK_IMPORTED_MODULE_1__.CLASSES.FLEXLAYOUT__ERROR_BOUNDARY_CONTENT }, this.props.message)));\n        }\n        return this.props.children;\n    }\n}\n\n\n//# sourceURL=webpack://FlexLayout/./src/view/ErrorBoundary.tsx?");

/***/ }),

/***/ "./src/view/Icons.tsx":
/*!****************************!*\
  !*** ./src/view/Icons.tsx ***!
  \****************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   AsterickIcon: () => (/* binding */ AsterickIcon),\n/* harmony export */   CloseIcon: () => (/* binding */ CloseIcon),\n/* harmony export */   EdgeIcon: () => (/* binding */ EdgeIcon),\n/* harmony export */   MaximizeIcon: () => (/* binding */ MaximizeIcon),\n/* harmony export */   OverflowIcon: () => (/* binding */ OverflowIcon),\n/* harmony export */   PopoutIcon: () => (/* binding */ PopoutIcon),\n/* harmony export */   RestoreIcon: () => (/* binding */ RestoreIcon)\n/* harmony export */ });\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react */ \"react\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_0__);\n\nconst style = { width: \"1em\", height: \"1em\", display: \"flex\", alignItems: \"center\" };\nconst CloseIcon = () => {\n    return (react__WEBPACK_IMPORTED_MODULE_0__.createElement(\"svg\", { xmlns: \"http://www.w3.org/2000/svg\", style: style, viewBox: \"0 0 24 24\" },\n        react__WEBPACK_IMPORTED_MODULE_0__.createElement(\"path\", { fill: \"none\", d: \"M0 0h24v24H0z\" }),\n        react__WEBPACK_IMPORTED_MODULE_0__.createElement(\"path\", { stroke: \"var(--color-icon)\", fill: \"var(--color-icon)\", d: \"M19 6.41L17.59 5 12 10.59 6.41 5 5 6.41 10.59 12 5 17.59 6.41 19 12 13.41 17.59 19 19 17.59 13.41 12z\" })));\n};\nconst MaximizeIcon = () => {\n    return (react__WEBPACK_IMPORTED_MODULE_0__.createElement(\"svg\", { xmlns: \"http://www.w3.org/2000/svg\", style: style, viewBox: \"0 0 24 24\", fill: \"var(--color-icon)\" },\n        react__WEBPACK_IMPORTED_MODULE_0__.createElement(\"path\", { d: \"M0 0h24v24H0z\", fill: \"none\" }),\n        react__WEBPACK_IMPORTED_MODULE_0__.createElement(\"path\", { stroke: \"var(--color-icon)\", d: \"M7 14H5v5h5v-2H7v-3zm-2-4h2V7h3V5H5v5zm12 7h-3v2h5v-5h-2v3zM14 5v2h3v3h2V5h-5z\" })));\n};\nconst OverflowIcon = () => {\n    return (react__WEBPACK_IMPORTED_MODULE_0__.createElement(\"svg\", { xmlns: \"http://www.w3.org/2000/svg\", style: style, viewBox: \"0 0 24 24\", fill: \"var(--color-icon)\" },\n        react__WEBPACK_IMPORTED_MODULE_0__.createElement(\"path\", { d: \"M0 0h24v24H0z\", fill: \"none\" }),\n        react__WEBPACK_IMPORTED_MODULE_0__.createElement(\"path\", { stroke: \"var(--color-icon)\", d: \"M7 10l5 5 5-5z\" })));\n};\nconst EdgeIcon = () => {\n    return (react__WEBPACK_IMPORTED_MODULE_0__.createElement(\"svg\", { xmlns: \"http://www.w3.org/2000/svg\", style: { display: \"block\", width: 10, height: 10 }, preserveAspectRatio: \"none\", viewBox: \"0 0 100 100\" },\n        react__WEBPACK_IMPORTED_MODULE_0__.createElement(\"path\", { fill: \"var(--color-edge-icon)\", stroke: \"var(--color-edge-icon)\", d: \"M10 30 L90 30 l-40 40 Z\" })));\n};\nconst PopoutIcon = () => {\n    return (\n    // <svg xmlns=\"http://www.w3.org/2000/svg\"  style={style}  viewBox=\"0 0 24 24\" fill=\"var(--color-icon)\"><path d=\"M0 0h24v24H0z\" fill=\"none\"/><path stroke=\"var(--color-icon)\" d=\"M9 5v2h6.59L4 18.59 5.41 20 17 8.41V15h2V5z\"/></svg>\n    // <svg xmlns=\"http://www.w3.org/2000/svg\" style={style} fill=\"none\" viewBox=\"0 0 24 24\" stroke=\"var(--color-icon)\" stroke-width=\"2\">\n    //     <path stroke-linecap=\"round\" stroke-linejoin=\"round\" d=\"M10 6H6a2 2 0 00-2 2v10a2 2 0 002 2h10a2 2 0 002-2v-4M14 4h6m0 0v6m0-6L10 14\" />\n    // </svg>\n    react__WEBPACK_IMPORTED_MODULE_0__.createElement(\"svg\", { xmlns: \"http://www.w3.org/2000/svg\", style: style, viewBox: \"0 0 20 20\", fill: \"var(--color-icon)\" },\n        react__WEBPACK_IMPORTED_MODULE_0__.createElement(\"path\", { d: \"M11 3a1 1 0 100 2h2.586l-6.293 6.293a1 1 0 101.414 1.414L15 6.414V9a1 1 0 102 0V4a1 1 0 00-1-1h-5z\" }),\n        react__WEBPACK_IMPORTED_MODULE_0__.createElement(\"path\", { d: \"M5 5a2 2 0 00-2 2v8a2 2 0 002 2h8a2 2 0 002-2v-3a1 1 0 10-2 0v3H5V7h3a1 1 0 000-2H5z\" })));\n};\nconst RestoreIcon = () => {\n    return (react__WEBPACK_IMPORTED_MODULE_0__.createElement(\"svg\", { xmlns: \"http://www.w3.org/2000/svg\", style: style, viewBox: \"0 0 24 24\", fill: \"var(--color-icon)\" },\n        react__WEBPACK_IMPORTED_MODULE_0__.createElement(\"path\", { d: \"M0 0h24v24H0z\", fill: \"none\" }),\n        react__WEBPACK_IMPORTED_MODULE_0__.createElement(\"path\", { stroke: \"var(--color-icon)\", d: \"M5 16h3v3h2v-5H5v2zm3-8H5v2h5V5H8v3zm6 11h2v-3h3v-2h-5v5zm2-11V5h-2v5h5V8h-3z\" })));\n};\nconst AsterickIcon = () => {\n    return (react__WEBPACK_IMPORTED_MODULE_0__.createElement(\"svg\", { xmlns: \"http://www.w3.org/2000/svg\", style: style, height: \"24px\", viewBox: \"0 -960 960 960\", width: \"24px\" },\n        react__WEBPACK_IMPORTED_MODULE_0__.createElement(\"path\", { fill: \"var(--color-icon)\", stroke: \"var(--color-icon)\", d: \"M440-120v-264L254-197l-57-57 187-186H120v-80h264L197-706l57-57 186 187v-264h80v264l186-187 57 57-187 186h264v80H576l187 186-57 57-186-187v264h-80Z\" })));\n};\n\n\n//# sourceURL=webpack://FlexLayout/./src/view/Icons.tsx?");

/***/ }),

/***/ "./src/view/Layout.tsx":
/*!*****************************!*\
  !*** ./src/view/Layout.tsx ***!
  \*****************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   Layout: () => (/* binding */ Layout),\n/* harmony export */   LayoutInternal: () => (/* binding */ LayoutInternal)\n/* harmony export */ });\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react */ \"react\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony import */ var react_dom__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! react-dom */ \"react-dom\");\n/* harmony import */ var react_dom__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(react_dom__WEBPACK_IMPORTED_MODULE_1__);\n/* harmony import */ var react_dom_client__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! react-dom/client */ \"./node_modules/.pnpm/react-dom@18.3.1_react@18.3.1/node_modules/react-dom/client.js\");\n/* harmony import */ var _DockLocation__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../DockLocation */ \"./src/DockLocation.ts\");\n/* harmony import */ var _I18nLabel__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../I18nLabel */ \"./src/I18nLabel.ts\");\n/* harmony import */ var _Orientation__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../Orientation */ \"./src/Orientation.ts\");\n/* harmony import */ var _Rect__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ../Rect */ \"./src/Rect.ts\");\n/* harmony import */ var _Types__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ../Types */ \"./src/Types.ts\");\n/* harmony import */ var _model_Actions__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ../model/Actions */ \"./src/model/Actions.ts\");\n/* harmony import */ var _model_BorderNode__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ../model/BorderNode */ \"./src/model/BorderNode.ts\");\n/* harmony import */ var _model_Model__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! ../model/Model */ \"./src/model/Model.ts\");\n/* harmony import */ var _model_TabNode__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(/*! ../model/TabNode */ \"./src/model/TabNode.ts\");\n/* harmony import */ var _model_TabSetNode__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__(/*! ../model/TabSetNode */ \"./src/model/TabSetNode.ts\");\n/* harmony import */ var _BorderTab__WEBPACK_IMPORTED_MODULE_13__ = __webpack_require__(/*! ./BorderTab */ \"./src/view/BorderTab.tsx\");\n/* harmony import */ var _BorderTabSet__WEBPACK_IMPORTED_MODULE_14__ = __webpack_require__(/*! ./BorderTabSet */ \"./src/view/BorderTabSet.tsx\");\n/* harmony import */ var _DragContainer__WEBPACK_IMPORTED_MODULE_15__ = __webpack_require__(/*! ./DragContainer */ \"./src/view/DragContainer.tsx\");\n/* harmony import */ var _ErrorBoundary__WEBPACK_IMPORTED_MODULE_16__ = __webpack_require__(/*! ./ErrorBoundary */ \"./src/view/ErrorBoundary.tsx\");\n/* harmony import */ var _PopoutWindow__WEBPACK_IMPORTED_MODULE_17__ = __webpack_require__(/*! ./PopoutWindow */ \"./src/view/PopoutWindow.tsx\");\n/* harmony import */ var _Icons__WEBPACK_IMPORTED_MODULE_18__ = __webpack_require__(/*! ./Icons */ \"./src/view/Icons.tsx\");\n/* harmony import */ var _Overlay__WEBPACK_IMPORTED_MODULE_19__ = __webpack_require__(/*! ./Overlay */ \"./src/view/Overlay.tsx\");\n/* harmony import */ var _Row__WEBPACK_IMPORTED_MODULE_20__ = __webpack_require__(/*! ./Row */ \"./src/view/Row.tsx\");\n/* harmony import */ var _Tab__WEBPACK_IMPORTED_MODULE_21__ = __webpack_require__(/*! ./Tab */ \"./src/view/Tab.tsx\");\n/* harmony import */ var _Utils__WEBPACK_IMPORTED_MODULE_22__ = __webpack_require__(/*! ./Utils */ \"./src/view/Utils.tsx\");\n/* harmony import */ var _TabButtonStamp__WEBPACK_IMPORTED_MODULE_23__ = __webpack_require__(/*! ./TabButtonStamp */ \"./src/view/TabButtonStamp.tsx\");\n/* harmony import */ var _SizeTracker__WEBPACK_IMPORTED_MODULE_24__ = __webpack_require__(/*! ./SizeTracker */ \"./src/view/SizeTracker.tsx\");\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n/**\n * A React component that hosts a multi-tabbed layout\n */\nclass Layout extends react__WEBPACK_IMPORTED_MODULE_0__.Component {\n    /** @internal */\n    constructor(props) {\n        super(props);\n        this.selfRef = react__WEBPACK_IMPORTED_MODULE_0__.createRef();\n        this.revision = 0;\n    }\n    /** re-render the layout */\n    redraw() {\n        this.selfRef.current.redraw(\"parent \" + this.revision);\n    }\n    /**\n     * Adds a new tab to the given tabset\n     * @param tabsetId the id of the tabset where the new tab will be added\n     * @param json the json for the new tab node\n     * @returns the added tab node or undefined\n     */\n    addTabToTabSet(tabsetId, json) {\n        return this.selfRef.current.addTabToTabSet(tabsetId, json);\n    }\n    /**\n     * Adds a new tab by dragging an item to the drop location, must be called from within an HTML\n     * drag start handler. You can use the setDragComponent() method to set the drag image before calling this\n     * method.\n     * @param event the drag start event\n     * @param json the json for the new tab node\n     * @param onDrop a callback to call when the drag is complete\n     */\n    addTabWithDragAndDrop(event, json, onDrop) {\n        this.selfRef.current.addTabWithDragAndDrop(event, json, onDrop);\n    }\n    /**\n     * Move a tab/tabset using drag and drop, must be called from within an HTML\n     * drag start handler\n     * @param event the drag start event\n     * @param node the tab or tabset to drag\n     */\n    moveTabWithDragAndDrop(event, node) {\n        this.selfRef.current.moveTabWithDragAndDrop(event, node);\n    }\n    /**\n     * Adds a new tab to the active tabset (if there is one)\n     * @param json the json for the new tab node\n     * @returns the added tab node or undefined\n     */\n    addTabToActiveTabSet(json) {\n        return this.selfRef.current.addTabToActiveTabSet(json);\n    }\n    /**\n     * Sets the drag image from a react component for a drag event\n     * @param event the drag event\n     * @param component the react component to be used for the drag image\n     * @param x the x position of the drag cursor on the image\n     * @param y the x position of the drag cursor on the image\n     */\n    setDragComponent(event, component, x, y) {\n        this.selfRef.current.setDragComponent(event, component, x, y);\n    }\n    /** Get the root div element of the layout */\n    getRootDiv() {\n        return this.selfRef.current.getRootDiv();\n    }\n    /** @internal */\n    render() {\n        return (react__WEBPACK_IMPORTED_MODULE_0__.createElement(LayoutInternal, Object.assign({ ref: this.selfRef }, this.props, { renderRevision: this.revision++ })));\n    }\n}\n/** @internal */\nclass LayoutInternal extends react__WEBPACK_IMPORTED_MODULE_0__.Component {\n    // private renderCount: any;\n    constructor(props) {\n        super(props);\n        this.moveableElementMap = new Map();\n        this.dragEnterCount = 0;\n        this.dragging = false;\n        this.updateLayoutMetrics = () => {\n            if (this.findBorderBarSizeRef.current) {\n                const borderBarSize = this.findBorderBarSizeRef.current.getBoundingClientRect().height;\n                if (borderBarSize !== this.state.calculatedBorderBarSize) {\n                    this.setState({ calculatedBorderBarSize: borderBarSize });\n                }\n            }\n        };\n        this.onModelChange = (action) => {\n            this.redrawInternal(\"model change\");\n            if (this.props.onModelChange) {\n                this.props.onModelChange(this.props.model, action);\n            }\n        };\n        this.updateRect = () => {\n            const rect = this.getDomRect();\n            if (!rect.equals(this.state.rect) && rect.width !== 0 && rect.height !== 0) {\n                // console.log(\"updateRect\", rect.floor());\n                this.setState({ rect });\n                if (this.windowId !== _model_Model__WEBPACK_IMPORTED_MODULE_10__.Model.MAIN_WINDOW_ID) {\n                    this.redrawInternal(\"rect updated\");\n                }\n            }\n        };\n        this.getClassName = (defaultClassName) => {\n            if (this.props.classNameMapper === undefined) {\n                return defaultClassName;\n            }\n            else {\n                return this.props.classNameMapper(defaultClassName);\n            }\n        };\n        this.onCloseWindow = (windowLayout) => {\n            this.doAction(_model_Actions__WEBPACK_IMPORTED_MODULE_8__.Actions.closeWindow(windowLayout.windowId));\n        };\n        this.onSetWindow = (windowLayout, window) => {\n        };\n        this.showControlInPortal = (control, element) => {\n            const portal = (0,react_dom__WEBPACK_IMPORTED_MODULE_1__.createPortal)(control, element);\n            this.setState({ portal });\n        };\n        this.hideControlInPortal = () => {\n            this.setState({ portal: undefined });\n        };\n        this.getIcons = () => {\n            return this.icons;\n        };\n        this.setDragNode = (event, node) => {\n            LayoutInternal.dragState = new DragState(this.mainLayout, DragSource.Internal, node, undefined, undefined);\n            // Note: can only set (very) limited types on android! so cannot set json\n            // Note: must set text/plain for android to allow drag, \n            //  so just set a simple message indicating its a flexlayout drag (this is not used anywhere else)\n            event.dataTransfer.setData('text/plain', \"--flexlayout--\");\n            event.dataTransfer.effectAllowed = \"copyMove\";\n            event.dataTransfer.dropEffect = \"move\";\n            this.dragEnterCount = 0;\n            if (node instanceof _model_TabSetNode__WEBPACK_IMPORTED_MODULE_12__.TabSetNode) {\n                let rendered = false;\n                let content = this.i18nName(_I18nLabel__WEBPACK_IMPORTED_MODULE_4__.I18nLabel.Move_Tabset);\n                if (node.getChildren().length > 0) {\n                    content = this.i18nName(_I18nLabel__WEBPACK_IMPORTED_MODULE_4__.I18nLabel.Move_Tabs).replace(\"?\", String(node.getChildren().length));\n                }\n                if (this.props.onRenderDragRect) {\n                    const dragComponent = this.props.onRenderDragRect(content, node, undefined);\n                    if (dragComponent) {\n                        this.setDragComponent(event, dragComponent, 10, 10);\n                        rendered = true;\n                    }\n                }\n                if (!rendered) {\n                    this.setDragComponent(event, content, 10, 10);\n                }\n            }\n            else {\n                const element = event.target;\n                const rect = element.getBoundingClientRect();\n                const offsetX = event.clientX - rect.left;\n                const offsetY = event.clientY - rect.top;\n                const parentNode = node === null || node === void 0 ? void 0 : node.getParent();\n                const isInVerticalBorder = parentNode instanceof _model_BorderNode__WEBPACK_IMPORTED_MODULE_9__.BorderNode && parentNode.getOrientation() === _Orientation__WEBPACK_IMPORTED_MODULE_5__.Orientation.HORZ;\n                const x = isInVerticalBorder ? 10 : offsetX;\n                const y = isInVerticalBorder ? 10 : offsetY;\n                let rendered = false;\n                if (this.props.onRenderDragRect) {\n                    const content = react__WEBPACK_IMPORTED_MODULE_0__.createElement(_TabButtonStamp__WEBPACK_IMPORTED_MODULE_23__.TabButtonStamp, { key: node.getId(), layout: this, node: node });\n                    const dragComponent = this.props.onRenderDragRect(content, node, undefined);\n                    if (dragComponent) {\n                        this.setDragComponent(event, dragComponent, x, y);\n                        rendered = true;\n                    }\n                }\n                if (!rendered) {\n                    if ((0,_Utils__WEBPACK_IMPORTED_MODULE_22__.isSafari)()) { // safari doesnt render the offscreen tabstamps\n                        this.setDragComponent(event, react__WEBPACK_IMPORTED_MODULE_0__.createElement(_TabButtonStamp__WEBPACK_IMPORTED_MODULE_23__.TabButtonStamp, { node: node, layout: this }), x, y);\n                    }\n                    else {\n                        event.dataTransfer.setDragImage(node.getTabStamp(), x, y);\n                    }\n                }\n            }\n        };\n        this.onDragEnterRaw = (event) => {\n            this.dragEnterCount++;\n            if (this.dragEnterCount === 1) {\n                this.onDragEnter(event);\n            }\n        };\n        this.onDragLeaveRaw = (event) => {\n            this.dragEnterCount--;\n            if (this.dragEnterCount === 0) {\n                this.onDragLeave(event);\n            }\n        };\n        this.onDragEnter = (event) => {\n            // console.log(\"onDragEnter\", this.windowId, this.dragEnterCount);\n            var _a;\n            if (!LayoutInternal.dragState && this.props.onExternalDrag) { // not internal dragging\n                const externalDrag = this.props.onExternalDrag(event);\n                if (externalDrag) {\n                    const tempNode = _model_TabNode__WEBPACK_IMPORTED_MODULE_11__.TabNode.fromJson(externalDrag.json, this.props.model, false);\n                    LayoutInternal.dragState = new DragState(this.mainLayout, DragSource.External, tempNode, externalDrag.json, externalDrag.onDrop);\n                }\n            }\n            if (LayoutInternal.dragState) {\n                if (this.windowId !== _model_Model__WEBPACK_IMPORTED_MODULE_10__.Model.MAIN_WINDOW_ID && LayoutInternal.dragState.mainLayout === this.mainLayout) {\n                    LayoutInternal.dragState.mainLayout.setDraggingOverWindow(true);\n                }\n                if (LayoutInternal.dragState.mainLayout !== this.mainLayout) {\n                    return; // drag not by this layout or its popouts\n                }\n                event.preventDefault();\n                this.dropInfo = undefined;\n                const rootdiv = this.selfRef.current;\n                this.outlineDiv = this.currentDocument.createElement(\"div\");\n                this.outlineDiv.className = this.getClassName(_Types__WEBPACK_IMPORTED_MODULE_7__.CLASSES.FLEXLAYOUT__OUTLINE_RECT);\n                this.outlineDiv.style.visibility = \"hidden\";\n                const speed = this.props.model.getAttribute(\"tabDragSpeed\");\n                this.outlineDiv.style.transition = `top ${speed}s, left ${speed}s, width ${speed}s, height ${speed}s`;\n                rootdiv.appendChild(this.outlineDiv);\n                this.dragging = true;\n                this.showOverlay(true);\n                // add edge indicators\n                if (!this.isDraggingOverWindow && this.props.model.getMaximizedTabset(this.windowId) === undefined) {\n                    this.setState({ showEdges: this.props.model.isEnableEdgeDock() });\n                }\n                const clientRect = (_a = this.selfRef.current) === null || _a === void 0 ? void 0 : _a.getBoundingClientRect();\n                const r = new _Rect__WEBPACK_IMPORTED_MODULE_6__.Rect(event.clientX - (clientRect.left), event.clientY - (clientRect.top), 1, 1);\n                r.positionElement(this.outlineDiv);\n            }\n        };\n        this.onDragOver = (event) => {\n            var _a, _b, _c;\n            if (this.dragging && !this.isDraggingOverWindow) {\n                // console.log(\"onDragOver\");\n                event.preventDefault();\n                const clientRect = (_a = this.selfRef.current) === null || _a === void 0 ? void 0 : _a.getBoundingClientRect();\n                const pos = {\n                    x: event.clientX - ((_b = clientRect === null || clientRect === void 0 ? void 0 : clientRect.left) !== null && _b !== void 0 ? _b : 0),\n                    y: event.clientY - ((_c = clientRect === null || clientRect === void 0 ? void 0 : clientRect.top) !== null && _c !== void 0 ? _c : 0),\n                };\n                this.checkForBorderToShow(pos.x, pos.y);\n                let dropInfo = this.props.model.findDropTargetNode(this.windowId, LayoutInternal.dragState.dragNode, pos.x, pos.y);\n                if (dropInfo) {\n                    this.dropInfo = dropInfo;\n                    if (this.outlineDiv) {\n                        this.outlineDiv.className = this.getClassName(dropInfo.className);\n                        dropInfo.rect.positionElement(this.outlineDiv);\n                        this.outlineDiv.style.visibility = \"visible\";\n                    }\n                }\n            }\n        };\n        this.onDragLeave = (event) => {\n            // console.log(\"onDragLeave\", this.windowId, this.dragging);\n            if (this.dragging) {\n                if (this.windowId !== _model_Model__WEBPACK_IMPORTED_MODULE_10__.Model.MAIN_WINDOW_ID) {\n                    LayoutInternal.dragState.mainLayout.setDraggingOverWindow(false);\n                }\n                this.clearDragLocal();\n            }\n        };\n        this.onDrop = (event) => {\n            // console.log(\"ondrop\", this.windowId, this.dragging, Layout.dragState);\n            if (this.dragging) {\n                event.preventDefault();\n                const dragState = LayoutInternal.dragState;\n                if (this.dropInfo) {\n                    if (dragState.dragJson !== undefined) {\n                        const newNode = this.doAction(_model_Actions__WEBPACK_IMPORTED_MODULE_8__.Actions.addNode(dragState.dragJson, this.dropInfo.node.getId(), this.dropInfo.location, this.dropInfo.index));\n                        if (dragState.fnNewNodeDropped !== undefined) {\n                            dragState.fnNewNodeDropped(newNode, event);\n                        }\n                    }\n                    else if (dragState.dragNode !== undefined) {\n                        this.doAction(_model_Actions__WEBPACK_IMPORTED_MODULE_8__.Actions.moveNode(dragState.dragNode.getId(), this.dropInfo.node.getId(), this.dropInfo.location, this.dropInfo.index));\n                    }\n                }\n                this.mainLayout.clearDragMain();\n            }\n            this.dragEnterCount = 0; // must set to zero here ref sublayouts\n        };\n        this.orderedIds = [];\n        this.selfRef = react__WEBPACK_IMPORTED_MODULE_0__.createRef();\n        this.moveablesRef = react__WEBPACK_IMPORTED_MODULE_0__.createRef();\n        this.mainRef = react__WEBPACK_IMPORTED_MODULE_0__.createRef();\n        this.findBorderBarSizeRef = react__WEBPACK_IMPORTED_MODULE_0__.createRef();\n        this.supportsPopout = props.supportsPopout !== undefined ? props.supportsPopout : defaultSupportsPopout;\n        this.popoutURL = props.popoutURL ? props.popoutURL : \"popout.html\";\n        this.icons = Object.assign(Object.assign({}, defaultIcons), props.icons);\n        this.windowId = props.windowId ? props.windowId : _model_Model__WEBPACK_IMPORTED_MODULE_10__.Model.MAIN_WINDOW_ID;\n        this.mainLayout = this.props.mainLayout ? this.props.mainLayout : this;\n        this.isDraggingOverWindow = false;\n        this.layoutWindow = this.props.model.getwindowsMap().get(this.windowId);\n        this.layoutWindow.layout = this;\n        this.popoutWindowName = this.props.popoutWindowName || \"Popout Window\";\n        // this.renderCount = 0;\n        this.state = {\n            rect: _Rect__WEBPACK_IMPORTED_MODULE_6__.Rect.empty(),\n            editingTab: undefined,\n            showEdges: false,\n            showOverlay: false,\n            calculatedBorderBarSize: 29,\n            layoutRevision: 0,\n            forceRevision: 0,\n            showHiddenBorder: _DockLocation__WEBPACK_IMPORTED_MODULE_3__.DockLocation.CENTER\n        };\n        this.isMainWindow = this.windowId === _model_Model__WEBPACK_IMPORTED_MODULE_10__.Model.MAIN_WINDOW_ID;\n    }\n    componentDidMount() {\n        this.updateRect();\n        this.currentDocument = this.selfRef.current.ownerDocument;\n        this.currentWindow = this.currentDocument.defaultView;\n        this.layoutWindow.window = this.currentWindow;\n        this.layoutWindow.toScreenRectFunction = (r) => this.getScreenRect(r);\n        this.resizeObserver = new ResizeObserver(entries => {\n            requestAnimationFrame(() => {\n                this.updateRect();\n            });\n        });\n        if (this.selfRef.current) {\n            this.resizeObserver.observe(this.selfRef.current);\n        }\n        if (this.isMainWindow) {\n            this.props.model.addChangeListener(this.onModelChange);\n            this.updateLayoutMetrics();\n        }\n        else {\n            // since resizeObserver doesn't always work as expected when observing element in another document\n            this.currentWindow.addEventListener(\"resize\", () => {\n                this.updateRect();\n            });\n            const sourceElement = this.props.mainLayout.getRootDiv();\n            const targetElement = this.selfRef.current;\n            (0,_Utils__WEBPACK_IMPORTED_MODULE_22__.copyInlineStyles)(sourceElement, targetElement);\n            this.styleObserver = new MutationObserver(() => {\n                const changed = (0,_Utils__WEBPACK_IMPORTED_MODULE_22__.copyInlineStyles)(sourceElement, targetElement);\n                if (changed) {\n                    this.redraw(\"mutation observer\");\n                }\n            });\n            // Observe changes to the source element's style attribute\n            this.styleObserver.observe(sourceElement, { attributeFilter: ['style'] });\n        }\n        // allow tabs to overlay when hidden\n        document.addEventListener('visibilitychange', () => {\n            for (const [_, layoutWindow] of this.props.model.getwindowsMap()) {\n                const layout = layoutWindow.layout;\n                if (layout) {\n                    this.redraw(\"visibility change\");\n                }\n            }\n        });\n    }\n    componentDidUpdate() {\n        this.currentDocument = this.selfRef.current.ownerDocument;\n        this.currentWindow = this.currentDocument.defaultView;\n        if (this.isMainWindow) {\n            if (this.props.model !== this.previousModel) {\n                if (this.previousModel !== undefined) {\n                    this.previousModel.removeChangeListener(this.onModelChange); // stop listening to old model\n                }\n                this.props.model.getwindowsMap().get(this.windowId).layout = this;\n                this.props.model.addChangeListener(this.onModelChange);\n                this.layoutWindow = this.props.model.getwindowsMap().get(this.windowId);\n                this.layoutWindow.layout = this;\n                this.layoutWindow.toScreenRectFunction = (r) => this.getScreenRect(r);\n                this.previousModel = this.props.model;\n                this.tidyMoveablesMap();\n            }\n            this.updateLayoutMetrics();\n        }\n    }\n    componentWillUnmount() {\n        var _a, _b;\n        if (this.selfRef.current) {\n            (_a = this.resizeObserver) === null || _a === void 0 ? void 0 : _a.unobserve(this.selfRef.current);\n        }\n        (_b = this.styleObserver) === null || _b === void 0 ? void 0 : _b.disconnect();\n    }\n    render() {\n        // console.log(\"render\", this.windowId, this.state.revision, this.renderCount++);\n        // first render will be used to find the size (via selfRef)\n        if (!this.selfRef.current) {\n            return (react__WEBPACK_IMPORTED_MODULE_0__.createElement(\"div\", { ref: this.selfRef, className: this.getClassName(_Types__WEBPACK_IMPORTED_MODULE_7__.CLASSES.FLEXLAYOUT__LAYOUT) },\n                react__WEBPACK_IMPORTED_MODULE_0__.createElement(\"div\", { ref: this.moveablesRef, key: \"__moveables__\", className: this.getClassName(_Types__WEBPACK_IMPORTED_MODULE_7__.CLASSES.FLEXLAYOUT__LAYOUT_MOVEABLES) }),\n                this.renderMetricsElements()));\n        }\n        const model = this.props.model;\n        model.getRoot(this.windowId).calcMinMaxSize();\n        model.getRoot(this.windowId).setPaths(\"\");\n        model.getBorderSet().setPaths();\n        const inner = this.renderLayout();\n        const outer = this.renderBorders(inner);\n        const tabs = this.renderTabs();\n        const reorderedTabs = this.reorderComponents(tabs, this.orderedIds);\n        let floatingWindows = null;\n        let tabMoveables = null;\n        let tabStamps = null;\n        let metricElements = null;\n        if (this.isMainWindow) {\n            floatingWindows = this.renderWindows();\n            metricElements = this.renderMetricsElements();\n            tabMoveables = this.renderTabMoveables();\n            tabStamps = react__WEBPACK_IMPORTED_MODULE_0__.createElement(\"div\", { key: \"__tabStamps__\", className: this.getClassName(_Types__WEBPACK_IMPORTED_MODULE_7__.CLASSES.FLEXLAYOUT__LAYOUT_TAB_STAMPS) }, this.renderTabStamps());\n        }\n        return (react__WEBPACK_IMPORTED_MODULE_0__.createElement(\"div\", { ref: this.selfRef, className: this.getClassName(_Types__WEBPACK_IMPORTED_MODULE_7__.CLASSES.FLEXLAYOUT__LAYOUT), onDragEnter: this.onDragEnterRaw, onDragLeave: this.onDragLeaveRaw, onDragOver: this.onDragOver, onDrop: this.onDrop },\n            react__WEBPACK_IMPORTED_MODULE_0__.createElement(\"div\", { ref: this.moveablesRef, key: \"__moveables__\", className: this.getClassName(_Types__WEBPACK_IMPORTED_MODULE_7__.CLASSES.FLEXLAYOUT__LAYOUT_MOVEABLES) }),\n            metricElements,\n            react__WEBPACK_IMPORTED_MODULE_0__.createElement(_Overlay__WEBPACK_IMPORTED_MODULE_19__.Overlay, { key: \"__overlay__\", layout: this, show: this.state.showOverlay }),\n            outer,\n            reorderedTabs,\n            tabMoveables,\n            tabStamps,\n            this.state.portal,\n            floatingWindows));\n    }\n    renderBorders(inner) {\n        const classMain = this.getClassName(_Types__WEBPACK_IMPORTED_MODULE_7__.CLASSES.FLEXLAYOUT__LAYOUT_MAIN);\n        const borders = this.props.model.getBorderSet().getBorderMap();\n        if (this.isMainWindow && borders.size > 0) {\n            inner = (react__WEBPACK_IMPORTED_MODULE_0__.createElement(\"div\", { className: classMain, ref: this.mainRef }, inner));\n            const borderSetComponents = new Map();\n            const borderSetContentComponents = new Map();\n            for (const [_, location] of _DockLocation__WEBPACK_IMPORTED_MODULE_3__.DockLocation.values) {\n                const border = borders.get(location);\n                const showBorder = border && (!border.isAutoHide() ||\n                    (border.isAutoHide() && (border.getChildren().length > 0 || this.state.showHiddenBorder === location)));\n                if (showBorder) {\n                    borderSetComponents.set(location, react__WEBPACK_IMPORTED_MODULE_0__.createElement(_BorderTabSet__WEBPACK_IMPORTED_MODULE_14__.BorderTabSet, { layout: this, border: border, size: this.state.calculatedBorderBarSize }));\n                    borderSetContentComponents.set(location, react__WEBPACK_IMPORTED_MODULE_0__.createElement(_BorderTab__WEBPACK_IMPORTED_MODULE_13__.BorderTab, { layout: this, border: border, show: border.getSelected() !== -1 }));\n                }\n            }\n            const classBorderOuter = this.getClassName(_Types__WEBPACK_IMPORTED_MODULE_7__.CLASSES.FLEXLAYOUT__LAYOUT_BORDER_CONTAINER);\n            const classBorderInner = this.getClassName(_Types__WEBPACK_IMPORTED_MODULE_7__.CLASSES.FLEXLAYOUT__LAYOUT_BORDER_CONTAINER_INNER);\n            if (this.props.model.getBorderSet().getLayoutHorizontal()) {\n                const innerWithBorderTabs = (react__WEBPACK_IMPORTED_MODULE_0__.createElement(\"div\", { className: classBorderInner, style: { flexDirection: \"column\" } },\n                    borderSetContentComponents.get(_DockLocation__WEBPACK_IMPORTED_MODULE_3__.DockLocation.TOP),\n                    react__WEBPACK_IMPORTED_MODULE_0__.createElement(\"div\", { className: classBorderInner, style: { flexDirection: \"row\" } },\n                        borderSetContentComponents.get(_DockLocation__WEBPACK_IMPORTED_MODULE_3__.DockLocation.LEFT),\n                        inner,\n                        borderSetContentComponents.get(_DockLocation__WEBPACK_IMPORTED_MODULE_3__.DockLocation.RIGHT)),\n                    borderSetContentComponents.get(_DockLocation__WEBPACK_IMPORTED_MODULE_3__.DockLocation.BOTTOM)));\n                return (react__WEBPACK_IMPORTED_MODULE_0__.createElement(\"div\", { className: classBorderOuter, style: { flexDirection: \"column\" } },\n                    borderSetComponents.get(_DockLocation__WEBPACK_IMPORTED_MODULE_3__.DockLocation.TOP),\n                    react__WEBPACK_IMPORTED_MODULE_0__.createElement(\"div\", { className: classBorderInner, style: { flexDirection: \"row\" } },\n                        borderSetComponents.get(_DockLocation__WEBPACK_IMPORTED_MODULE_3__.DockLocation.LEFT),\n                        innerWithBorderTabs,\n                        borderSetComponents.get(_DockLocation__WEBPACK_IMPORTED_MODULE_3__.DockLocation.RIGHT)),\n                    borderSetComponents.get(_DockLocation__WEBPACK_IMPORTED_MODULE_3__.DockLocation.BOTTOM)));\n            }\n            else {\n                const innerWithBorderTabs = (react__WEBPACK_IMPORTED_MODULE_0__.createElement(\"div\", { className: classBorderInner, style: { flexDirection: \"row\" } },\n                    borderSetContentComponents.get(_DockLocation__WEBPACK_IMPORTED_MODULE_3__.DockLocation.LEFT),\n                    react__WEBPACK_IMPORTED_MODULE_0__.createElement(\"div\", { className: classBorderInner, style: { flexDirection: \"column\" } },\n                        borderSetContentComponents.get(_DockLocation__WEBPACK_IMPORTED_MODULE_3__.DockLocation.TOP),\n                        inner,\n                        borderSetContentComponents.get(_DockLocation__WEBPACK_IMPORTED_MODULE_3__.DockLocation.BOTTOM)),\n                    borderSetContentComponents.get(_DockLocation__WEBPACK_IMPORTED_MODULE_3__.DockLocation.RIGHT)));\n                return (react__WEBPACK_IMPORTED_MODULE_0__.createElement(\"div\", { className: classBorderOuter, style: { flexDirection: \"row\" } },\n                    borderSetComponents.get(_DockLocation__WEBPACK_IMPORTED_MODULE_3__.DockLocation.LEFT),\n                    react__WEBPACK_IMPORTED_MODULE_0__.createElement(\"div\", { className: classBorderInner, style: { flexDirection: \"column\" } },\n                        borderSetComponents.get(_DockLocation__WEBPACK_IMPORTED_MODULE_3__.DockLocation.TOP),\n                        innerWithBorderTabs,\n                        borderSetComponents.get(_DockLocation__WEBPACK_IMPORTED_MODULE_3__.DockLocation.BOTTOM)),\n                    borderSetComponents.get(_DockLocation__WEBPACK_IMPORTED_MODULE_3__.DockLocation.RIGHT)));\n            }\n        }\n        else { // no borders\n            return (react__WEBPACK_IMPORTED_MODULE_0__.createElement(\"div\", { className: classMain, ref: this.mainRef, style: { position: \"absolute\", top: 0, left: 0, bottom: 0, right: 0, display: \"flex\" } }, inner));\n        }\n    }\n    renderLayout() {\n        return (react__WEBPACK_IMPORTED_MODULE_0__.createElement(react__WEBPACK_IMPORTED_MODULE_0__.Fragment, null,\n            react__WEBPACK_IMPORTED_MODULE_0__.createElement(_Row__WEBPACK_IMPORTED_MODULE_20__.Row, { key: \"__row__\", layout: this, node: this.props.model.getRoot(this.windowId) }),\n            this.renderEdgeIndicators()));\n    }\n    renderEdgeIndicators() {\n        const edges = [];\n        const arrowIcon = this.icons.edgeArrow;\n        if (this.state.showEdges) {\n            const r = this.props.model.getRoot(this.windowId).getRect();\n            const length = edgeRectLength;\n            const width = edgeRectWidth;\n            const offset = edgeRectLength / 2;\n            const className = this.getClassName(_Types__WEBPACK_IMPORTED_MODULE_7__.CLASSES.FLEXLAYOUT__EDGE_RECT);\n            const radius = 50;\n            edges.push(react__WEBPACK_IMPORTED_MODULE_0__.createElement(\"div\", { key: \"North\", style: { top: 0, left: r.width / 2 - offset, width: length, height: width, borderBottomLeftRadius: radius, borderBottomRightRadius: radius }, className: className + \" \" + this.getClassName(_Types__WEBPACK_IMPORTED_MODULE_7__.CLASSES.FLEXLAYOUT__EDGE_RECT_TOP) },\n                react__WEBPACK_IMPORTED_MODULE_0__.createElement(\"div\", { style: { transform: \"rotate(180deg)\" } }, arrowIcon)));\n            edges.push(react__WEBPACK_IMPORTED_MODULE_0__.createElement(\"div\", { key: \"West\", style: { top: r.height / 2 - offset, left: 0, width: width, height: length, borderTopRightRadius: radius, borderBottomRightRadius: radius }, className: className + \" \" + this.getClassName(_Types__WEBPACK_IMPORTED_MODULE_7__.CLASSES.FLEXLAYOUT__EDGE_RECT_LEFT) },\n                react__WEBPACK_IMPORTED_MODULE_0__.createElement(\"div\", { style: { transform: \"rotate(90deg)\" } }, arrowIcon)));\n            edges.push(react__WEBPACK_IMPORTED_MODULE_0__.createElement(\"div\", { key: \"South\", style: { top: r.height - width, left: r.width / 2 - offset, width: length, height: width, borderTopLeftRadius: radius, borderTopRightRadius: radius }, className: className + \" \" + this.getClassName(_Types__WEBPACK_IMPORTED_MODULE_7__.CLASSES.FLEXLAYOUT__EDGE_RECT_BOTTOM) },\n                react__WEBPACK_IMPORTED_MODULE_0__.createElement(\"div\", null, arrowIcon)));\n            edges.push(react__WEBPACK_IMPORTED_MODULE_0__.createElement(\"div\", { key: \"East\", style: { top: r.height / 2 - offset, left: r.width - width, width: width, height: length, borderTopLeftRadius: radius, borderBottomLeftRadius: radius }, className: className + \" \" + this.getClassName(_Types__WEBPACK_IMPORTED_MODULE_7__.CLASSES.FLEXLAYOUT__EDGE_RECT_RIGHT) },\n                react__WEBPACK_IMPORTED_MODULE_0__.createElement(\"div\", { style: { transform: \"rotate(-90deg)\" } }, arrowIcon)));\n        }\n        return edges;\n    }\n    renderWindows() {\n        const floatingWindows = [];\n        if (this.supportsPopout) {\n            const windows = this.props.model.getwindowsMap();\n            let i = 1;\n            for (const [windowId, layoutWindow] of windows) {\n                if (windowId !== _model_Model__WEBPACK_IMPORTED_MODULE_10__.Model.MAIN_WINDOW_ID) {\n                    floatingWindows.push(react__WEBPACK_IMPORTED_MODULE_0__.createElement(_PopoutWindow__WEBPACK_IMPORTED_MODULE_17__.PopoutWindow, { key: windowId, layout: this, title: this.popoutWindowName + \" \" + i, layoutWindow: layoutWindow, url: this.popoutURL + \"?id=\" + windowId, onSetWindow: this.onSetWindow, onCloseWindow: this.onCloseWindow },\n                        react__WEBPACK_IMPORTED_MODULE_0__.createElement(LayoutInternal, Object.assign({}, this.props, { windowId: windowId, mainLayout: this }))));\n                    i++;\n                }\n            }\n        }\n        return floatingWindows;\n    }\n    renderTabMoveables() {\n        const tabMoveables = [];\n        this.props.model.visitNodes((node) => {\n            if (node instanceof _model_TabNode__WEBPACK_IMPORTED_MODULE_11__.TabNode) {\n                const child = node;\n                const element = this.getMoveableElement(child.getId());\n                child.setMoveableElement(element);\n                const selected = child.isSelected();\n                const rect = child.getParent().getContentRect();\n                // only render first time if size >0\n                const renderTab = child.isRendered() ||\n                    ((selected || !child.isEnableRenderOnDemand()) && (rect.width > 0 && rect.height > 0));\n                if (renderTab) {\n                    //  console.log(\"rendertab\", child.getName(), this.props.renderRevision);\n                    const key = child.getId() + (child.isEnableWindowReMount() ? child.getWindowId() : \"\");\n                    tabMoveables.push((0,react_dom__WEBPACK_IMPORTED_MODULE_1__.createPortal)(react__WEBPACK_IMPORTED_MODULE_0__.createElement(_SizeTracker__WEBPACK_IMPORTED_MODULE_24__.SizeTracker, { rect: rect, selected: child.isSelected(), forceRevision: this.state.forceRevision, tabsRevision: this.props.renderRevision, key: key },\n                        react__WEBPACK_IMPORTED_MODULE_0__.createElement(_ErrorBoundary__WEBPACK_IMPORTED_MODULE_16__.ErrorBoundary, { message: this.i18nName(_I18nLabel__WEBPACK_IMPORTED_MODULE_4__.I18nLabel.Error_rendering_component) }, this.props.factory(child))), element, key));\n                    child.setRendered(renderTab);\n                }\n            }\n        });\n        return tabMoveables;\n    }\n    renderTabStamps() {\n        const tabStamps = [];\n        this.props.model.visitNodes((node) => {\n            if (node instanceof _model_TabNode__WEBPACK_IMPORTED_MODULE_11__.TabNode) {\n                const child = node;\n                // what the tab should look like when dragged (since images need to have been loaded before drag image can be taken)\n                tabStamps.push(react__WEBPACK_IMPORTED_MODULE_0__.createElement(_DragContainer__WEBPACK_IMPORTED_MODULE_15__.DragContainer, { key: child.getId(), layout: this, node: child }));\n            }\n        });\n        return tabStamps;\n    }\n    renderTabs() {\n        const tabs = new Map();\n        this.props.model.visitWindowNodes(this.windowId, (node) => {\n            if (node instanceof _model_TabNode__WEBPACK_IMPORTED_MODULE_11__.TabNode) {\n                const child = node;\n                const selected = child.isSelected();\n                const path = child.getPath();\n                const renderTab = child.isRendered() || selected || !child.isEnableRenderOnDemand();\n                if (renderTab) {\n                    // const rect = (child.getParent() as BorderNode | TabSetNode).getContentRect();\n                    // const key = child.getId();\n                    tabs.set(child.getId(), (\n                    // <SizeTracker rect={rect} forceRevision={this.state.forceRevision} key={key}>\n                    react__WEBPACK_IMPORTED_MODULE_0__.createElement(_Tab__WEBPACK_IMPORTED_MODULE_21__.Tab, { key: child.getId(), layout: this, path: path, node: child, selected: selected })\n                    // </SizeTracker>\n                    ));\n                }\n            }\n        });\n        return tabs;\n    }\n    renderMetricsElements() {\n        return (react__WEBPACK_IMPORTED_MODULE_0__.createElement(\"div\", { key: \"findBorderBarSize\", ref: this.findBorderBarSizeRef, className: this.getClassName(_Types__WEBPACK_IMPORTED_MODULE_7__.CLASSES.FLEXLAYOUT__BORDER_SIZER) }, \"FindBorderBarSize\"));\n    }\n    checkForBorderToShow(x, y) {\n        const r = this.getBoundingClientRect(this.mainRef.current);\n        const c = r.getCenter();\n        const margin = edgeRectWidth;\n        const offset = edgeRectLength / 2;\n        let overEdge = false;\n        if (this.props.model.isEnableEdgeDock() && this.state.showHiddenBorder === _DockLocation__WEBPACK_IMPORTED_MODULE_3__.DockLocation.CENTER) {\n            if ((y > c.y - offset && y < c.y + offset) ||\n                (x > c.x - offset && x < c.x + offset)) {\n                overEdge = true;\n            }\n        }\n        let location = _DockLocation__WEBPACK_IMPORTED_MODULE_3__.DockLocation.CENTER;\n        if (!overEdge) {\n            if (x <= r.x + margin) {\n                location = _DockLocation__WEBPACK_IMPORTED_MODULE_3__.DockLocation.LEFT;\n            }\n            else if (x >= r.getRight() - margin) {\n                location = _DockLocation__WEBPACK_IMPORTED_MODULE_3__.DockLocation.RIGHT;\n            }\n            else if (y <= r.y + margin) {\n                location = _DockLocation__WEBPACK_IMPORTED_MODULE_3__.DockLocation.TOP;\n            }\n            else if (y >= r.getBottom() - margin) {\n                location = _DockLocation__WEBPACK_IMPORTED_MODULE_3__.DockLocation.BOTTOM;\n            }\n        }\n        if (location !== this.state.showHiddenBorder) {\n            this.setState({ showHiddenBorder: location });\n        }\n    }\n    tidyMoveablesMap() {\n        // console.log(\"tidyMoveablesMap\");\n        const tabs = new Map();\n        this.props.model.visitNodes((node, _) => {\n            if (node instanceof _model_TabNode__WEBPACK_IMPORTED_MODULE_11__.TabNode) {\n                tabs.set(node.getId(), node);\n            }\n        });\n        for (const [nodeId, element] of this.moveableElementMap) {\n            if (!tabs.has(nodeId)) {\n                // console.log(\"delete\", nodeId);\n                element.remove(); // remove from dom\n                this.moveableElementMap.delete(nodeId); // remove map entry \n            }\n        }\n    }\n    reorderComponents(components, ids) {\n        const nextIds = [];\n        const nextIdsSet = new Set();\n        let reordered = [];\n        // Keep any previous tabs in the same DOM order as before, removing any that have been deleted\n        for (const id of ids) {\n            if (components.get(id)) {\n                nextIds.push(id);\n                nextIdsSet.add(id);\n            }\n        }\n        ids.splice(0, ids.length, ...nextIds);\n        // Add tabs that have been added to the DOM\n        for (const [id, _] of components) {\n            if (!nextIdsSet.has(id)) {\n                ids.push(id);\n            }\n        }\n        reordered = ids.map((id) => {\n            return components.get(id);\n        });\n        return reordered;\n    }\n    redraw(type) {\n        // console.log(\"redraw\", this.windowId, type);\n        this.mainLayout.setState((state, props) => { return { forceRevision: state.forceRevision + 1 }; });\n    }\n    redrawInternal(type) {\n        // console.log(\"redrawInternal\", this.windowId, type);\n        this.mainLayout.setState((state, props) => { return { layoutRevision: state.layoutRevision + 1 }; });\n    }\n    doAction(action) {\n        if (this.props.onAction !== undefined) {\n            const outcome = this.props.onAction(action);\n            if (outcome !== undefined) {\n                return this.props.model.doAction(outcome);\n            }\n            return undefined;\n        }\n        else {\n            return this.props.model.doAction(action);\n        }\n    }\n    getBoundingClientRect(div) {\n        const layoutRect = this.getDomRect();\n        if (layoutRect) {\n            return _Rect__WEBPACK_IMPORTED_MODULE_6__.Rect.getBoundingClientRect(div).relativeTo(layoutRect);\n        }\n        return _Rect__WEBPACK_IMPORTED_MODULE_6__.Rect.empty();\n    }\n    getMoveableContainer() {\n        return this.moveablesRef.current;\n    }\n    getMoveableElement(id) {\n        let moveableElement = this.moveableElementMap.get(id);\n        if (moveableElement === undefined) {\n            moveableElement = document.createElement(\"div\");\n            this.moveablesRef.current.appendChild(moveableElement);\n            moveableElement.className = _Types__WEBPACK_IMPORTED_MODULE_7__.CLASSES.FLEXLAYOUT__TAB_MOVEABLE;\n            this.moveableElementMap.set(id, moveableElement);\n        }\n        return moveableElement;\n    }\n    getMainLayout() {\n        return this.mainLayout;\n    }\n    getCurrentDocument() {\n        return this.currentDocument;\n    }\n    getDomRect() {\n        if (this.selfRef.current) {\n            return _Rect__WEBPACK_IMPORTED_MODULE_6__.Rect.fromDomRect(this.selfRef.current.getBoundingClientRect());\n        }\n        else {\n            return _Rect__WEBPACK_IMPORTED_MODULE_6__.Rect.empty();\n        }\n    }\n    getWindowId() {\n        return this.windowId;\n    }\n    getRootDiv() {\n        return this.selfRef.current;\n    }\n    getMainElement() {\n        return this.mainRef.current;\n    }\n    getFactory() {\n        return this.props.factory;\n    }\n    isSupportsPopout() {\n        return this.supportsPopout;\n    }\n    isRealtimeResize() {\n        var _a;\n        return (_a = this.props.realtimeResize) !== null && _a !== void 0 ? _a : false;\n    }\n    getPopoutURL() {\n        return this.popoutURL;\n    }\n    setEditingTab(tabNode) {\n        this.setState({ editingTab: tabNode });\n    }\n    getEditingTab() {\n        return this.state.editingTab;\n    }\n    getModel() {\n        return this.props.model;\n    }\n    getScreenRect(inRect) {\n        const rect = inRect.clone();\n        const layoutRect = this.getDomRect();\n        // Note: outerHeight can be less than innerHeight when window is zoomed, so cannot use\n        // const navHeight = Math.min(65, this.currentWindow!.outerHeight - this.currentWindow!.innerHeight);\n        // const navWidth = Math.min(65, this.currentWindow!.outerWidth - this.currentWindow!.innerWidth);\n        const navHeight = 60;\n        const navWidth = 2;\n        // console.log(rect.y, this.currentWindow!.screenX,layoutRect.y);\n        rect.x = this.currentWindow.screenX + this.currentWindow.scrollX + navWidth / 2 + layoutRect.x + rect.x;\n        rect.y = this.currentWindow.screenY + this.currentWindow.scrollY + (navHeight - navWidth / 2) + layoutRect.y + rect.y;\n        rect.height += navHeight;\n        rect.width += navWidth;\n        return rect;\n    }\n    addTabToTabSet(tabsetId, json) {\n        const tabsetNode = this.props.model.getNodeById(tabsetId);\n        if (tabsetNode !== undefined) {\n            const node = this.doAction(_model_Actions__WEBPACK_IMPORTED_MODULE_8__.Actions.addNode(json, tabsetId, _DockLocation__WEBPACK_IMPORTED_MODULE_3__.DockLocation.CENTER, -1));\n            return node;\n        }\n        return undefined;\n    }\n    addTabToActiveTabSet(json) {\n        const tabsetNode = this.props.model.getActiveTabset(this.windowId);\n        if (tabsetNode !== undefined) {\n            const node = this.doAction(_model_Actions__WEBPACK_IMPORTED_MODULE_8__.Actions.addNode(json, tabsetNode.getId(), _DockLocation__WEBPACK_IMPORTED_MODULE_3__.DockLocation.CENTER, -1));\n            return node;\n        }\n        return undefined;\n    }\n    maximize(tabsetNode) {\n        this.doAction(_model_Actions__WEBPACK_IMPORTED_MODULE_8__.Actions.maximizeToggle(tabsetNode.getId(), this.getWindowId()));\n    }\n    customizeTab(tabNode, renderValues) {\n        if (this.props.onRenderTab) {\n            this.props.onRenderTab(tabNode, renderValues);\n        }\n    }\n    customizeTabSet(tabSetNode, renderValues) {\n        if (this.props.onRenderTabSet) {\n            this.props.onRenderTabSet(tabSetNode, renderValues);\n        }\n    }\n    i18nName(id, param) {\n        let message;\n        if (this.props.i18nMapper) {\n            message = this.props.i18nMapper(id, param);\n        }\n        if (message === undefined) {\n            message = id + (param === undefined ? \"\" : param);\n        }\n        return message;\n    }\n    getShowOverflowMenu() {\n        return this.props.onShowOverflowMenu;\n    }\n    getTabSetPlaceHolderCallback() {\n        return this.props.onTabSetPlaceHolder;\n    }\n    showContextMenu(node, event) {\n        if (this.props.onContextMenu) {\n            this.props.onContextMenu(node, event);\n        }\n    }\n    auxMouseClick(node, event) {\n        if (this.props.onAuxMouseClick) {\n            this.props.onAuxMouseClick(node, event);\n        }\n    }\n    showOverlay(show) {\n        this.setState({ showOverlay: show });\n        (0,_Utils__WEBPACK_IMPORTED_MODULE_22__.enablePointerOnIFrames)(!show, this.currentDocument);\n    }\n    // *************************** Start Drag Drop *************************************\n    addTabWithDragAndDrop(event, json, onDrop) {\n        const tempNode = _model_TabNode__WEBPACK_IMPORTED_MODULE_11__.TabNode.fromJson(json, this.props.model, false);\n        LayoutInternal.dragState = new DragState(this.mainLayout, DragSource.Add, tempNode, json, onDrop);\n    }\n    moveTabWithDragAndDrop(event, node) {\n        this.setDragNode(event, node);\n    }\n    setDragComponent(event, component, x, y) {\n        let dragElement = (react__WEBPACK_IMPORTED_MODULE_0__.createElement(\"div\", { style: { position: \"unset\" }, className: this.getClassName(_Types__WEBPACK_IMPORTED_MODULE_7__.CLASSES.FLEXLAYOUT__LAYOUT) + \" \" + this.getClassName(_Types__WEBPACK_IMPORTED_MODULE_7__.CLASSES.FLEXLAYOUT__DRAG_RECT) }, component));\n        const tempDiv = this.currentDocument.createElement('div');\n        tempDiv.setAttribute(\"data-layout-path\", \"/drag-rectangle\");\n        tempDiv.style.position = \"absolute\";\n        tempDiv.style.left = \"-10000px\";\n        tempDiv.style.top = \"-10000px\";\n        this.currentDocument.body.appendChild(tempDiv);\n        (0,react_dom_client__WEBPACK_IMPORTED_MODULE_2__.createRoot)(tempDiv).render(dragElement);\n        event.dataTransfer.setDragImage(tempDiv, x, y);\n        setTimeout(() => {\n            this.currentDocument.body.removeChild(tempDiv);\n        }, 0);\n    }\n    setDraggingOverWindow(overWindow) {\n        // console.log(\"setDraggingOverWindow\", overWindow);\n        if (this.isDraggingOverWindow !== overWindow) {\n            if (this.outlineDiv) {\n                this.outlineDiv.style.visibility = overWindow ? \"hidden\" : \"visible\";\n            }\n            if (overWindow) {\n                this.setState({ showEdges: false });\n            }\n            else {\n                // add edge indicators\n                if (this.props.model.getMaximizedTabset(this.windowId) === undefined) {\n                    this.setState({ showEdges: this.props.model.isEnableEdgeDock() });\n                }\n            }\n            this.isDraggingOverWindow = overWindow;\n        }\n    }\n    clearDragMain() {\n        // console.log(\"clear drag main\");\n        LayoutInternal.dragState = undefined;\n        if (this.windowId === _model_Model__WEBPACK_IMPORTED_MODULE_10__.Model.MAIN_WINDOW_ID) {\n            this.isDraggingOverWindow = false;\n        }\n        for (const [, layoutWindow] of this.props.model.getwindowsMap()) {\n            // console.log(layoutWindow);\n            layoutWindow.layout.clearDragLocal();\n        }\n    }\n    clearDragLocal() {\n        // console.log(\"clear drag local\", this.windowId);\n        this.setState({ showEdges: false });\n        this.showOverlay(false);\n        this.dragEnterCount = 0;\n        this.dragging = false;\n        if (this.outlineDiv) {\n            this.selfRef.current.removeChild(this.outlineDiv);\n            this.outlineDiv = undefined;\n        }\n    }\n}\nLayoutInternal.dragState = undefined;\nconst defaultIcons = {\n    close: react__WEBPACK_IMPORTED_MODULE_0__.createElement(_Icons__WEBPACK_IMPORTED_MODULE_18__.CloseIcon, null),\n    closeTabset: react__WEBPACK_IMPORTED_MODULE_0__.createElement(_Icons__WEBPACK_IMPORTED_MODULE_18__.CloseIcon, null),\n    popout: react__WEBPACK_IMPORTED_MODULE_0__.createElement(_Icons__WEBPACK_IMPORTED_MODULE_18__.PopoutIcon, null),\n    maximize: react__WEBPACK_IMPORTED_MODULE_0__.createElement(_Icons__WEBPACK_IMPORTED_MODULE_18__.MaximizeIcon, null),\n    restore: react__WEBPACK_IMPORTED_MODULE_0__.createElement(_Icons__WEBPACK_IMPORTED_MODULE_18__.RestoreIcon, null),\n    more: react__WEBPACK_IMPORTED_MODULE_0__.createElement(_Icons__WEBPACK_IMPORTED_MODULE_18__.OverflowIcon, null),\n    edgeArrow: react__WEBPACK_IMPORTED_MODULE_0__.createElement(_Icons__WEBPACK_IMPORTED_MODULE_18__.EdgeIcon, null),\n    activeTabset: react__WEBPACK_IMPORTED_MODULE_0__.createElement(_Icons__WEBPACK_IMPORTED_MODULE_18__.AsterickIcon, null)\n};\nvar DragSource;\n(function (DragSource) {\n    DragSource[\"Internal\"] = \"internal\";\n    DragSource[\"External\"] = \"external\";\n    DragSource[\"Add\"] = \"add\";\n})(DragSource || (DragSource = {}));\n/** @internal */\nconst defaultSupportsPopout = (0,_Utils__WEBPACK_IMPORTED_MODULE_22__.isDesktop)();\n/** @internal */\nconst edgeRectLength = 100;\n/** @internal */\nconst edgeRectWidth = 10;\n// global layout drag state\nclass DragState {\n    constructor(mainLayout, dragSource, dragNode, dragJson, fnNewNodeDropped) {\n        this.mainLayout = mainLayout;\n        this.dragSource = dragSource;\n        this.dragNode = dragNode;\n        this.dragJson = dragJson;\n        this.fnNewNodeDropped = fnNewNodeDropped;\n    }\n}\n\n\n//# sourceURL=webpack://FlexLayout/./src/view/Layout.tsx?");

/***/ }),

/***/ "./src/view/Overlay.tsx":
/*!******************************!*\
  !*** ./src/view/Overlay.tsx ***!
  \******************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   Overlay: () => (/* binding */ Overlay)\n/* harmony export */ });\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react */ \"react\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony import */ var _Types__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../Types */ \"./src/Types.ts\");\n\n\n/** @internal */\nconst Overlay = (props) => {\n    const { layout, show } = props;\n    return (react__WEBPACK_IMPORTED_MODULE_0__.createElement(\"div\", { className: layout.getClassName(_Types__WEBPACK_IMPORTED_MODULE_1__.CLASSES.FLEXLAYOUT__LAYOUT_OVERLAY), style: { display: (show ? \"flex\" : \"none\")\n        } }));\n};\n\n\n//# sourceURL=webpack://FlexLayout/./src/view/Overlay.tsx?");

/***/ }),

/***/ "./src/view/PopoutWindow.tsx":
/*!***********************************!*\
  !*** ./src/view/PopoutWindow.tsx ***!
  \***********************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   PopoutWindow: () => (/* binding */ PopoutWindow)\n/* harmony export */ });\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react */ \"react\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony import */ var react_dom__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! react-dom */ \"react-dom\");\n/* harmony import */ var react_dom__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(react_dom__WEBPACK_IMPORTED_MODULE_1__);\n/* harmony import */ var _Types__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../Types */ \"./src/Types.ts\");\n\n\n\n/** @internal */\nconst PopoutWindow = (props) => {\n    const { title, layout, layoutWindow, url, onCloseWindow, onSetWindow, children } = props;\n    const popoutWindow = react__WEBPACK_IMPORTED_MODULE_0__.useRef(null);\n    const [content, setContent] = react__WEBPACK_IMPORTED_MODULE_0__.useState(undefined);\n    // map from main docs style -> this docs equivalent style\n    const styleMap = new Map();\n    react__WEBPACK_IMPORTED_MODULE_0__.useLayoutEffect(() => {\n        if (!popoutWindow.current) { // only create window once, even in strict mode\n            const windowId = layoutWindow.windowId;\n            const rect = layoutWindow.rect;\n            popoutWindow.current = window.open(url, windowId, `left=${rect.x},top=${rect.y},width=${rect.width},height=${rect.height}`);\n            if (popoutWindow.current) {\n                layoutWindow.window = popoutWindow.current;\n                onSetWindow(layoutWindow, popoutWindow.current);\n                // listen for parent unloading to remove all popouts\n                window.addEventListener(\"beforeunload\", () => {\n                    if (popoutWindow.current) {\n                        const closedWindow = popoutWindow.current;\n                        popoutWindow.current = null; // need to set to null before close, since this will trigger popup window before unload...\n                        closedWindow.close();\n                    }\n                });\n                popoutWindow.current.addEventListener(\"load\", () => {\n                    if (popoutWindow.current) {\n                        popoutWindow.current.focus();\n                        // note: resizeto must be before moveto in chrome otherwise the window will end up at 0,0\n                        popoutWindow.current.resizeTo(rect.width, rect.height);\n                        popoutWindow.current.moveTo(rect.x, rect.y);\n                        const popoutDocument = popoutWindow.current.document;\n                        popoutDocument.title = title;\n                        const popoutContent = popoutDocument.createElement(\"div\");\n                        popoutContent.className = _Types__WEBPACK_IMPORTED_MODULE_2__.CLASSES.FLEXLAYOUT__FLOATING_WINDOW_CONTENT;\n                        popoutDocument.body.appendChild(popoutContent);\n                        copyStyles(popoutDocument, styleMap).then(() => {\n                            setContent(popoutContent); // re-render once link styles loaded\n                        });\n                        // listen for style mutations\n                        const observer = new MutationObserver((mutationsList) => handleStyleMutations(mutationsList, popoutDocument, styleMap));\n                        observer.observe(document.head, { childList: true });\n                        // listen for popout unloading (needs to be after load for safari)\n                        popoutWindow.current.addEventListener(\"beforeunload\", () => {\n                            if (popoutWindow.current) {\n                                onCloseWindow(layoutWindow); // remove the layoutWindow in the model\n                                popoutWindow.current = null;\n                                observer.disconnect();\n                            }\n                        });\n                    }\n                });\n            }\n            else {\n                console.warn(`Unable to open window ${url}`);\n                onCloseWindow(layoutWindow); // remove the layoutWindow in the model\n            }\n        }\n        return () => {\n            var _a;\n            // only close popoutWindow if windowId has been removed from the model (ie this was due to model change)\n            if (!layout.getModel().getwindowsMap().has(layoutWindow.windowId)) {\n                (_a = popoutWindow.current) === null || _a === void 0 ? void 0 : _a.close();\n                popoutWindow.current = null;\n            }\n        };\n    }, []);\n    if (content !== undefined) {\n        return (0,react_dom__WEBPACK_IMPORTED_MODULE_1__.createPortal)(children, content);\n    }\n    else {\n        return null;\n    }\n};\nfunction handleStyleMutations(mutationsList, popoutDocument, styleMap) {\n    for (const mutation of mutationsList) {\n        if (mutation.type === 'childList') {\n            for (const addition of mutation.addedNodes) {\n                if (addition instanceof HTMLLinkElement || addition instanceof HTMLStyleElement) {\n                    copyStyle(popoutDocument, addition, styleMap);\n                }\n            }\n            for (const removal of mutation.removedNodes) {\n                if (removal instanceof HTMLLinkElement || removal instanceof HTMLStyleElement) {\n                    const popoutStyle = styleMap.get(removal);\n                    if (popoutStyle) {\n                        popoutDocument.head.removeChild(popoutStyle);\n                    }\n                }\n            }\n        }\n    }\n}\n;\n/** @internal */\nfunction copyStyles(popoutDoc, styleMap) {\n    const promises = [];\n    const styleElements = document.querySelectorAll('style, link[rel=\"stylesheet\"]');\n    for (const element of styleElements) {\n        copyStyle(popoutDoc, element, styleMap, promises);\n    }\n    return Promise.all(promises);\n}\n/** @internal */\nfunction copyStyle(popoutDoc, element, styleMap, promises) {\n    if (element instanceof HTMLLinkElement) {\n        // prefer links since they will keep paths to images etc\n        const linkElement = element.cloneNode(true);\n        popoutDoc.head.appendChild(linkElement);\n        styleMap.set(element, linkElement);\n        if (promises) {\n            promises.push(new Promise((resolve) => {\n                linkElement.onload = () => resolve(true);\n            }));\n        }\n    }\n    else if (element instanceof HTMLStyleElement) {\n        try {\n            const styleElement = element.cloneNode(true);\n            popoutDoc.head.appendChild(styleElement);\n            styleMap.set(element, styleElement);\n        }\n        catch (e) {\n            // can throw an exception\n        }\n    }\n}\n\n\n//# sourceURL=webpack://FlexLayout/./src/view/PopoutWindow.tsx?");

/***/ }),

/***/ "./src/view/PopupMenu.tsx":
/*!********************************!*\
  !*** ./src/view/PopupMenu.tsx ***!
  \********************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   showPopup: () => (/* binding */ showPopup)\n/* harmony export */ });\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react */ \"react\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony import */ var _Types__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../Types */ \"./src/Types.ts\");\n/* harmony import */ var _TabButtonStamp__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./TabButtonStamp */ \"./src/view/TabButtonStamp.tsx\");\n\n\n\n/** @internal */\nfunction showPopup(triggerElement, items, onSelect, layout) {\n    var _a;\n    const layoutDiv = layout.getRootDiv();\n    const classNameMapper = layout.getClassName;\n    const currentDocument = triggerElement.ownerDocument;\n    const triggerRect = triggerElement.getBoundingClientRect();\n    const layoutRect = (_a = layoutDiv === null || layoutDiv === void 0 ? void 0 : layoutDiv.getBoundingClientRect()) !== null && _a !== void 0 ? _a : new DOMRect(0, 0, 100, 100);\n    const elm = currentDocument.createElement(\"div\");\n    elm.className = classNameMapper(_Types__WEBPACK_IMPORTED_MODULE_1__.CLASSES.FLEXLAYOUT__POPUP_MENU_CONTAINER);\n    if (triggerRect.left < layoutRect.left + layoutRect.width / 2) {\n        elm.style.left = triggerRect.left - layoutRect.left + \"px\";\n    }\n    else {\n        elm.style.right = layoutRect.right - triggerRect.right + \"px\";\n    }\n    if (triggerRect.top < layoutRect.top + layoutRect.height / 2) {\n        elm.style.top = triggerRect.top - layoutRect.top + \"px\";\n    }\n    else {\n        elm.style.bottom = layoutRect.bottom - triggerRect.bottom + \"px\";\n    }\n    layout.showOverlay(true);\n    if (layoutDiv) {\n        layoutDiv.appendChild(elm);\n    }\n    const onHide = () => {\n        layout.hideControlInPortal();\n        layout.showOverlay(false);\n        if (layoutDiv) {\n            layoutDiv.removeChild(elm);\n        }\n        elm.removeEventListener(\"pointerdown\", onElementPointerDown);\n        currentDocument.removeEventListener(\"pointerdown\", onDocPointerDown);\n    };\n    const onElementPointerDown = (event) => {\n        event.stopPropagation();\n    };\n    const onDocPointerDown = (_event) => {\n        onHide();\n    };\n    elm.addEventListener(\"pointerdown\", onElementPointerDown);\n    currentDocument.addEventListener(\"pointerdown\", onDocPointerDown);\n    layout.showControlInPortal(react__WEBPACK_IMPORTED_MODULE_0__.createElement(PopupMenu, { currentDocument: currentDocument, onSelect: onSelect, onHide: onHide, items: items, classNameMapper: classNameMapper, layout: layout }), elm);\n}\n/** @internal */\nconst PopupMenu = (props) => {\n    const { items, onHide, onSelect, classNameMapper, layout } = props;\n    const onItemClick = (item, event) => {\n        onSelect(item);\n        onHide();\n        event.stopPropagation();\n    };\n    const onDragStart = (event, node) => {\n        event.stopPropagation(); // prevent starting a tabset drag as well\n        layout.setDragNode(event.nativeEvent, node);\n        setTimeout(() => {\n            onHide();\n        }, 0);\n    };\n    const onDragEnd = (event) => {\n        layout.clearDragMain();\n    };\n    const itemElements = items.map((item, i) => (react__WEBPACK_IMPORTED_MODULE_0__.createElement(\"div\", { key: item.index, className: classNameMapper(_Types__WEBPACK_IMPORTED_MODULE_1__.CLASSES.FLEXLAYOUT__POPUP_MENU_ITEM), \"data-layout-path\": \"/popup-menu/tb\" + i, onClick: (event) => onItemClick(item, event), draggable: true, onDragStart: (e) => onDragStart(e, item.node), onDragEnd: onDragEnd, title: item.node.getHelpText() },\n        react__WEBPACK_IMPORTED_MODULE_0__.createElement(_TabButtonStamp__WEBPACK_IMPORTED_MODULE_2__.TabButtonStamp, { node: item.node, layout: layout }))));\n    return (react__WEBPACK_IMPORTED_MODULE_0__.createElement(\"div\", { className: classNameMapper(_Types__WEBPACK_IMPORTED_MODULE_1__.CLASSES.FLEXLAYOUT__POPUP_MENU), \"data-layout-path\": \"/popup-menu\" }, itemElements));\n};\n\n\n//# sourceURL=webpack://FlexLayout/./src/view/PopupMenu.tsx?");

/***/ }),

/***/ "./src/view/Row.tsx":
/*!**************************!*\
  !*** ./src/view/Row.tsx ***!
  \**************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   Row: () => (/* binding */ Row)\n/* harmony export */ });\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react */ \"react\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony import */ var _model_RowNode__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../model/RowNode */ \"./src/model/RowNode.ts\");\n/* harmony import */ var _model_TabSetNode__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../model/TabSetNode */ \"./src/model/TabSetNode.ts\");\n/* harmony import */ var _Types__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../Types */ \"./src/Types.ts\");\n/* harmony import */ var _TabSet__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./TabSet */ \"./src/view/TabSet.tsx\");\n/* harmony import */ var _Splitter__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./Splitter */ \"./src/view/Splitter.tsx\");\n/* harmony import */ var _Orientation__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ../Orientation */ \"./src/Orientation.ts\");\n\n\n\n\n\n\n\n/** @internal */\nconst Row = (props) => {\n    const { layout, node } = props;\n    const selfRef = react__WEBPACK_IMPORTED_MODULE_0__.useRef(null);\n    const horizontal = node.getOrientation() === _Orientation__WEBPACK_IMPORTED_MODULE_6__.Orientation.HORZ;\n    react__WEBPACK_IMPORTED_MODULE_0__.useLayoutEffect(() => {\n        node.setRect(layout.getBoundingClientRect(selfRef.current));\n    });\n    const items = [];\n    let i = 0;\n    for (const child of node.getChildren()) {\n        if (i > 0) {\n            items.push(react__WEBPACK_IMPORTED_MODULE_0__.createElement(_Splitter__WEBPACK_IMPORTED_MODULE_5__.Splitter, { key: \"splitter\" + i, layout: layout, node: node, index: i, horizontal: horizontal }));\n        }\n        if (child instanceof _model_RowNode__WEBPACK_IMPORTED_MODULE_1__.RowNode) {\n            items.push(react__WEBPACK_IMPORTED_MODULE_0__.createElement(Row, { key: child.getId(), layout: layout, node: child }));\n        }\n        else if (child instanceof _model_TabSetNode__WEBPACK_IMPORTED_MODULE_2__.TabSetNode) {\n            items.push(react__WEBPACK_IMPORTED_MODULE_0__.createElement(_TabSet__WEBPACK_IMPORTED_MODULE_4__.TabSet, { key: child.getId(), layout: layout, node: child }));\n        }\n        i++;\n    }\n    const style = {\n        flexGrow: Math.max(1, node.getWeight() * 1000), // NOTE:  flex-grow cannot have values < 1 otherwise will not fill parent, need to normalize \n        minWidth: node.getMinWidth(),\n        minHeight: node.getMinHeight(),\n        maxWidth: node.getMaxWidth(),\n        maxHeight: node.getMaxHeight(),\n    };\n    if (horizontal) {\n        style.flexDirection = \"row\";\n    }\n    else {\n        style.flexDirection = \"column\";\n    }\n    return (react__WEBPACK_IMPORTED_MODULE_0__.createElement(\"div\", { ref: selfRef, className: layout.getClassName(_Types__WEBPACK_IMPORTED_MODULE_3__.CLASSES.FLEXLAYOUT__ROW), style: style }, items));\n};\n\n\n//# sourceURL=webpack://FlexLayout/./src/view/Row.tsx?");

/***/ }),

/***/ "./src/view/SizeTracker.tsx":
/*!**********************************!*\
  !*** ./src/view/SizeTracker.tsx ***!
  \**********************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   SizeTracker: () => (/* binding */ SizeTracker)\n/* harmony export */ });\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react */ \"react\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_0__);\n\n// only render if size changed or forceRevision changed or tabsRevision changed\nconst SizeTracker = react__WEBPACK_IMPORTED_MODULE_0__.memo(({ children }) => {\n    return react__WEBPACK_IMPORTED_MODULE_0__.createElement(react__WEBPACK_IMPORTED_MODULE_0__.Fragment, null, children);\n}, (prevProps, nextProps) => {\n    return prevProps.rect.equalSize(nextProps.rect) &&\n        prevProps.selected === nextProps.selected &&\n        prevProps.forceRevision === nextProps.forceRevision &&\n        prevProps.tabsRevision === nextProps.tabsRevision;\n});\n\n\n//# sourceURL=webpack://FlexLayout/./src/view/SizeTracker.tsx?");

/***/ }),

/***/ "./src/view/Splitter.tsx":
/*!*******************************!*\
  !*** ./src/view/Splitter.tsx ***!
  \*******************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   Splitter: () => (/* binding */ Splitter)\n/* harmony export */ });\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react */ \"react\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony import */ var _model_Actions__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../model/Actions */ \"./src/model/Actions.ts\");\n/* harmony import */ var _model_BorderNode__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../model/BorderNode */ \"./src/model/BorderNode.ts\");\n/* harmony import */ var _model_RowNode__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../model/RowNode */ \"./src/model/RowNode.ts\");\n/* harmony import */ var _Orientation__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../Orientation */ \"./src/Orientation.ts\");\n/* harmony import */ var _Types__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../Types */ \"./src/Types.ts\");\n/* harmony import */ var _Utils__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./Utils */ \"./src/view/Utils.tsx\");\n/* harmony import */ var _Rect__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ../Rect */ \"./src/Rect.ts\");\n\n\n\n\n\n\n\n\n/** @internal */\nconst Splitter = (props) => {\n    const { layout, node, index, horizontal } = props;\n    const [dragging, setDragging] = react__WEBPACK_IMPORTED_MODULE_0__.useState(false);\n    const selfRef = react__WEBPACK_IMPORTED_MODULE_0__.useRef(null);\n    const extendedRef = react__WEBPACK_IMPORTED_MODULE_0__.useRef(null);\n    const pBounds = react__WEBPACK_IMPORTED_MODULE_0__.useRef([]);\n    const outlineDiv = react__WEBPACK_IMPORTED_MODULE_0__.useRef(undefined);\n    const handleDiv = react__WEBPACK_IMPORTED_MODULE_0__.useRef(undefined);\n    const dragStartX = react__WEBPACK_IMPORTED_MODULE_0__.useRef(0);\n    const dragStartY = react__WEBPACK_IMPORTED_MODULE_0__.useRef(0);\n    const initalSizes = react__WEBPACK_IMPORTED_MODULE_0__.useRef({ initialSizes: [], sum: 0, startPosition: 0 });\n    // const throttleTimer = React.useRef<NodeJS.Timeout | undefined>(undefined);\n    const size = node.getModel().getSplitterSize();\n    let extra = node.getModel().getSplitterExtra();\n    if (!(0,_Utils__WEBPACK_IMPORTED_MODULE_6__.isDesktop)()) {\n        // make hit test area on mobile at least 30px\n        extra = Math.max(30, extra + size) - size;\n    }\n    react__WEBPACK_IMPORTED_MODULE_0__.useEffect(() => {\n        var _a, _b;\n        // Android fix: must have passive touchstart handler to prevent default handling\n        (_a = selfRef.current) === null || _a === void 0 ? void 0 : _a.addEventListener(\"touchstart\", onTouchStart, { passive: false });\n        (_b = extendedRef.current) === null || _b === void 0 ? void 0 : _b.addEventListener(\"touchstart\", onTouchStart, { passive: false });\n        return () => {\n            var _a, _b;\n            (_a = selfRef.current) === null || _a === void 0 ? void 0 : _a.removeEventListener(\"touchstart\", onTouchStart);\n            (_b = extendedRef.current) === null || _b === void 0 ? void 0 : _b.removeEventListener(\"touchstart\", onTouchStart);\n        };\n    }, []);\n    const onTouchStart = (event) => {\n        event.preventDefault();\n        event.stopImmediatePropagation();\n    };\n    const onPointerDown = (event) => {\n        var _a;\n        event.stopPropagation();\n        if (node instanceof _model_RowNode__WEBPACK_IMPORTED_MODULE_3__.RowNode) {\n            initalSizes.current = node.getSplitterInitials(index);\n        }\n        (0,_Utils__WEBPACK_IMPORTED_MODULE_6__.enablePointerOnIFrames)(false, layout.getCurrentDocument());\n        (0,_Utils__WEBPACK_IMPORTED_MODULE_6__.startDrag)(event.currentTarget.ownerDocument, event, onDragMove, onDragEnd, onDragCancel);\n        pBounds.current = node.getSplitterBounds(index, true);\n        const rootdiv = layout.getRootDiv();\n        outlineDiv.current = layout.getCurrentDocument().createElement(\"div\");\n        outlineDiv.current.style.flexDirection = horizontal ? \"row\" : \"column\";\n        outlineDiv.current.className = layout.getClassName(_Types__WEBPACK_IMPORTED_MODULE_5__.CLASSES.FLEXLAYOUT__SPLITTER_DRAG);\n        outlineDiv.current.style.cursor = node.getOrientation() === _Orientation__WEBPACK_IMPORTED_MODULE_4__.Orientation.VERT ? \"ns-resize\" : \"ew-resize\";\n        if (node.getModel().isSplitterEnableHandle()) {\n            handleDiv.current = layout.getCurrentDocument().createElement(\"div\");\n            handleDiv.current.className = cm(_Types__WEBPACK_IMPORTED_MODULE_5__.CLASSES.FLEXLAYOUT__SPLITTER_HANDLE) + \" \" +\n                (horizontal ? cm(_Types__WEBPACK_IMPORTED_MODULE_5__.CLASSES.FLEXLAYOUT__SPLITTER_HANDLE_HORZ) : cm(_Types__WEBPACK_IMPORTED_MODULE_5__.CLASSES.FLEXLAYOUT__SPLITTER_HANDLE_VERT));\n            outlineDiv.current.appendChild(handleDiv.current);\n        }\n        const r = (_a = selfRef.current) === null || _a === void 0 ? void 0 : _a.getBoundingClientRect();\n        const rect = new _Rect__WEBPACK_IMPORTED_MODULE_7__.Rect(r.x - layout.getDomRect().x, r.y - layout.getDomRect().y, r.width, r.height);\n        dragStartX.current = event.clientX - r.x;\n        dragStartY.current = event.clientY - r.y;\n        rect.positionElement(outlineDiv.current);\n        if (rootdiv) {\n            rootdiv.appendChild(outlineDiv.current);\n        }\n        setDragging(true);\n    };\n    const onDragCancel = () => {\n        const rootdiv = layout.getRootDiv();\n        if (rootdiv && outlineDiv.current) {\n            rootdiv.removeChild(outlineDiv.current);\n        }\n        outlineDiv.current = undefined;\n        setDragging(false);\n    };\n    const onDragMove = (x, y) => {\n        if (outlineDiv.current) {\n            const clientRect = layout.getDomRect();\n            if (!clientRect) {\n                return;\n            }\n            if (node.getOrientation() === _Orientation__WEBPACK_IMPORTED_MODULE_4__.Orientation.VERT) {\n                outlineDiv.current.style.top = getBoundPosition(y - clientRect.y - dragStartY.current) + \"px\";\n            }\n            else {\n                outlineDiv.current.style.left = getBoundPosition(x - clientRect.x - dragStartX.current) + \"px\";\n            }\n            if (layout.isRealtimeResize()) {\n                updateLayout(true);\n            }\n        }\n    };\n    const onDragEnd = () => {\n        if (outlineDiv.current) {\n            updateLayout(false);\n            const rootdiv = layout.getRootDiv();\n            if (rootdiv && outlineDiv.current) {\n                rootdiv.removeChild(outlineDiv.current);\n            }\n            outlineDiv.current = undefined;\n        }\n        (0,_Utils__WEBPACK_IMPORTED_MODULE_6__.enablePointerOnIFrames)(true, layout.getCurrentDocument());\n        setDragging(false);\n    };\n    const updateLayout = (realtime) => {\n        const redraw = () => {\n            if (outlineDiv.current) {\n                let value = 0;\n                if (node.getOrientation() === _Orientation__WEBPACK_IMPORTED_MODULE_4__.Orientation.VERT) {\n                    value = outlineDiv.current.offsetTop;\n                }\n                else {\n                    value = outlineDiv.current.offsetLeft;\n                }\n                if (node instanceof _model_BorderNode__WEBPACK_IMPORTED_MODULE_2__.BorderNode) {\n                    const pos = node.calculateSplit(node, value);\n                    layout.doAction(_model_Actions__WEBPACK_IMPORTED_MODULE_1__.Actions.adjustBorderSplit(node.getId(), pos));\n                }\n                else {\n                    const init = initalSizes.current;\n                    const weights = node.calculateSplit(index, value, init.initialSizes, init.sum, init.startPosition);\n                    layout.doAction(_model_Actions__WEBPACK_IMPORTED_MODULE_1__.Actions.adjustWeights(node.getId(), weights));\n                }\n            }\n        };\n        redraw();\n    };\n    const getBoundPosition = (p) => {\n        const bounds = pBounds.current;\n        let rtn = p;\n        if (p < bounds[0]) {\n            rtn = bounds[0];\n        }\n        if (p > bounds[1]) {\n            rtn = bounds[1];\n        }\n        return rtn;\n    };\n    const cm = layout.getClassName;\n    const style = {\n        cursor: horizontal ? \"ew-resize\" : \"ns-resize\",\n        flexDirection: horizontal ? \"column\" : \"row\"\n    };\n    let className = cm(_Types__WEBPACK_IMPORTED_MODULE_5__.CLASSES.FLEXLAYOUT__SPLITTER) + \" \" + cm(_Types__WEBPACK_IMPORTED_MODULE_5__.CLASSES.FLEXLAYOUT__SPLITTER_ + node.getOrientation().getName());\n    if (node instanceof _model_BorderNode__WEBPACK_IMPORTED_MODULE_2__.BorderNode) {\n        className += \" \" + cm(_Types__WEBPACK_IMPORTED_MODULE_5__.CLASSES.FLEXLAYOUT__SPLITTER_BORDER);\n    }\n    else {\n        if (node.getModel().getMaximizedTabset(layout.getWindowId()) !== undefined) {\n            style.display = \"none\";\n        }\n    }\n    if (horizontal) {\n        style.width = size + \"px\";\n        style.minWidth = size + \"px\";\n    }\n    else {\n        style.height = size + \"px\";\n        style.minHeight = size + \"px\";\n    }\n    let handle;\n    if (!dragging && node.getModel().isSplitterEnableHandle()) {\n        handle = (react__WEBPACK_IMPORTED_MODULE_0__.createElement(\"div\", { className: cm(_Types__WEBPACK_IMPORTED_MODULE_5__.CLASSES.FLEXLAYOUT__SPLITTER_HANDLE) + \" \" +\n                (horizontal ? cm(_Types__WEBPACK_IMPORTED_MODULE_5__.CLASSES.FLEXLAYOUT__SPLITTER_HANDLE_HORZ) : cm(_Types__WEBPACK_IMPORTED_MODULE_5__.CLASSES.FLEXLAYOUT__SPLITTER_HANDLE_VERT)) }));\n    }\n    if (extra === 0) {\n        return (react__WEBPACK_IMPORTED_MODULE_0__.createElement(\"div\", { className: className, style: style, ref: selfRef, \"data-layout-path\": node.getPath() + \"/s\" + (index - 1), onPointerDown: onPointerDown }, handle));\n    }\n    else {\n        // add extended transparent div for hit testing\n        const style2 = {};\n        if (node.getOrientation() === _Orientation__WEBPACK_IMPORTED_MODULE_4__.Orientation.HORZ) {\n            style2.height = \"100%\";\n            style2.width = size + extra + \"px\";\n            style2.cursor = \"ew-resize\";\n        }\n        else {\n            style2.height = size + extra + \"px\";\n            style2.width = \"100%\";\n            style2.cursor = \"ns-resize\";\n        }\n        const className2 = cm(_Types__WEBPACK_IMPORTED_MODULE_5__.CLASSES.FLEXLAYOUT__SPLITTER_EXTRA);\n        return (react__WEBPACK_IMPORTED_MODULE_0__.createElement(\"div\", { className: className, style: style, ref: selfRef, \"data-layout-path\": node.getPath() + \"/s\" + (index - 1), onPointerDown: onPointerDown },\n            react__WEBPACK_IMPORTED_MODULE_0__.createElement(\"div\", { style: style2, ref: extendedRef, className: className2, onPointerDown: onPointerDown })));\n    }\n};\n\n\n//# sourceURL=webpack://FlexLayout/./src/view/Splitter.tsx?");

/***/ }),

/***/ "./src/view/Tab.tsx":
/*!**************************!*\
  !*** ./src/view/Tab.tsx ***!
  \**************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   Tab: () => (/* binding */ Tab)\n/* harmony export */ });\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react */ \"react\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony import */ var _model_TabSetNode__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../model/TabSetNode */ \"./src/model/TabSetNode.ts\");\n/* harmony import */ var _Types__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../Types */ \"./src/Types.ts\");\n/* harmony import */ var _model_BorderNode__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../model/BorderNode */ \"./src/model/BorderNode.ts\");\n/* harmony import */ var _model_Actions__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../model/Actions */ \"./src/model/Actions.ts\");\n\n\n\n\n\n/** @internal */\nconst Tab = (props) => {\n    const { layout, selected, node, path } = props;\n    const selfRef = react__WEBPACK_IMPORTED_MODULE_0__.useRef(null);\n    const firstSelect = react__WEBPACK_IMPORTED_MODULE_0__.useRef(true);\n    const parentNode = node.getParent();\n    const rect = parentNode.getContentRect();\n    react__WEBPACK_IMPORTED_MODULE_0__.useLayoutEffect(() => {\n        const element = node.getMoveableElement();\n        selfRef.current.appendChild(element);\n        node.setMoveableElement(element);\n        const handleScroll = () => {\n            node.saveScrollPosition();\n        };\n        // keep scroll position\n        element.addEventListener('scroll', handleScroll);\n        // listen for clicks to change active tabset\n        selfRef.current.addEventListener(\"pointerdown\", onPointerDown);\n        return () => {\n            element.removeEventListener('scroll', handleScroll);\n            if (selfRef.current) {\n                selfRef.current.removeEventListener(\"pointerdown\", onPointerDown);\n            }\n            node.setVisible(false);\n        };\n    }, []);\n    react__WEBPACK_IMPORTED_MODULE_0__.useEffect(() => {\n        if (node.isSelected()) {\n            if (firstSelect.current) {\n                node.restoreScrollPosition(); // if window docked back in\n                firstSelect.current = false;\n            }\n        }\n    });\n    const onPointerDown = () => {\n        const parent = node.getParent(); // cannot use parentNode here since will be out of date\n        if (parent instanceof _model_TabSetNode__WEBPACK_IMPORTED_MODULE_1__.TabSetNode) {\n            if (!parent.isActive()) {\n                layout.doAction(_model_Actions__WEBPACK_IMPORTED_MODULE_4__.Actions.setActiveTabset(parent.getId(), layout.getWindowId()));\n            }\n        }\n    };\n    node.setRect(rect); // needed for resize event\n    const cm = layout.getClassName;\n    const style = {};\n    rect.styleWithPosition(style);\n    let overlay = null;\n    if (selected) {\n        node.setVisible(true);\n        if (document.hidden && node.isEnablePopoutOverlay()) {\n            const overlayStyle = {};\n            rect.styleWithPosition(overlayStyle);\n            overlay = (react__WEBPACK_IMPORTED_MODULE_0__.createElement(\"div\", { style: overlayStyle, className: cm(_Types__WEBPACK_IMPORTED_MODULE_2__.CLASSES.FLEXLAYOUT__TAB_OVERLAY) }));\n        }\n    }\n    else {\n        style.display = \"none\";\n        node.setVisible(false);\n    }\n    if (parentNode instanceof _model_TabSetNode__WEBPACK_IMPORTED_MODULE_1__.TabSetNode) {\n        if (node.getModel().getMaximizedTabset(layout.getWindowId()) !== undefined) {\n            if (parentNode.isMaximized()) {\n                style.zIndex = 10;\n            }\n            else {\n                style.display = \"none\";\n            }\n        }\n    }\n    let className = cm(_Types__WEBPACK_IMPORTED_MODULE_2__.CLASSES.FLEXLAYOUT__TAB);\n    if (parentNode instanceof _model_BorderNode__WEBPACK_IMPORTED_MODULE_3__.BorderNode) {\n        className += \" \" + cm(_Types__WEBPACK_IMPORTED_MODULE_2__.CLASSES.FLEXLAYOUT__TAB_BORDER);\n        className += \" \" + cm(_Types__WEBPACK_IMPORTED_MODULE_2__.CLASSES.FLEXLAYOUT__TAB_BORDER_ + parentNode.getLocation().getName());\n    }\n    if (node.getContentClassName() !== undefined) {\n        className += \" \" + node.getContentClassName();\n    }\n    return (react__WEBPACK_IMPORTED_MODULE_0__.createElement(react__WEBPACK_IMPORTED_MODULE_0__.Fragment, null,\n        overlay,\n        react__WEBPACK_IMPORTED_MODULE_0__.createElement(\"div\", { ref: selfRef, style: style, className: className, \"data-layout-path\": path })));\n};\n\n\n//# sourceURL=webpack://FlexLayout/./src/view/Tab.tsx?");

/***/ }),

/***/ "./src/view/TabButton.tsx":
/*!********************************!*\
  !*** ./src/view/TabButton.tsx ***!
  \********************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   TabButton: () => (/* binding */ TabButton)\n/* harmony export */ });\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react */ \"react\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony import */ var _I18nLabel__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../I18nLabel */ \"./src/I18nLabel.ts\");\n/* harmony import */ var _model_Actions__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../model/Actions */ \"./src/model/Actions.ts\");\n/* harmony import */ var _model_ICloseType__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../model/ICloseType */ \"./src/model/ICloseType.ts\");\n/* harmony import */ var _Types__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../Types */ \"./src/Types.ts\");\n/* harmony import */ var _Utils__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./Utils */ \"./src/view/Utils.tsx\");\n\n\n\n\n\n\n/** @internal */\nconst TabButton = (props) => {\n    const { layout, node, selected, path } = props;\n    const selfRef = react__WEBPACK_IMPORTED_MODULE_0__.useRef(null);\n    const contentRef = react__WEBPACK_IMPORTED_MODULE_0__.useRef(null);\n    const icons = layout.getIcons();\n    react__WEBPACK_IMPORTED_MODULE_0__.useLayoutEffect(() => {\n        node.setTabRect(layout.getBoundingClientRect(selfRef.current));\n        if (layout.getEditingTab() === node) {\n            contentRef.current.select();\n        }\n    });\n    const onDragStart = (event) => {\n        event.stopPropagation(); // prevent starting a tabset drag as well\n        layout.setDragNode(event.nativeEvent, node);\n    };\n    const onDragEnd = (event) => {\n        layout.clearDragMain();\n    };\n    const onAuxMouseClick = (event) => {\n        if ((0,_Utils__WEBPACK_IMPORTED_MODULE_5__.isAuxMouseEvent)(event)) {\n            layout.auxMouseClick(node, event);\n        }\n    };\n    const onContextMenu = (event) => {\n        layout.showContextMenu(node, event);\n    };\n    const onClick = () => {\n        layout.doAction(_model_Actions__WEBPACK_IMPORTED_MODULE_2__.Actions.selectTab(node.getId()));\n    };\n    const onDoubleClick = (event) => {\n        if (node.isEnableRename()) {\n            onRename();\n            event.stopPropagation();\n        }\n    };\n    const onRename = () => {\n        layout.setEditingTab(node);\n        layout.getCurrentDocument().body.addEventListener(\"pointerdown\", onEndEdit);\n    };\n    const onEndEdit = (event) => {\n        if (event.target !== contentRef.current) {\n            layout.getCurrentDocument().body.removeEventListener(\"pointerdown\", onEndEdit);\n            layout.setEditingTab(undefined);\n        }\n    };\n    const isClosable = () => {\n        const closeType = node.getCloseType();\n        if (selected || closeType === _model_ICloseType__WEBPACK_IMPORTED_MODULE_3__.ICloseType.Always) {\n            return true;\n        }\n        if (closeType === _model_ICloseType__WEBPACK_IMPORTED_MODULE_3__.ICloseType.Visible) {\n            // not selected but x should be visible due to hover\n            if (window.matchMedia && window.matchMedia(\"(hover: hover) and (pointer: fine)\").matches) {\n                return true;\n            }\n        }\n        return false;\n    };\n    const onClose = (event) => {\n        if (isClosable()) {\n            layout.doAction(_model_Actions__WEBPACK_IMPORTED_MODULE_2__.Actions.deleteTab(node.getId()));\n        }\n        else {\n            onClick();\n        }\n    };\n    const onClosePointerDown = (event) => {\n        event.stopPropagation();\n    };\n    const onTextBoxPointerDown = (event) => {\n        event.stopPropagation();\n    };\n    const onTextBoxKeyPress = (event) => {\n        if (event.code === 'Escape') {\n            // esc\n            layout.setEditingTab(undefined);\n        }\n        else if (event.code === 'Enter') {\n            // enter\n            layout.setEditingTab(undefined);\n            layout.doAction(_model_Actions__WEBPACK_IMPORTED_MODULE_2__.Actions.renameTab(node.getId(), event.target.value));\n        }\n    };\n    const cm = layout.getClassName;\n    const parentNode = node.getParent();\n    const isStretch = parentNode.isEnableSingleTabStretch() && parentNode.getChildren().length === 1;\n    let baseClassName = isStretch ? _Types__WEBPACK_IMPORTED_MODULE_4__.CLASSES.FLEXLAYOUT__TAB_BUTTON_STRETCH : _Types__WEBPACK_IMPORTED_MODULE_4__.CLASSES.FLEXLAYOUT__TAB_BUTTON;\n    let classNames = cm(baseClassName);\n    classNames += \" \" + cm(baseClassName + \"_\" + parentNode.getTabLocation());\n    if (!isStretch) {\n        if (selected) {\n            classNames += \" \" + cm(baseClassName + \"--selected\");\n        }\n        else {\n            classNames += \" \" + cm(baseClassName + \"--unselected\");\n        }\n    }\n    if (node.getClassName() !== undefined) {\n        classNames += \" \" + node.getClassName();\n    }\n    const renderState = (0,_Utils__WEBPACK_IMPORTED_MODULE_5__.getRenderStateEx)(layout, node);\n    let content = renderState.content ? (react__WEBPACK_IMPORTED_MODULE_0__.createElement(\"div\", { className: cm(_Types__WEBPACK_IMPORTED_MODULE_4__.CLASSES.FLEXLAYOUT__TAB_BUTTON_CONTENT) }, renderState.content)) : null;\n    const leading = renderState.leading ? (react__WEBPACK_IMPORTED_MODULE_0__.createElement(\"div\", { className: cm(_Types__WEBPACK_IMPORTED_MODULE_4__.CLASSES.FLEXLAYOUT__TAB_BUTTON_LEADING) }, renderState.leading)) : null;\n    if (layout.getEditingTab() === node) {\n        content = (react__WEBPACK_IMPORTED_MODULE_0__.createElement(\"input\", { ref: contentRef, className: cm(_Types__WEBPACK_IMPORTED_MODULE_4__.CLASSES.FLEXLAYOUT__TAB_BUTTON_TEXTBOX), \"data-layout-path\": path + \"/textbox\", type: \"text\", autoFocus: true, defaultValue: node.getName(), onKeyDown: onTextBoxKeyPress, onPointerDown: onTextBoxPointerDown }));\n    }\n    if (node.isEnableClose() && !isStretch) {\n        const closeTitle = layout.i18nName(_I18nLabel__WEBPACK_IMPORTED_MODULE_1__.I18nLabel.Close_Tab);\n        renderState.buttons.push(react__WEBPACK_IMPORTED_MODULE_0__.createElement(\"div\", { key: \"close\", \"data-layout-path\": path + \"/button/close\", title: closeTitle, className: cm(_Types__WEBPACK_IMPORTED_MODULE_4__.CLASSES.FLEXLAYOUT__TAB_BUTTON_TRAILING), onPointerDown: onClosePointerDown, onClick: onClose }, (typeof icons.close === \"function\") ? icons.close(node) : icons.close));\n    }\n    return (react__WEBPACK_IMPORTED_MODULE_0__.createElement(\"div\", { ref: selfRef, \"data-layout-path\": path, className: classNames, onClick: onClick, onAuxClick: onAuxMouseClick, onContextMenu: onContextMenu, title: node.getHelpText(), draggable: true, onDragStart: onDragStart, onDragEnd: onDragEnd, onDoubleClick: onDoubleClick },\n        leading,\n        content,\n        renderState.buttons));\n};\n\n\n//# sourceURL=webpack://FlexLayout/./src/view/TabButton.tsx?");

/***/ }),

/***/ "./src/view/TabButtonStamp.tsx":
/*!*************************************!*\
  !*** ./src/view/TabButtonStamp.tsx ***!
  \*************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   TabButtonStamp: () => (/* binding */ TabButtonStamp)\n/* harmony export */ });\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react */ \"react\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony import */ var _Types__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../Types */ \"./src/Types.ts\");\n/* harmony import */ var _Utils__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./Utils */ \"./src/view/Utils.tsx\");\n\n\n\n/** @internal */\nconst TabButtonStamp = (props) => {\n    const { layout, node } = props;\n    const cm = layout.getClassName;\n    let classNames = cm(_Types__WEBPACK_IMPORTED_MODULE_1__.CLASSES.FLEXLAYOUT__TAB_BUTTON_STAMP);\n    const renderState = (0,_Utils__WEBPACK_IMPORTED_MODULE_2__.getRenderStateEx)(layout, node);\n    let content = renderState.content ? (react__WEBPACK_IMPORTED_MODULE_0__.createElement(\"div\", { className: cm(_Types__WEBPACK_IMPORTED_MODULE_1__.CLASSES.FLEXLAYOUT__TAB_BUTTON_CONTENT) }, renderState.content))\n        : node.getNameForOverflowMenu();\n    const leading = renderState.leading ? (react__WEBPACK_IMPORTED_MODULE_0__.createElement(\"div\", { className: cm(_Types__WEBPACK_IMPORTED_MODULE_1__.CLASSES.FLEXLAYOUT__TAB_BUTTON_LEADING) }, renderState.leading)) : null;\n    return (react__WEBPACK_IMPORTED_MODULE_0__.createElement(\"div\", { className: classNames, title: node.getHelpText() },\n        leading,\n        content));\n};\n\n\n//# sourceURL=webpack://FlexLayout/./src/view/TabButtonStamp.tsx?");

/***/ }),

/***/ "./src/view/TabOverflowHook.tsx":
/*!**************************************!*\
  !*** ./src/view/TabOverflowHook.tsx ***!
  \**************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   useTabOverflow: () => (/* binding */ useTabOverflow)\n/* harmony export */ });\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react */ \"react\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony import */ var _Rect__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../Rect */ \"./src/Rect.ts\");\n/* harmony import */ var _model_TabSetNode__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../model/TabSetNode */ \"./src/model/TabSetNode.ts\");\n/* harmony import */ var _Orientation__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../Orientation */ \"./src/Orientation.ts\");\n\n\n\n\n/** @internal */\nconst useTabOverflow = (node, orientation, toolbarRef, stickyButtonsRef) => {\n    const firstRender = react__WEBPACK_IMPORTED_MODULE_0__.useRef(true);\n    const tabsTruncated = react__WEBPACK_IMPORTED_MODULE_0__.useRef(false);\n    const lastRect = react__WEBPACK_IMPORTED_MODULE_0__.useRef(_Rect__WEBPACK_IMPORTED_MODULE_1__.Rect.empty());\n    const selfRef = react__WEBPACK_IMPORTED_MODULE_0__.useRef(null);\n    const [position, setPosition] = react__WEBPACK_IMPORTED_MODULE_0__.useState(0);\n    const userControlledLeft = react__WEBPACK_IMPORTED_MODULE_0__.useRef(false);\n    const [hiddenTabs, setHiddenTabs] = react__WEBPACK_IMPORTED_MODULE_0__.useState([]);\n    const lastHiddenCount = react__WEBPACK_IMPORTED_MODULE_0__.useRef(0);\n    // if selected node or tabset/border rectangle change then unset usercontrolled (so selected tab will be kept in view)\n    react__WEBPACK_IMPORTED_MODULE_0__.useLayoutEffect(() => {\n        userControlledLeft.current = false;\n    }, [node.getSelectedNode(), node.getRect().width, node.getRect().height]);\n    react__WEBPACK_IMPORTED_MODULE_0__.useLayoutEffect(() => {\n        const nodeRect = node instanceof _model_TabSetNode__WEBPACK_IMPORTED_MODULE_2__.TabSetNode ? node.getRect() : node.getTabHeaderRect();\n        if (nodeRect.width > 0 && nodeRect.height > 0) {\n            updateVisibleTabs();\n        }\n    });\n    const instance = toolbarRef.current;\n    react__WEBPACK_IMPORTED_MODULE_0__.useEffect(() => {\n        if (!instance) {\n            return;\n        }\n        instance.addEventListener(\"wheel\", onWheel, { passive: false });\n        return () => {\n            instance.removeEventListener(\"wheel\", onWheel);\n        };\n    }, [instance]);\n    // needed to prevent default mouse wheel over tabset/border (cannot do with react event?)\n    const onWheel = (event) => {\n        event.preventDefault();\n    };\n    const getNear = (rect) => {\n        if (orientation === _Orientation__WEBPACK_IMPORTED_MODULE_3__.Orientation.HORZ) {\n            return rect.x;\n        }\n        else {\n            return rect.y;\n        }\n    };\n    const getFar = (rect) => {\n        if (orientation === _Orientation__WEBPACK_IMPORTED_MODULE_3__.Orientation.HORZ) {\n            return rect.getRight();\n        }\n        else {\n            return rect.getBottom();\n        }\n    };\n    const getSize = (rect) => {\n        if (orientation === _Orientation__WEBPACK_IMPORTED_MODULE_3__.Orientation.HORZ) {\n            return rect.width;\n        }\n        else {\n            return rect.height;\n        }\n    };\n    const updateVisibleTabs = () => {\n        const tabMargin = 2;\n        if (firstRender.current === true) {\n            tabsTruncated.current = false;\n        }\n        const nodeRect = node instanceof _model_TabSetNode__WEBPACK_IMPORTED_MODULE_2__.TabSetNode ? node.getRect() : node.getTabHeaderRect();\n        let lastChild = node.getChildren()[node.getChildren().length - 1];\n        const stickyButtonsSize = stickyButtonsRef.current === null ? 0 : getSize(stickyButtonsRef.current.getBoundingClientRect());\n        if (firstRender.current === true ||\n            (lastHiddenCount.current === 0 && hiddenTabs.length !== 0) ||\n            nodeRect.width !== lastRect.current.width || // incase rect changed between first render and second\n            nodeRect.height !== lastRect.current.height) {\n            lastHiddenCount.current = hiddenTabs.length;\n            lastRect.current = nodeRect;\n            const enabled = node instanceof _model_TabSetNode__WEBPACK_IMPORTED_MODULE_2__.TabSetNode ? node.isEnableTabStrip() === true : true;\n            let endPos = getFar(nodeRect) - stickyButtonsSize;\n            if (toolbarRef.current !== null) {\n                endPos -= getSize(toolbarRef.current.getBoundingClientRect());\n            }\n            if (enabled && node.getChildren().length > 0) {\n                if (hiddenTabs.length === 0 && position === 0 && getFar(lastChild.getTabRect()) + tabMargin < endPos) {\n                    return; // nothing to do all tabs are shown in available space\n                }\n                let shiftPos = 0;\n                const selectedTab = node.getSelectedNode();\n                if (selectedTab && !userControlledLeft.current) {\n                    const selectedRect = selectedTab.getTabRect();\n                    const selectedStart = getNear(selectedRect) - tabMargin;\n                    const selectedEnd = getFar(selectedRect) + tabMargin;\n                    // when selected tab is larger than available space then align left\n                    if (getSize(selectedRect) + 2 * tabMargin >= endPos - getNear(nodeRect)) {\n                        shiftPos = getNear(nodeRect) - selectedStart;\n                        // console.log(\"shiftPos1\", shiftPos, getNear(nodeRect), selectedStart);\n                    }\n                    else {\n                        if (selectedEnd > endPos || selectedStart < getNear(nodeRect)) {\n                            if (selectedStart < getNear(nodeRect)) {\n                                shiftPos = getNear(nodeRect) - selectedStart;\n                                // console.log(\"shiftPos2\", shiftPos, getNear(nodeRect), selectedStart);\n                            }\n                            // use second if statement to prevent tab moving back then forwards if not enough space for single tab\n                            if (selectedEnd + shiftPos > endPos) {\n                                shiftPos = endPos - selectedEnd;\n                            }\n                        }\n                    }\n                }\n                const extraSpace = Math.max(0, endPos - (getFar(lastChild.getTabRect()) + tabMargin + shiftPos));\n                const newPosition = Math.min(0, position + shiftPos + extraSpace);\n                // console.log(\"newPosition\", newPosition, position, shiftPos, extraSpace);\n                // find hidden tabs\n                const diff = newPosition - position;\n                const hidden = [];\n                for (let i = 0; i < node.getChildren().length; i++) {\n                    const child = node.getChildren()[i];\n                    if (getNear(child.getTabRect()) + diff < getNear(nodeRect) || getFar(child.getTabRect()) + diff > endPos) {\n                        hidden.push({ node: child, index: i });\n                    }\n                }\n                tabsTruncated.current = hidden.length > 0;\n                firstRender.current = false; // need to do a second render\n                setHiddenTabs(hidden);\n                // console.log(newPosition);\n                setPosition(newPosition);\n            }\n        }\n        else {\n            firstRender.current = true;\n        }\n    };\n    const onMouseWheel = (event) => {\n        let delta = 0;\n        if (Math.abs(event.deltaX) > Math.abs(event.deltaY)) {\n            delta = -event.deltaX;\n        }\n        else {\n            delta = -event.deltaY;\n        }\n        if (event.deltaMode === 1) {\n            // DOM_DELTA_LINE\t0x01\tThe delta values are specified in lines.\n            delta *= 40;\n        }\n        setPosition(position + delta);\n        userControlledLeft.current = true;\n        event.stopPropagation();\n    };\n    return { selfRef, position, userControlledLeft, hiddenTabs, onMouseWheel, tabsTruncated: tabsTruncated.current };\n};\n\n\n//# sourceURL=webpack://FlexLayout/./src/view/TabOverflowHook.tsx?");

/***/ }),

/***/ "./src/view/TabSet.tsx":
/*!*****************************!*\
  !*** ./src/view/TabSet.tsx ***!
  \*****************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   TabSet: () => (/* binding */ TabSet)\n/* harmony export */ });\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react */ \"react\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony import */ var _I18nLabel__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../I18nLabel */ \"./src/I18nLabel.ts\");\n/* harmony import */ var _model_Actions__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../model/Actions */ \"./src/model/Actions.ts\");\n/* harmony import */ var _PopupMenu__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./PopupMenu */ \"./src/view/PopupMenu.tsx\");\n/* harmony import */ var _TabButton__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./TabButton */ \"./src/view/TabButton.tsx\");\n/* harmony import */ var _TabOverflowHook__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./TabOverflowHook */ \"./src/view/TabOverflowHook.tsx\");\n/* harmony import */ var _Orientation__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ../Orientation */ \"./src/Orientation.ts\");\n/* harmony import */ var _Types__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ../Types */ \"./src/Types.ts\");\n/* harmony import */ var _Utils__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ./Utils */ \"./src/view/Utils.tsx\");\n/* harmony import */ var react_dom__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! react-dom */ \"react-dom\");\n/* harmony import */ var react_dom__WEBPACK_IMPORTED_MODULE_9___default = /*#__PURE__*/__webpack_require__.n(react_dom__WEBPACK_IMPORTED_MODULE_9__);\n/* harmony import */ var _Rect__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! ../Rect */ \"./src/Rect.ts\");\n\n\n\n\n\n\n\n\n\n\n\n/** @internal */\nconst TabSet = (props) => {\n    const { node, layout } = props;\n    const tabStripRef = react__WEBPACK_IMPORTED_MODULE_0__.useRef(null);\n    const tabStripInnerRef = react__WEBPACK_IMPORTED_MODULE_0__.useRef(null);\n    const contentRef = react__WEBPACK_IMPORTED_MODULE_0__.useRef(null);\n    const buttonBarRef = react__WEBPACK_IMPORTED_MODULE_0__.useRef(null);\n    const overflowbuttonRef = react__WEBPACK_IMPORTED_MODULE_0__.useRef(null);\n    const stickyButtonsRef = react__WEBPACK_IMPORTED_MODULE_0__.useRef(null);\n    const icons = layout.getIcons();\n    // must use useEffect (rather than useLayoutEffect) otherwise contentrect not set correctly (has height 0 when changing theme in demo)\n    react__WEBPACK_IMPORTED_MODULE_0__.useEffect(() => {\n        node.setRect(layout.getBoundingClientRect(selfRef.current));\n        if (tabStripRef.current) {\n            node.setTabStripRect(layout.getBoundingClientRect(tabStripRef.current));\n        }\n        const newContentRect = _Rect__WEBPACK_IMPORTED_MODULE_10__.Rect.getContentRect(contentRef.current).relativeTo(layout.getDomRect());\n        if (!node.getContentRect().equals(newContentRect)) {\n            node.setContentRect(newContentRect);\n            layout.redrawInternal(\"tabset content rect \" + newContentRect);\n        }\n    });\n    // this must be after the useEffect, so the node rect is already set (else window popin will not position tabs correctly)\n    const { selfRef, position, userControlledLeft, hiddenTabs, onMouseWheel, tabsTruncated } = (0,_TabOverflowHook__WEBPACK_IMPORTED_MODULE_5__.useTabOverflow)(node, _Orientation__WEBPACK_IMPORTED_MODULE_6__.Orientation.HORZ, buttonBarRef, stickyButtonsRef);\n    const onOverflowClick = (event) => {\n        const callback = layout.getShowOverflowMenu();\n        if (callback !== undefined) {\n            callback(node, event, hiddenTabs, onOverflowItemSelect);\n        }\n        else {\n            const element = overflowbuttonRef.current;\n            (0,_PopupMenu__WEBPACK_IMPORTED_MODULE_3__.showPopup)(element, hiddenTabs, onOverflowItemSelect, layout);\n        }\n        event.stopPropagation();\n    };\n    const onOverflowItemSelect = (item) => {\n        layout.doAction(_model_Actions__WEBPACK_IMPORTED_MODULE_2__.Actions.selectTab(item.node.getId()));\n        userControlledLeft.current = false;\n    };\n    const onDragStart = (event) => {\n        if (!layout.getEditingTab()) {\n            event.stopPropagation();\n            layout.setDragNode(event.nativeEvent, node);\n        }\n        else {\n            event.preventDefault();\n        }\n    };\n    const onPointerDown = (event) => {\n        if (!(0,_Utils__WEBPACK_IMPORTED_MODULE_8__.isAuxMouseEvent)(event)) {\n            let name = node.getName();\n            if (name === undefined) {\n                name = \"\";\n            }\n            else {\n                name = \": \" + name;\n            }\n            layout.doAction(_model_Actions__WEBPACK_IMPORTED_MODULE_2__.Actions.setActiveTabset(node.getId(), layout.getWindowId()));\n        }\n    };\n    const onAuxMouseClick = (event) => {\n        if ((0,_Utils__WEBPACK_IMPORTED_MODULE_8__.isAuxMouseEvent)(event)) {\n            layout.auxMouseClick(node, event);\n        }\n    };\n    const onContextMenu = (event) => {\n        layout.showContextMenu(node, event);\n    };\n    const onInterceptPointerDown = (event) => {\n        event.stopPropagation();\n    };\n    const onMaximizeToggle = (event) => {\n        if (node.canMaximize()) {\n            layout.maximize(node);\n        }\n        event.stopPropagation();\n    };\n    const onClose = (event) => {\n        layout.doAction(_model_Actions__WEBPACK_IMPORTED_MODULE_2__.Actions.deleteTabset(node.getId()));\n        event.stopPropagation();\n    };\n    const onCloseTab = (event) => {\n        layout.doAction(_model_Actions__WEBPACK_IMPORTED_MODULE_2__.Actions.deleteTab(node.getChildren()[0].getId()));\n        event.stopPropagation();\n    };\n    const onPopoutTab = (event) => {\n        if (selectedTabNode !== undefined) {\n            layout.doAction(_model_Actions__WEBPACK_IMPORTED_MODULE_2__.Actions.popoutTab(selectedTabNode.getId()));\n            // layout.doAction(Actions.popoutTabset(node.getId()));\n        }\n        event.stopPropagation();\n    };\n    const onDoubleClick = (event) => {\n        if (node.canMaximize()) {\n            layout.maximize(node);\n        }\n    };\n    // Start Render\n    const cm = layout.getClassName;\n    // tabbar inner can get shifted left via tab rename, this resets scrollleft to 0\n    if (tabStripInnerRef.current !== null && tabStripInnerRef.current.scrollLeft !== 0) {\n        tabStripInnerRef.current.scrollLeft = 0;\n    }\n    const selectedTabNode = node.getSelectedNode();\n    const path = node.getPath();\n    const tabs = [];\n    if (node.isEnableTabStrip()) {\n        for (let i = 0; i < node.getChildren().length; i++) {\n            const child = node.getChildren()[i];\n            let isSelected = node.getSelected() === i;\n            tabs.push(react__WEBPACK_IMPORTED_MODULE_0__.createElement(_TabButton__WEBPACK_IMPORTED_MODULE_4__.TabButton, { layout: layout, node: child, path: path + \"/tb\" + i, key: child.getId(), selected: isSelected }));\n            if (i < node.getChildren().length - 1) {\n                tabs.push(react__WEBPACK_IMPORTED_MODULE_0__.createElement(\"div\", { key: \"divider\" + i, className: cm(_Types__WEBPACK_IMPORTED_MODULE_7__.CLASSES.FLEXLAYOUT__TABSET_TAB_DIVIDER) }));\n            }\n        }\n    }\n    let stickyButtons = [];\n    let buttons = [];\n    // allow customization of header contents and buttons\n    const renderState = { stickyButtons, buttons, overflowPosition: undefined };\n    layout.customizeTabSet(node, renderState);\n    stickyButtons = renderState.stickyButtons;\n    buttons = renderState.buttons;\n    const isTabStretch = node.isEnableSingleTabStretch() && node.getChildren().length === 1;\n    const showClose = (isTabStretch && (node.getChildren()[0].isEnableClose())) || node.isEnableClose();\n    if (renderState.overflowPosition === undefined) {\n        renderState.overflowPosition = stickyButtons.length;\n    }\n    if (stickyButtons.length > 0) {\n        if (!node.isEnableTabWrap() && (tabsTruncated || isTabStretch)) {\n            buttons = [...stickyButtons, ...buttons];\n        }\n        else {\n            tabs.push(react__WEBPACK_IMPORTED_MODULE_0__.createElement(\"div\", { ref: stickyButtonsRef, key: \"sticky_buttons_container\", onPointerDown: onInterceptPointerDown, onDragStart: (e) => { e.preventDefault(); }, className: cm(_Types__WEBPACK_IMPORTED_MODULE_7__.CLASSES.FLEXLAYOUT__TAB_TOOLBAR_STICKY_BUTTONS_CONTAINER) }, stickyButtons));\n        }\n    }\n    if (!node.isEnableTabWrap()) {\n        if (hiddenTabs.length > 0) {\n            const overflowTitle = layout.i18nName(_I18nLabel__WEBPACK_IMPORTED_MODULE_1__.I18nLabel.Overflow_Menu_Tooltip);\n            let overflowContent;\n            if (typeof icons.more === \"function\") {\n                overflowContent = icons.more(node, hiddenTabs);\n            }\n            else {\n                overflowContent = (react__WEBPACK_IMPORTED_MODULE_0__.createElement(react__WEBPACK_IMPORTED_MODULE_0__.Fragment, null,\n                    icons.more,\n                    react__WEBPACK_IMPORTED_MODULE_0__.createElement(\"div\", { className: cm(_Types__WEBPACK_IMPORTED_MODULE_7__.CLASSES.FLEXLAYOUT__TAB_BUTTON_OVERFLOW_COUNT) }, hiddenTabs.length)));\n            }\n            buttons.splice(Math.min(renderState.overflowPosition, buttons.length), 0, react__WEBPACK_IMPORTED_MODULE_0__.createElement(\"button\", { key: \"overflowbutton\", \"data-layout-path\": path + \"/button/overflow\", ref: overflowbuttonRef, className: cm(_Types__WEBPACK_IMPORTED_MODULE_7__.CLASSES.FLEXLAYOUT__TAB_TOOLBAR_BUTTON) + \" \" + cm(_Types__WEBPACK_IMPORTED_MODULE_7__.CLASSES.FLEXLAYOUT__TAB_BUTTON_OVERFLOW), title: overflowTitle, onClick: onOverflowClick, onPointerDown: onInterceptPointerDown }, overflowContent));\n        }\n    }\n    if (selectedTabNode !== undefined &&\n        layout.isSupportsPopout() &&\n        selectedTabNode.isEnablePopout() &&\n        selectedTabNode.isEnablePopoutIcon()) {\n        const popoutTitle = layout.i18nName(_I18nLabel__WEBPACK_IMPORTED_MODULE_1__.I18nLabel.Popout_Tab);\n        buttons.push(react__WEBPACK_IMPORTED_MODULE_0__.createElement(\"button\", { key: \"popout\", \"data-layout-path\": path + \"/button/popout\", title: popoutTitle, className: cm(_Types__WEBPACK_IMPORTED_MODULE_7__.CLASSES.FLEXLAYOUT__TAB_TOOLBAR_BUTTON) + \" \" + cm(_Types__WEBPACK_IMPORTED_MODULE_7__.CLASSES.FLEXLAYOUT__TAB_TOOLBAR_BUTTON_FLOAT), onClick: onPopoutTab, onPointerDown: onInterceptPointerDown }, (typeof icons.popout === \"function\") ? icons.popout(selectedTabNode) : icons.popout));\n    }\n    if (node.canMaximize()) {\n        const minTitle = layout.i18nName(_I18nLabel__WEBPACK_IMPORTED_MODULE_1__.I18nLabel.Restore);\n        const maxTitle = layout.i18nName(_I18nLabel__WEBPACK_IMPORTED_MODULE_1__.I18nLabel.Maximize);\n        buttons.push(react__WEBPACK_IMPORTED_MODULE_0__.createElement(\"button\", { key: \"max\", \"data-layout-path\": path + \"/button/max\", title: node.isMaximized() ? minTitle : maxTitle, className: cm(_Types__WEBPACK_IMPORTED_MODULE_7__.CLASSES.FLEXLAYOUT__TAB_TOOLBAR_BUTTON) + \" \" + cm(_Types__WEBPACK_IMPORTED_MODULE_7__.CLASSES.FLEXLAYOUT__TAB_TOOLBAR_BUTTON_ + (node.isMaximized() ? \"max\" : \"min\")), onClick: onMaximizeToggle, onPointerDown: onInterceptPointerDown }, node.isMaximized() ?\n            (typeof icons.restore === \"function\") ? icons.restore(node) : icons.restore :\n            (typeof icons.maximize === \"function\") ? icons.maximize(node) : icons.maximize));\n    }\n    if (!node.isMaximized() && showClose) {\n        const title = isTabStretch ? layout.i18nName(_I18nLabel__WEBPACK_IMPORTED_MODULE_1__.I18nLabel.Close_Tab) : layout.i18nName(_I18nLabel__WEBPACK_IMPORTED_MODULE_1__.I18nLabel.Close_Tabset);\n        buttons.push(react__WEBPACK_IMPORTED_MODULE_0__.createElement(\"button\", { key: \"close\", \"data-layout-path\": path + \"/button/close\", title: title, className: cm(_Types__WEBPACK_IMPORTED_MODULE_7__.CLASSES.FLEXLAYOUT__TAB_TOOLBAR_BUTTON) + \" \" + cm(_Types__WEBPACK_IMPORTED_MODULE_7__.CLASSES.FLEXLAYOUT__TAB_TOOLBAR_BUTTON_CLOSE), onClick: isTabStretch ? onCloseTab : onClose, onPointerDown: onInterceptPointerDown }, (typeof icons.closeTabset === \"function\") ? icons.closeTabset(node) : icons.closeTabset));\n    }\n    if (node.isActive() && node.isEnableActiveIcon()) {\n        const title = layout.i18nName(_I18nLabel__WEBPACK_IMPORTED_MODULE_1__.I18nLabel.Active_Tabset);\n        buttons.push(react__WEBPACK_IMPORTED_MODULE_0__.createElement(\"div\", { key: \"active\", \"data-layout-path\": path + \"/button/active\", title: title, className: cm(_Types__WEBPACK_IMPORTED_MODULE_7__.CLASSES.FLEXLAYOUT__TAB_TOOLBAR_ICON) }, (typeof icons.activeTabset === \"function\") ? icons.activeTabset(node) : icons.activeTabset));\n    }\n    const buttonbar = (react__WEBPACK_IMPORTED_MODULE_0__.createElement(\"div\", { key: \"buttonbar\", ref: buttonBarRef, className: cm(_Types__WEBPACK_IMPORTED_MODULE_7__.CLASSES.FLEXLAYOUT__TAB_TOOLBAR), onPointerDown: onInterceptPointerDown, onDragStart: (e) => { e.preventDefault(); } }, buttons));\n    let tabStrip;\n    let tabStripClasses = cm(_Types__WEBPACK_IMPORTED_MODULE_7__.CLASSES.FLEXLAYOUT__TABSET_TABBAR_OUTER);\n    if (node.getClassNameTabStrip() !== undefined) {\n        tabStripClasses += \" \" + node.getClassNameTabStrip();\n    }\n    tabStripClasses += \" \" + _Types__WEBPACK_IMPORTED_MODULE_7__.CLASSES.FLEXLAYOUT__TABSET_TABBAR_OUTER_ + node.getTabLocation();\n    if (node.isActive()) {\n        tabStripClasses += \" \" + cm(_Types__WEBPACK_IMPORTED_MODULE_7__.CLASSES.FLEXLAYOUT__TABSET_SELECTED);\n    }\n    if (node.isMaximized()) {\n        tabStripClasses += \" \" + cm(_Types__WEBPACK_IMPORTED_MODULE_7__.CLASSES.FLEXLAYOUT__TABSET_MAXIMIZED);\n    }\n    if (isTabStretch) {\n        const tabNode = node.getChildren()[0];\n        if (tabNode.getTabSetClassName() !== undefined) {\n            tabStripClasses += \" \" + tabNode.getTabSetClassName();\n        }\n    }\n    if (node.isEnableTabWrap()) {\n        if (node.isEnableTabStrip()) {\n            tabStrip = (react__WEBPACK_IMPORTED_MODULE_0__.createElement(\"div\", { className: tabStripClasses, style: { flexWrap: \"wrap\", gap: \"1px\", marginTop: \"2px\" }, ref: tabStripRef, \"data-layout-path\": path + \"/tabstrip\", onPointerDown: onPointerDown, onDoubleClick: onDoubleClick, onContextMenu: onContextMenu, onClick: onAuxMouseClick, onAuxClick: onAuxMouseClick, draggable: true, onDragStart: onDragStart },\n                tabs,\n                react__WEBPACK_IMPORTED_MODULE_0__.createElement(\"div\", { style: { flexGrow: 1 } }),\n                buttonbar));\n        }\n    }\n    else {\n        if (node.isEnableTabStrip()) {\n            tabStrip = (react__WEBPACK_IMPORTED_MODULE_0__.createElement(\"div\", { className: tabStripClasses, ref: tabStripRef, \"data-layout-path\": path + \"/tabstrip\", onPointerDown: onPointerDown, onDoubleClick: onDoubleClick, onContextMenu: onContextMenu, onClick: onAuxMouseClick, onAuxClick: onAuxMouseClick, draggable: true, onWheel: onMouseWheel, onDragStart: onDragStart },\n                react__WEBPACK_IMPORTED_MODULE_0__.createElement(\"div\", { ref: tabStripInnerRef, className: cm(_Types__WEBPACK_IMPORTED_MODULE_7__.CLASSES.FLEXLAYOUT__TABSET_TABBAR_INNER) + \" \" + cm(_Types__WEBPACK_IMPORTED_MODULE_7__.CLASSES.FLEXLAYOUT__TABSET_TABBAR_INNER_ + node.getTabLocation()) },\n                    react__WEBPACK_IMPORTED_MODULE_0__.createElement(\"div\", { style: { left: position, width: (isTabStretch ? \"100%\" : \"10000px\") }, className: cm(_Types__WEBPACK_IMPORTED_MODULE_7__.CLASSES.FLEXLAYOUT__TABSET_TABBAR_INNER_TAB_CONTAINER) + \" \" + cm(_Types__WEBPACK_IMPORTED_MODULE_7__.CLASSES.FLEXLAYOUT__TABSET_TABBAR_INNER_TAB_CONTAINER_ + node.getTabLocation()) }, tabs)),\n                buttonbar));\n        }\n    }\n    var emptyTabset;\n    if (node.getChildren().length === 0) {\n        const placeHolderCallback = layout.getTabSetPlaceHolderCallback();\n        if (placeHolderCallback) {\n            emptyTabset = placeHolderCallback(node);\n        }\n    }\n    let content = react__WEBPACK_IMPORTED_MODULE_0__.createElement(\"div\", { ref: contentRef, className: cm(_Types__WEBPACK_IMPORTED_MODULE_7__.CLASSES.FLEXLAYOUT__TABSET_CONTENT) }, emptyTabset);\n    if (node.getTabLocation() === \"top\") {\n        content = react__WEBPACK_IMPORTED_MODULE_0__.createElement(react__WEBPACK_IMPORTED_MODULE_0__.Fragment, null,\n            tabStrip,\n            content);\n    }\n    else {\n        content = react__WEBPACK_IMPORTED_MODULE_0__.createElement(react__WEBPACK_IMPORTED_MODULE_0__.Fragment, null,\n            content,\n            tabStrip);\n    }\n    let style = {\n        flexGrow: Math.max(1, node.getWeight() * 1000),\n        minWidth: node.getMinWidth(),\n        minHeight: node.getMinHeight(),\n        maxWidth: node.getMaxWidth(),\n        maxHeight: node.getMaxHeight()\n    };\n    if (node.getModel().getMaximizedTabset(layout.getWindowId()) !== undefined && !node.isMaximized()) {\n        style.display = \"none\";\n    }\n    // note: tabset container is needed to allow flexbox to size without border/padding/margin\n    // then inner tabset can have border/padding/margin for styling\n    const tabset = (react__WEBPACK_IMPORTED_MODULE_0__.createElement(\"div\", { ref: selfRef, className: cm(_Types__WEBPACK_IMPORTED_MODULE_7__.CLASSES.FLEXLAYOUT__TABSET_CONTAINER), style: style },\n        react__WEBPACK_IMPORTED_MODULE_0__.createElement(\"div\", { className: cm(_Types__WEBPACK_IMPORTED_MODULE_7__.CLASSES.FLEXLAYOUT__TABSET), \"data-layout-path\": path }, content)));\n    if (node.isMaximized()) {\n        if (layout.getMainElement()) {\n            return (0,react_dom__WEBPACK_IMPORTED_MODULE_9__.createPortal)(react__WEBPACK_IMPORTED_MODULE_0__.createElement(\"div\", { style: {\n                    position: \"absolute\",\n                    display: \"flex\",\n                    top: 0, left: 0, bottom: 0, right: 0\n                } }, tabset), layout.getMainElement());\n        }\n        else {\n            return tabset;\n        }\n    }\n    else {\n        return tabset;\n    }\n};\n\n\n//# sourceURL=webpack://FlexLayout/./src/view/TabSet.tsx?");

/***/ }),

/***/ "./src/view/Utils.tsx":
/*!****************************!*\
  !*** ./src/view/Utils.tsx ***!
  \****************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   canDockToWindow: () => (/* binding */ canDockToWindow),\n/* harmony export */   copyInlineStyles: () => (/* binding */ copyInlineStyles),\n/* harmony export */   enablePointerOnIFrames: () => (/* binding */ enablePointerOnIFrames),\n/* harmony export */   getElementsByTagName: () => (/* binding */ getElementsByTagName),\n/* harmony export */   getRenderStateEx: () => (/* binding */ getRenderStateEx),\n/* harmony export */   isAuxMouseEvent: () => (/* binding */ isAuxMouseEvent),\n/* harmony export */   isDesktop: () => (/* binding */ isDesktop),\n/* harmony export */   isOnScreen: () => (/* binding */ isOnScreen),\n/* harmony export */   isSafari: () => (/* binding */ isSafari),\n/* harmony export */   keepOnScreen: () => (/* binding */ keepOnScreen),\n/* harmony export */   startDrag: () => (/* binding */ startDrag)\n/* harmony export */ });\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react */ \"react\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony import */ var _model_TabNode__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../model/TabNode */ \"./src/model/TabNode.ts\");\n/* harmony import */ var _model_TabSetNode__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../model/TabSetNode */ \"./src/model/TabSetNode.ts\");\n\n\n\n/** @internal */\nfunction isDesktop() {\n    const desktop = typeof window !== \"undefined\" && window.matchMedia && window.matchMedia(\"(hover: hover) and (pointer: fine)\").matches;\n    return desktop;\n}\n/** @internal */\nfunction getRenderStateEx(layout, node, iconAngle) {\n    let leadingContent = undefined;\n    let titleContent = node.getName();\n    let name = node.getName();\n    if (iconAngle === undefined) {\n        iconAngle = 0;\n    }\n    if (leadingContent === undefined && node.getIcon() !== undefined) {\n        if (iconAngle !== 0) {\n            leadingContent = react__WEBPACK_IMPORTED_MODULE_0__.createElement(\"img\", { style: { width: \"1em\", height: \"1em\", transform: \"rotate(\" + iconAngle + \"deg)\" }, src: node.getIcon(), alt: \"leadingContent\" });\n        }\n        else {\n            leadingContent = react__WEBPACK_IMPORTED_MODULE_0__.createElement(\"img\", { style: { width: \"1em\", height: \"1em\" }, src: node.getIcon(), alt: \"leadingContent\" });\n        }\n    }\n    let buttons = [];\n    // allow customization of leading contents (icon) and contents\n    const renderState = { leading: leadingContent, content: titleContent, name, buttons };\n    layout.customizeTab(node, renderState);\n    node.setRenderedName(renderState.name);\n    return renderState;\n}\n/** @internal */\nfunction isAuxMouseEvent(event) {\n    let auxEvent = false;\n    if (event.nativeEvent instanceof MouseEvent) {\n        if (event.nativeEvent.button !== 0 || event.ctrlKey || event.altKey || event.metaKey || event.shiftKey) {\n            auxEvent = true;\n        }\n    }\n    return auxEvent;\n}\nfunction enablePointerOnIFrames(enable, currentDocument) {\n    const iframes = [\n        ...getElementsByTagName('iframe', currentDocument),\n        ...getElementsByTagName('webview', currentDocument),\n    ];\n    for (const iframe of iframes) {\n        iframe.style.pointerEvents = enable ? 'auto' : 'none';\n    }\n}\n;\nfunction getElementsByTagName(tag, currentDocument) {\n    return [...currentDocument.getElementsByTagName(tag)];\n}\nfunction startDrag(doc, event, drag, dragEnd, dragCancel) {\n    event.preventDefault();\n    const pointerMove = (ev) => {\n        ev.preventDefault();\n        drag(ev.clientX, ev.clientY);\n    };\n    const pointerCancel = (ev) => {\n        ev.preventDefault();\n        dragCancel();\n    };\n    const pointerUp = () => {\n        doc.removeEventListener(\"pointermove\", pointerMove);\n        doc.removeEventListener(\"pointerup\", pointerUp);\n        doc.removeEventListener(\"pointercancel\", pointerCancel);\n        dragEnd();\n    };\n    doc.addEventListener(\"pointermove\", pointerMove);\n    doc.addEventListener(\"pointerup\", pointerUp);\n    doc.addEventListener('pointercancel', pointerCancel);\n}\nfunction canDockToWindow(node) {\n    if (node instanceof _model_TabNode__WEBPACK_IMPORTED_MODULE_1__.TabNode) {\n        return node.isEnablePopout();\n    }\n    else if (node instanceof _model_TabSetNode__WEBPACK_IMPORTED_MODULE_2__.TabSetNode) {\n        for (const child of node.getChildren()) {\n            if (child.isEnablePopout() === false) {\n                return false;\n            }\n        }\n        return true;\n    }\n    return false;\n}\nfunction keepOnScreen(rect) {\n    rect.snap(10);\n    const availableScreenWidth = window.screen.availWidth;\n    const availableScreenHeight = window.screen.availHeight;\n    if (rect.x + rect.width > availableScreenWidth || rect.y + rect.height > availableScreenHeight) {\n        // Adjust the rectangle to fit within the available screen space\n        rect.x = Math.max(0, Math.min(rect.x, availableScreenWidth - rect.width));\n        rect.y = Math.max(0, Math.min(rect.y, availableScreenHeight - rect.height));\n    }\n    return rect;\n}\nfunction isOnScreen(rect) {\n    const availableScreenWidth = window.screen.availWidth;\n    const availableScreenHeight = window.screen.availHeight;\n    return (rect.x >= 0 && rect.getRight() <= availableScreenWidth &&\n        rect.y >= 0 || rect.getBottom() <= availableScreenHeight);\n}\nfunction copyInlineStyles(source, target) {\n    // Get the inline style attribute from the source element\n    const sourceStyle = source.getAttribute('style');\n    const targetStyle = target.getAttribute('style');\n    if (sourceStyle === targetStyle)\n        return false;\n    // console.log(\"copyInlineStyles\", sourceStyle);\n    if (sourceStyle) {\n        // Set the style attribute on the target element\n        target.setAttribute('style', sourceStyle);\n    }\n    else {\n        // If the source has no inline style, clear the target's style attribute\n        target.removeAttribute('style');\n    }\n    return true;\n}\nfunction isSafari() {\n    const userAgent = navigator.userAgent;\n    return userAgent.includes(\"Safari\") && !userAgent.includes(\"Chrome\") && !userAgent.includes(\"Chromium\");\n}\n\n\n//# sourceURL=webpack://FlexLayout/./src/view/Utils.tsx?");

/***/ }),

/***/ "react":
/*!**************************************************************************************!*\
  !*** external {"root":"React","commonjs":"react","commonjs2":"react","amd":"react"} ***!
  \**************************************************************************************/
/***/ ((module) => {

module.exports = __WEBPACK_EXTERNAL_MODULE_react__;

/***/ }),

/***/ "react-dom":
/*!*****************************************************************************************************!*\
  !*** external {"root":"ReactDOM","commonjs":"react-dom","commonjs2":"react-dom","amd":"react-dom"} ***!
  \*****************************************************************************************************/
/***/ ((module) => {

module.exports = __WEBPACK_EXTERNAL_MODULE_react_dom__;

/***/ })

/******/ 	});
/************************************************************************/
/******/ 	// The module cache
/******/ 	var __webpack_module_cache__ = {};
/******/ 	
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/ 		// Check if module is in cache
/******/ 		var cachedModule = __webpack_module_cache__[moduleId];
/******/ 		if (cachedModule !== undefined) {
/******/ 			return cachedModule.exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = __webpack_module_cache__[moduleId] = {
/******/ 			// no module.id needed
/******/ 			// no module.loaded needed
/******/ 			exports: {}
/******/ 		};
/******/ 	
/******/ 		// Execute the module function
/******/ 		__webpack_modules__[moduleId](module, module.exports, __webpack_require__);
/******/ 	
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/ 	
/************************************************************************/
/******/ 	/* webpack/runtime/compat get default export */
/******/ 	(() => {
/******/ 		// getDefaultExport function for compatibility with non-harmony modules
/******/ 		__webpack_require__.n = (module) => {
/******/ 			var getter = module && module.__esModule ?
/******/ 				() => (module['default']) :
/******/ 				() => (module);
/******/ 			__webpack_require__.d(getter, { a: getter });
/******/ 			return getter;
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/define property getters */
/******/ 	(() => {
/******/ 		// define getter functions for harmony exports
/******/ 		__webpack_require__.d = (exports, definition) => {
/******/ 			for(var key in definition) {
/******/ 				if(__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {
/******/ 					Object.defineProperty(exports, key, { enumerable: true, get: definition[key] });
/******/ 				}
/******/ 			}
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/hasOwnProperty shorthand */
/******/ 	(() => {
/******/ 		__webpack_require__.o = (obj, prop) => (Object.prototype.hasOwnProperty.call(obj, prop))
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/make namespace object */
/******/ 	(() => {
/******/ 		// define __esModule on exports
/******/ 		__webpack_require__.r = (exports) => {
/******/ 			if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 				Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 			}
/******/ 			Object.defineProperty(exports, '__esModule', { value: true });
/******/ 		};
/******/ 	})();
/******/ 	
/************************************************************************/
/******/ 	
/******/ 	// startup
/******/ 	// Load entry module and return exports
/******/ 	// This entry module can't be inlined because the eval devtool is used.
/******/ 	var __webpack_exports__ = __webpack_require__("./src/index.ts");
/******/ 	
/******/ 	return __webpack_exports__;
/******/ })()
;
});